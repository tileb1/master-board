
new_ioc_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006d18  080001d0  080001d0  000101d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000a0  08006ee8  08006ee8  00016ee8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08006f88  08006f88  00016f88  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08006f90  08006f90  00016f90  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08006f94  08006f94  00016f94  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000014  20000000  08006f98  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       000001a0  20000014  08006fac  00020014  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          000047e4  200001b4  0800714c  000201b4  2**2
                  ALLOC
  9 ._user_heap_stack 00000600  20004998  0800714c  00024998  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  000201b4  2**0
                  CONTENTS, READONLY
 11 .debug_info   000449af  00000000  00000000  000201e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00008844  00000000  00000000  00064b93  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00015785  00000000  00000000  0006d3d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001aa8  00000000  00000000  00082b60  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002488  00000000  00000000  00084608  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   000111f2  00000000  00000000  00086a90  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00009bf4  00000000  00000000  00097c82  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007c  00000000  00000000  000a1876  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004ff4  00000000  00000000  000a18f4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001d0 <__do_global_dtors_aux>:
 80001d0:	b510      	push	{r4, lr}
 80001d2:	4c05      	ldr	r4, [pc, #20]	; (80001e8 <__do_global_dtors_aux+0x18>)
 80001d4:	7823      	ldrb	r3, [r4, #0]
 80001d6:	b933      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x16>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x1c>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x12>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x20>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	200001b4 	.word	0x200001b4
 80001ec:	00000000 	.word	0x00000000
 80001f0:	08006ed0 	.word	0x08006ed0

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b03      	ldr	r3, [pc, #12]	; (8000204 <frame_dummy+0x10>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4903      	ldr	r1, [pc, #12]	; (8000208 <frame_dummy+0x14>)
 80001fc:	4803      	ldr	r0, [pc, #12]	; (800020c <frame_dummy+0x18>)
 80001fe:	f3af 8000 	nop.w
 8000202:	bd08      	pop	{r3, pc}
 8000204:	00000000 	.word	0x00000000
 8000208:	200001b8 	.word	0x200001b8
 800020c:	08006ed0 	.word	0x08006ed0

08000210 <__aeabi_uldivmod>:
 8000210:	b953      	cbnz	r3, 8000228 <__aeabi_uldivmod+0x18>
 8000212:	b94a      	cbnz	r2, 8000228 <__aeabi_uldivmod+0x18>
 8000214:	2900      	cmp	r1, #0
 8000216:	bf08      	it	eq
 8000218:	2800      	cmpeq	r0, #0
 800021a:	bf1c      	itt	ne
 800021c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000220:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000224:	f000 b97a 	b.w	800051c <__aeabi_idiv0>
 8000228:	f1ad 0c08 	sub.w	ip, sp, #8
 800022c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000230:	f000 f806 	bl	8000240 <__udivmoddi4>
 8000234:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000238:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800023c:	b004      	add	sp, #16
 800023e:	4770      	bx	lr

08000240 <__udivmoddi4>:
 8000240:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000244:	468c      	mov	ip, r1
 8000246:	460d      	mov	r5, r1
 8000248:	4604      	mov	r4, r0
 800024a:	9e08      	ldr	r6, [sp, #32]
 800024c:	2b00      	cmp	r3, #0
 800024e:	d151      	bne.n	80002f4 <__udivmoddi4+0xb4>
 8000250:	428a      	cmp	r2, r1
 8000252:	4617      	mov	r7, r2
 8000254:	d96d      	bls.n	8000332 <__udivmoddi4+0xf2>
 8000256:	fab2 fe82 	clz	lr, r2
 800025a:	f1be 0f00 	cmp.w	lr, #0
 800025e:	d00b      	beq.n	8000278 <__udivmoddi4+0x38>
 8000260:	f1ce 0c20 	rsb	ip, lr, #32
 8000264:	fa01 f50e 	lsl.w	r5, r1, lr
 8000268:	fa20 fc0c 	lsr.w	ip, r0, ip
 800026c:	fa02 f70e 	lsl.w	r7, r2, lr
 8000270:	ea4c 0c05 	orr.w	ip, ip, r5
 8000274:	fa00 f40e 	lsl.w	r4, r0, lr
 8000278:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800027c:	0c25      	lsrs	r5, r4, #16
 800027e:	fbbc f8fa 	udiv	r8, ip, sl
 8000282:	fa1f f987 	uxth.w	r9, r7
 8000286:	fb0a cc18 	mls	ip, sl, r8, ip
 800028a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800028e:	fb08 f309 	mul.w	r3, r8, r9
 8000292:	42ab      	cmp	r3, r5
 8000294:	d90a      	bls.n	80002ac <__udivmoddi4+0x6c>
 8000296:	19ed      	adds	r5, r5, r7
 8000298:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 800029c:	f080 8123 	bcs.w	80004e6 <__udivmoddi4+0x2a6>
 80002a0:	42ab      	cmp	r3, r5
 80002a2:	f240 8120 	bls.w	80004e6 <__udivmoddi4+0x2a6>
 80002a6:	f1a8 0802 	sub.w	r8, r8, #2
 80002aa:	443d      	add	r5, r7
 80002ac:	1aed      	subs	r5, r5, r3
 80002ae:	b2a4      	uxth	r4, r4
 80002b0:	fbb5 f0fa 	udiv	r0, r5, sl
 80002b4:	fb0a 5510 	mls	r5, sl, r0, r5
 80002b8:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 80002bc:	fb00 f909 	mul.w	r9, r0, r9
 80002c0:	45a1      	cmp	r9, r4
 80002c2:	d909      	bls.n	80002d8 <__udivmoddi4+0x98>
 80002c4:	19e4      	adds	r4, r4, r7
 80002c6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80002ca:	f080 810a 	bcs.w	80004e2 <__udivmoddi4+0x2a2>
 80002ce:	45a1      	cmp	r9, r4
 80002d0:	f240 8107 	bls.w	80004e2 <__udivmoddi4+0x2a2>
 80002d4:	3802      	subs	r0, #2
 80002d6:	443c      	add	r4, r7
 80002d8:	eba4 0409 	sub.w	r4, r4, r9
 80002dc:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80002e0:	2100      	movs	r1, #0
 80002e2:	2e00      	cmp	r6, #0
 80002e4:	d061      	beq.n	80003aa <__udivmoddi4+0x16a>
 80002e6:	fa24 f40e 	lsr.w	r4, r4, lr
 80002ea:	2300      	movs	r3, #0
 80002ec:	6034      	str	r4, [r6, #0]
 80002ee:	6073      	str	r3, [r6, #4]
 80002f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002f4:	428b      	cmp	r3, r1
 80002f6:	d907      	bls.n	8000308 <__udivmoddi4+0xc8>
 80002f8:	2e00      	cmp	r6, #0
 80002fa:	d054      	beq.n	80003a6 <__udivmoddi4+0x166>
 80002fc:	2100      	movs	r1, #0
 80002fe:	e886 0021 	stmia.w	r6, {r0, r5}
 8000302:	4608      	mov	r0, r1
 8000304:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000308:	fab3 f183 	clz	r1, r3
 800030c:	2900      	cmp	r1, #0
 800030e:	f040 808e 	bne.w	800042e <__udivmoddi4+0x1ee>
 8000312:	42ab      	cmp	r3, r5
 8000314:	d302      	bcc.n	800031c <__udivmoddi4+0xdc>
 8000316:	4282      	cmp	r2, r0
 8000318:	f200 80fa 	bhi.w	8000510 <__udivmoddi4+0x2d0>
 800031c:	1a84      	subs	r4, r0, r2
 800031e:	eb65 0503 	sbc.w	r5, r5, r3
 8000322:	2001      	movs	r0, #1
 8000324:	46ac      	mov	ip, r5
 8000326:	2e00      	cmp	r6, #0
 8000328:	d03f      	beq.n	80003aa <__udivmoddi4+0x16a>
 800032a:	e886 1010 	stmia.w	r6, {r4, ip}
 800032e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000332:	b912      	cbnz	r2, 800033a <__udivmoddi4+0xfa>
 8000334:	2701      	movs	r7, #1
 8000336:	fbb7 f7f2 	udiv	r7, r7, r2
 800033a:	fab7 fe87 	clz	lr, r7
 800033e:	f1be 0f00 	cmp.w	lr, #0
 8000342:	d134      	bne.n	80003ae <__udivmoddi4+0x16e>
 8000344:	1beb      	subs	r3, r5, r7
 8000346:	0c3a      	lsrs	r2, r7, #16
 8000348:	fa1f fc87 	uxth.w	ip, r7
 800034c:	2101      	movs	r1, #1
 800034e:	fbb3 f8f2 	udiv	r8, r3, r2
 8000352:	0c25      	lsrs	r5, r4, #16
 8000354:	fb02 3318 	mls	r3, r2, r8, r3
 8000358:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800035c:	fb0c f308 	mul.w	r3, ip, r8
 8000360:	42ab      	cmp	r3, r5
 8000362:	d907      	bls.n	8000374 <__udivmoddi4+0x134>
 8000364:	19ed      	adds	r5, r5, r7
 8000366:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 800036a:	d202      	bcs.n	8000372 <__udivmoddi4+0x132>
 800036c:	42ab      	cmp	r3, r5
 800036e:	f200 80d1 	bhi.w	8000514 <__udivmoddi4+0x2d4>
 8000372:	4680      	mov	r8, r0
 8000374:	1aed      	subs	r5, r5, r3
 8000376:	b2a3      	uxth	r3, r4
 8000378:	fbb5 f0f2 	udiv	r0, r5, r2
 800037c:	fb02 5510 	mls	r5, r2, r0, r5
 8000380:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000384:	fb0c fc00 	mul.w	ip, ip, r0
 8000388:	45a4      	cmp	ip, r4
 800038a:	d907      	bls.n	800039c <__udivmoddi4+0x15c>
 800038c:	19e4      	adds	r4, r4, r7
 800038e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000392:	d202      	bcs.n	800039a <__udivmoddi4+0x15a>
 8000394:	45a4      	cmp	ip, r4
 8000396:	f200 80b8 	bhi.w	800050a <__udivmoddi4+0x2ca>
 800039a:	4618      	mov	r0, r3
 800039c:	eba4 040c 	sub.w	r4, r4, ip
 80003a0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80003a4:	e79d      	b.n	80002e2 <__udivmoddi4+0xa2>
 80003a6:	4631      	mov	r1, r6
 80003a8:	4630      	mov	r0, r6
 80003aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003ae:	f1ce 0420 	rsb	r4, lr, #32
 80003b2:	fa05 f30e 	lsl.w	r3, r5, lr
 80003b6:	fa07 f70e 	lsl.w	r7, r7, lr
 80003ba:	fa20 f804 	lsr.w	r8, r0, r4
 80003be:	0c3a      	lsrs	r2, r7, #16
 80003c0:	fa25 f404 	lsr.w	r4, r5, r4
 80003c4:	ea48 0803 	orr.w	r8, r8, r3
 80003c8:	fbb4 f1f2 	udiv	r1, r4, r2
 80003cc:	ea4f 4518 	mov.w	r5, r8, lsr #16
 80003d0:	fb02 4411 	mls	r4, r2, r1, r4
 80003d4:	fa1f fc87 	uxth.w	ip, r7
 80003d8:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 80003dc:	fb01 f30c 	mul.w	r3, r1, ip
 80003e0:	42ab      	cmp	r3, r5
 80003e2:	fa00 f40e 	lsl.w	r4, r0, lr
 80003e6:	d909      	bls.n	80003fc <__udivmoddi4+0x1bc>
 80003e8:	19ed      	adds	r5, r5, r7
 80003ea:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 80003ee:	f080 808a 	bcs.w	8000506 <__udivmoddi4+0x2c6>
 80003f2:	42ab      	cmp	r3, r5
 80003f4:	f240 8087 	bls.w	8000506 <__udivmoddi4+0x2c6>
 80003f8:	3902      	subs	r1, #2
 80003fa:	443d      	add	r5, r7
 80003fc:	1aeb      	subs	r3, r5, r3
 80003fe:	fa1f f588 	uxth.w	r5, r8
 8000402:	fbb3 f0f2 	udiv	r0, r3, r2
 8000406:	fb02 3310 	mls	r3, r2, r0, r3
 800040a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800040e:	fb00 f30c 	mul.w	r3, r0, ip
 8000412:	42ab      	cmp	r3, r5
 8000414:	d907      	bls.n	8000426 <__udivmoddi4+0x1e6>
 8000416:	19ed      	adds	r5, r5, r7
 8000418:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 800041c:	d26f      	bcs.n	80004fe <__udivmoddi4+0x2be>
 800041e:	42ab      	cmp	r3, r5
 8000420:	d96d      	bls.n	80004fe <__udivmoddi4+0x2be>
 8000422:	3802      	subs	r0, #2
 8000424:	443d      	add	r5, r7
 8000426:	1aeb      	subs	r3, r5, r3
 8000428:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800042c:	e78f      	b.n	800034e <__udivmoddi4+0x10e>
 800042e:	f1c1 0720 	rsb	r7, r1, #32
 8000432:	fa22 f807 	lsr.w	r8, r2, r7
 8000436:	408b      	lsls	r3, r1
 8000438:	fa05 f401 	lsl.w	r4, r5, r1
 800043c:	ea48 0303 	orr.w	r3, r8, r3
 8000440:	fa20 fe07 	lsr.w	lr, r0, r7
 8000444:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000448:	40fd      	lsrs	r5, r7
 800044a:	ea4e 0e04 	orr.w	lr, lr, r4
 800044e:	fbb5 f9fc 	udiv	r9, r5, ip
 8000452:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000456:	fb0c 5519 	mls	r5, ip, r9, r5
 800045a:	fa1f f883 	uxth.w	r8, r3
 800045e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000462:	fb09 f408 	mul.w	r4, r9, r8
 8000466:	42ac      	cmp	r4, r5
 8000468:	fa02 f201 	lsl.w	r2, r2, r1
 800046c:	fa00 fa01 	lsl.w	sl, r0, r1
 8000470:	d908      	bls.n	8000484 <__udivmoddi4+0x244>
 8000472:	18ed      	adds	r5, r5, r3
 8000474:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000478:	d243      	bcs.n	8000502 <__udivmoddi4+0x2c2>
 800047a:	42ac      	cmp	r4, r5
 800047c:	d941      	bls.n	8000502 <__udivmoddi4+0x2c2>
 800047e:	f1a9 0902 	sub.w	r9, r9, #2
 8000482:	441d      	add	r5, r3
 8000484:	1b2d      	subs	r5, r5, r4
 8000486:	fa1f fe8e 	uxth.w	lr, lr
 800048a:	fbb5 f0fc 	udiv	r0, r5, ip
 800048e:	fb0c 5510 	mls	r5, ip, r0, r5
 8000492:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000496:	fb00 f808 	mul.w	r8, r0, r8
 800049a:	45a0      	cmp	r8, r4
 800049c:	d907      	bls.n	80004ae <__udivmoddi4+0x26e>
 800049e:	18e4      	adds	r4, r4, r3
 80004a0:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 80004a4:	d229      	bcs.n	80004fa <__udivmoddi4+0x2ba>
 80004a6:	45a0      	cmp	r8, r4
 80004a8:	d927      	bls.n	80004fa <__udivmoddi4+0x2ba>
 80004aa:	3802      	subs	r0, #2
 80004ac:	441c      	add	r4, r3
 80004ae:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80004b2:	eba4 0408 	sub.w	r4, r4, r8
 80004b6:	fba0 8902 	umull	r8, r9, r0, r2
 80004ba:	454c      	cmp	r4, r9
 80004bc:	46c6      	mov	lr, r8
 80004be:	464d      	mov	r5, r9
 80004c0:	d315      	bcc.n	80004ee <__udivmoddi4+0x2ae>
 80004c2:	d012      	beq.n	80004ea <__udivmoddi4+0x2aa>
 80004c4:	b156      	cbz	r6, 80004dc <__udivmoddi4+0x29c>
 80004c6:	ebba 030e 	subs.w	r3, sl, lr
 80004ca:	eb64 0405 	sbc.w	r4, r4, r5
 80004ce:	fa04 f707 	lsl.w	r7, r4, r7
 80004d2:	40cb      	lsrs	r3, r1
 80004d4:	431f      	orrs	r7, r3
 80004d6:	40cc      	lsrs	r4, r1
 80004d8:	6037      	str	r7, [r6, #0]
 80004da:	6074      	str	r4, [r6, #4]
 80004dc:	2100      	movs	r1, #0
 80004de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004e2:	4618      	mov	r0, r3
 80004e4:	e6f8      	b.n	80002d8 <__udivmoddi4+0x98>
 80004e6:	4690      	mov	r8, r2
 80004e8:	e6e0      	b.n	80002ac <__udivmoddi4+0x6c>
 80004ea:	45c2      	cmp	sl, r8
 80004ec:	d2ea      	bcs.n	80004c4 <__udivmoddi4+0x284>
 80004ee:	ebb8 0e02 	subs.w	lr, r8, r2
 80004f2:	eb69 0503 	sbc.w	r5, r9, r3
 80004f6:	3801      	subs	r0, #1
 80004f8:	e7e4      	b.n	80004c4 <__udivmoddi4+0x284>
 80004fa:	4628      	mov	r0, r5
 80004fc:	e7d7      	b.n	80004ae <__udivmoddi4+0x26e>
 80004fe:	4640      	mov	r0, r8
 8000500:	e791      	b.n	8000426 <__udivmoddi4+0x1e6>
 8000502:	4681      	mov	r9, r0
 8000504:	e7be      	b.n	8000484 <__udivmoddi4+0x244>
 8000506:	4601      	mov	r1, r0
 8000508:	e778      	b.n	80003fc <__udivmoddi4+0x1bc>
 800050a:	3802      	subs	r0, #2
 800050c:	443c      	add	r4, r7
 800050e:	e745      	b.n	800039c <__udivmoddi4+0x15c>
 8000510:	4608      	mov	r0, r1
 8000512:	e708      	b.n	8000326 <__udivmoddi4+0xe6>
 8000514:	f1a8 0802 	sub.w	r8, r8, #2
 8000518:	443d      	add	r5, r7
 800051a:	e72b      	b.n	8000374 <__udivmoddi4+0x134>

0800051c <__aeabi_idiv0>:
 800051c:	4770      	bx	lr
 800051e:	bf00      	nop

08000520 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000520:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000522:	4a0e      	ldr	r2, [pc, #56]	; (800055c <HAL_InitTick+0x3c>)
 8000524:	4b0e      	ldr	r3, [pc, #56]	; (8000560 <HAL_InitTick+0x40>)
{
 8000526:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000528:	7818      	ldrb	r0, [r3, #0]
 800052a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800052e:	fbb3 f3f0 	udiv	r3, r3, r0
 8000532:	6810      	ldr	r0, [r2, #0]
 8000534:	fbb0 f0f3 	udiv	r0, r0, r3
 8000538:	f000 fab8 	bl	8000aac <HAL_SYSTICK_Config>
 800053c:	4604      	mov	r4, r0
 800053e:	b958      	cbnz	r0, 8000558 <HAL_InitTick+0x38>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000540:	2d0f      	cmp	r5, #15
 8000542:	d809      	bhi.n	8000558 <HAL_InitTick+0x38>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000544:	4602      	mov	r2, r0
 8000546:	4629      	mov	r1, r5
 8000548:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800054c:	f000 fa6e 	bl	8000a2c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000550:	4b04      	ldr	r3, [pc, #16]	; (8000564 <HAL_InitTick+0x44>)
 8000552:	4620      	mov	r0, r4
 8000554:	601d      	str	r5, [r3, #0]
 8000556:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8000558:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 800055a:	bd38      	pop	{r3, r4, r5, pc}
 800055c:	20000010 	.word	0x20000010
 8000560:	20000000 	.word	0x20000000
 8000564:	20000004 	.word	0x20000004

08000568 <HAL_Init>:
{
 8000568:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800056a:	4b0b      	ldr	r3, [pc, #44]	; (8000598 <HAL_Init+0x30>)
 800056c:	681a      	ldr	r2, [r3, #0]
 800056e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000572:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000574:	681a      	ldr	r2, [r3, #0]
 8000576:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800057a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800057c:	681a      	ldr	r2, [r3, #0]
 800057e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000582:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000584:	2003      	movs	r0, #3
 8000586:	f000 fa3f 	bl	8000a08 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800058a:	200f      	movs	r0, #15
 800058c:	f7ff ffc8 	bl	8000520 <HAL_InitTick>
  HAL_MspInit();
 8000590:	f005 ff14 	bl	80063bc <HAL_MspInit>
}
 8000594:	2000      	movs	r0, #0
 8000596:	bd08      	pop	{r3, pc}
 8000598:	40023c00 	.word	0x40023c00

0800059c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800059c:	4a03      	ldr	r2, [pc, #12]	; (80005ac <HAL_IncTick+0x10>)
 800059e:	4b04      	ldr	r3, [pc, #16]	; (80005b0 <HAL_IncTick+0x14>)
 80005a0:	6811      	ldr	r1, [r2, #0]
 80005a2:	781b      	ldrb	r3, [r3, #0]
 80005a4:	440b      	add	r3, r1
 80005a6:	6013      	str	r3, [r2, #0]
 80005a8:	4770      	bx	lr
 80005aa:	bf00      	nop
 80005ac:	20003f34 	.word	0x20003f34
 80005b0:	20000000 	.word	0x20000000

080005b4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80005b4:	4b01      	ldr	r3, [pc, #4]	; (80005bc <HAL_GetTick+0x8>)
 80005b6:	6818      	ldr	r0, [r3, #0]
}
 80005b8:	4770      	bx	lr
 80005ba:	bf00      	nop
 80005bc:	20003f34 	.word	0x20003f34

080005c0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80005c0:	b538      	push	{r3, r4, r5, lr}
 80005c2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80005c4:	f7ff fff6 	bl	80005b4 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80005c8:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 80005ca:	bf1c      	itt	ne
 80005cc:	4b05      	ldrne	r3, [pc, #20]	; (80005e4 <HAL_Delay+0x24>)
 80005ce:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 80005d0:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 80005d2:	bf18      	it	ne
 80005d4:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80005d6:	f7ff ffed 	bl	80005b4 <HAL_GetTick>
 80005da:	1b40      	subs	r0, r0, r5
 80005dc:	4284      	cmp	r4, r0
 80005de:	d8fa      	bhi.n	80005d6 <HAL_Delay+0x16>
  {
  }
}
 80005e0:	bd38      	pop	{r3, r4, r5, pc}
 80005e2:	bf00      	nop
 80005e4:	20000000 	.word	0x20000000

080005e8 <HAL_CAN_Init>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
 80005e8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Check CAN handle */
  if (hcan == NULL)
 80005ea:	4604      	mov	r4, r0
 80005ec:	2800      	cmp	r0, #0
 80005ee:	d06e      	beq.n	80006ce <HAL_CAN_Init+0xe6>
  assert_param(IS_CAN_SJW(hcan->Init.SyncJumpWidth));
  assert_param(IS_CAN_BS1(hcan->Init.TimeSeg1));
  assert_param(IS_CAN_BS2(hcan->Init.TimeSeg2));
  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));

  if (hcan->State == HAL_CAN_STATE_RESET)
 80005f0:	f890 3020 	ldrb.w	r3, [r0, #32]
 80005f4:	b90b      	cbnz	r3, 80005fa <HAL_CAN_Init+0x12>
  {
    /* Init the low level hardware: CLOCK, NVIC */
    HAL_CAN_MspInit(hcan);
 80005f6:	f005 f96f 	bl	80058d8 <HAL_CAN_MspInit>
  }

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 80005fa:	6822      	ldr	r2, [r4, #0]
 80005fc:	6813      	ldr	r3, [r2, #0]
 80005fe:	f023 0302 	bic.w	r3, r3, #2
 8000602:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000604:	f7ff ffd6 	bl	80005b4 <HAL_GetTick>
 8000608:	4605      	mov	r5, r0

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != RESET)
 800060a:	6823      	ldr	r3, [r4, #0]
 800060c:	685a      	ldr	r2, [r3, #4]
 800060e:	0791      	lsls	r1, r2, #30
 8000610:	d451      	bmi.n	80006b6 <HAL_CAN_Init+0xce>
      return HAL_ERROR;
    }
  }

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000612:	681a      	ldr	r2, [r3, #0]
 8000614:	f042 0201 	orr.w	r2, r2, #1
 8000618:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800061a:	f7ff ffcb 	bl	80005b4 <HAL_GetTick>
 800061e:	4605      	mov	r5, r0

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == RESET)
 8000620:	6823      	ldr	r3, [r4, #0]
 8000622:	685a      	ldr	r2, [r3, #4]
 8000624:	07d2      	lsls	r2, r2, #31
 8000626:	d554      	bpl.n	80006d2 <HAL_CAN_Init+0xea>
      return HAL_ERROR;
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8000628:	7e22      	ldrb	r2, [r4, #24]
 800062a:	2a01      	cmp	r2, #1
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 800062c:	681a      	ldr	r2, [r3, #0]
 800062e:	bf0c      	ite	eq
 8000630:	f042 0280 	orreq.w	r2, r2, #128	; 0x80
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000634:	f022 0280 	bicne.w	r2, r2, #128	; 0x80
 8000638:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic bus-off management */
  if (hcan->Init.AutoBusOff == ENABLE)
 800063a:	7e62      	ldrb	r2, [r4, #25]
 800063c:	2a01      	cmp	r2, #1
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 800063e:	681a      	ldr	r2, [r3, #0]
 8000640:	bf0c      	ite	eq
 8000642:	f042 0240 	orreq.w	r2, r2, #64	; 0x40
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8000646:	f022 0240 	bicne.w	r2, r2, #64	; 0x40
 800064a:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic wake-up mode */
  if (hcan->Init.AutoWakeUp == ENABLE)
 800064c:	7ea2      	ldrb	r2, [r4, #26]
 800064e:	2a01      	cmp	r2, #1
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000650:	681a      	ldr	r2, [r3, #0]
 8000652:	bf0c      	ite	eq
 8000654:	f042 0220 	orreq.w	r2, r2, #32
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000658:	f022 0220 	bicne.w	r2, r2, #32
 800065c:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic retransmission */
  if (hcan->Init.AutoRetransmission == ENABLE)
 800065e:	7ee2      	ldrb	r2, [r4, #27]
 8000660:	2a01      	cmp	r2, #1
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 8000662:	681a      	ldr	r2, [r3, #0]
 8000664:	bf0c      	ite	eq
 8000666:	f022 0210 	biceq.w	r2, r2, #16
  }
  else
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800066a:	f042 0210 	orrne.w	r2, r2, #16
 800066e:	601a      	str	r2, [r3, #0]
  }

  /* Set the receive FIFO locked mode */
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 8000670:	7f22      	ldrb	r2, [r4, #28]
 8000672:	2a01      	cmp	r2, #1
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8000674:	681a      	ldr	r2, [r3, #0]
 8000676:	bf0c      	ite	eq
 8000678:	f042 0208 	orreq.w	r2, r2, #8
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 800067c:	f022 0208 	bicne.w	r2, r2, #8
 8000680:	601a      	str	r2, [r3, #0]
  }

  /* Set the transmit FIFO priority */
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 8000682:	7f62      	ldrb	r2, [r4, #29]
 8000684:	2a01      	cmp	r2, #1
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 8000686:	681a      	ldr	r2, [r3, #0]
 8000688:	bf0c      	ite	eq
 800068a:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 800068e:	f022 0204 	bicne.w	r2, r2, #4
 8000692:	601a      	str	r2, [r3, #0]
  }

  /* Set the bit timing register */
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 8000694:	68e1      	ldr	r1, [r4, #12]
 8000696:	68a2      	ldr	r2, [r4, #8]
 8000698:	430a      	orrs	r2, r1
 800069a:	6921      	ldr	r1, [r4, #16]
 800069c:	430a      	orrs	r2, r1
 800069e:	6961      	ldr	r1, [r4, #20]
 80006a0:	430a      	orrs	r2, r1
 80006a2:	6861      	ldr	r1, [r4, #4]
 80006a4:	3901      	subs	r1, #1
 80006a6:	430a      	orrs	r2, r1
 80006a8:	61da      	str	r2, [r3, #28]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 80006aa:	2000      	movs	r0, #0

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 80006ac:	2301      	movs	r3, #1
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 80006ae:	6260      	str	r0, [r4, #36]	; 0x24
  hcan->State = HAL_CAN_STATE_READY;
 80006b0:	f884 3020 	strb.w	r3, [r4, #32]

  /* Return function status */
  return HAL_OK;
 80006b4:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 80006b6:	f7ff ff7d 	bl	80005b4 <HAL_GetTick>
 80006ba:	1b40      	subs	r0, r0, r5
 80006bc:	280a      	cmp	r0, #10
 80006be:	d9a4      	bls.n	800060a <HAL_CAN_Init+0x22>
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 80006c0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80006c2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80006c6:	6263      	str	r3, [r4, #36]	; 0x24
      hcan->State = HAL_CAN_STATE_ERROR;
 80006c8:	2305      	movs	r3, #5
 80006ca:	f884 3020 	strb.w	r3, [r4, #32]
    return HAL_ERROR;
 80006ce:	2001      	movs	r0, #1
}
 80006d0:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 80006d2:	f7ff ff6f 	bl	80005b4 <HAL_GetTick>
 80006d6:	1b40      	subs	r0, r0, r5
 80006d8:	280a      	cmp	r0, #10
 80006da:	d9a1      	bls.n	8000620 <HAL_CAN_Init+0x38>
 80006dc:	e7f0      	b.n	80006c0 <HAL_CAN_Init+0xd8>
	...

080006e0 <HAL_CAN_ConfigFilter>:
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
{
  uint32_t filternbrbitpos = 0U;
  CAN_TypeDef *can_ip = hcan->Instance;

  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80006e0:	f890 3020 	ldrb.w	r3, [r0, #32]
 80006e4:	2b01      	cmp	r3, #1
{
 80006e6:	b530      	push	{r4, r5, lr}
  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80006e8:	d003      	beq.n	80006f2 <HAL_CAN_ConfigFilter+0x12>
      (hcan->State == HAL_CAN_STATE_LISTENING))
 80006ea:	f890 3020 	ldrb.w	r3, [r0, #32]
  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80006ee:	2b02      	cmp	r3, #2
 80006f0:	d177      	bne.n	80007e2 <HAL_CAN_ConfigFilter+0x102>
    /* Check the parameters */
    assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
#endif

    /* Initialisation mode for the filter */
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 80006f2:	4b3f      	ldr	r3, [pc, #252]	; (80007f0 <HAL_CAN_ConfigFilter+0x110>)
 80006f4:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80006f8:	f042 0201 	orr.w	r2, r2, #1
 80006fc:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
    }

#elif defined(CAN2)
    /* Select the start filter number of CAN2 slave instance */
    CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
 8000700:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000704:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 8000708:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
 800070c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000710:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8000712:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8000716:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

#endif
    /* Convert filter number into bit position */
    filternbrbitpos = (1U) << sFilterConfig->FilterBank;
 800071a:	6948      	ldr	r0, [r1, #20]

    /* Filter Deactivation */
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 800071c:	f8d3 521c 	ldr.w	r5, [r3, #540]	; 0x21c
    filternbrbitpos = (1U) << sFilterConfig->FilterBank;
 8000720:	2401      	movs	r4, #1
 8000722:	4084      	lsls	r4, r0
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8000724:	43e2      	mvns	r2, r4
 8000726:	4015      	ands	r5, r2
 8000728:	f8c3 521c 	str.w	r5, [r3, #540]	; 0x21c

    /* Filter Scale */
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 800072c:	69cd      	ldr	r5, [r1, #28]
 800072e:	2d00      	cmp	r5, #0
 8000730:	d136      	bne.n	80007a0 <HAL_CAN_ConfigFilter+0xc0>
    {
      /* 16-bit scale for the filter */
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000732:	f8d3 520c 	ldr.w	r5, [r3, #524]	; 0x20c
 8000736:	4015      	ands	r5, r2
 8000738:	f8c3 520c 	str.w	r5, [r3, #524]	; 0x20c
 800073c:	00c0      	lsls	r0, r0, #3

      /* First 16-bit identifier and First 16-bit mask */
      /* Or First 16-bit identifier and Second 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800073e:	68cd      	ldr	r5, [r1, #12]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8000740:	888b      	ldrh	r3, [r1, #4]
 8000742:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8000746:	f500 40c8 	add.w	r0, r0, #25600	; 0x6400
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800074a:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800074e:	f8c0 3240 	str.w	r3, [r0, #576]	; 0x240

      /* Second 16-bit identifier and Second 16-bit mask */
      /* Or Third 16-bit identifier and Fourth 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000752:	688d      	ldr	r5, [r1, #8]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 8000754:	880b      	ldrh	r3, [r1, #0]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000756:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800075a:	f8c0 3244 	str.w	r3, [r0, #580]	; 0x244
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
    }

    /* Filter Mode */
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 800075e:	6988      	ldr	r0, [r1, #24]
 8000760:	4b23      	ldr	r3, [pc, #140]	; (80007f0 <HAL_CAN_ConfigFilter+0x110>)
 8000762:	2800      	cmp	r0, #0
 8000764:	d135      	bne.n	80007d2 <HAL_CAN_ConfigFilter+0xf2>
    {
      /* Id/Mask mode for the filter*/
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 8000766:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
 800076a:	4010      	ands	r0, r2
    }
    else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    {
      /* Identifier list mode for the filter*/
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 800076c:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    }

    /* Filter FIFO assignment */
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8000770:	6908      	ldr	r0, [r1, #16]
 8000772:	bb90      	cbnz	r0, 80007da <HAL_CAN_ConfigFilter+0xfa>
    {
      /* FIFO 0 assignation for the filter */
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 8000774:	f8d3 0214 	ldr.w	r0, [r3, #532]	; 0x214
 8000778:	4002      	ands	r2, r0
    }
    else
    {
      /* FIFO 1 assignation for the filter */
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 800077a:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    }

    /* Filter activation */
    if (sFilterConfig->FilterActivation == ENABLE)
 800077e:	6a0b      	ldr	r3, [r1, #32]
 8000780:	4a1b      	ldr	r2, [pc, #108]	; (80007f0 <HAL_CAN_ConfigFilter+0x110>)
 8000782:	2b01      	cmp	r3, #1
    {
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 8000784:	bf02      	ittt	eq
 8000786:	f8d2 321c 	ldreq.w	r3, [r2, #540]	; 0x21c
 800078a:	4323      	orreq	r3, r4
 800078c:	f8c2 321c 	streq.w	r3, [r2, #540]	; 0x21c
    }

    /* Leave the initialisation mode for the filter */
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000790:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 8000794:	f023 0301 	bic.w	r3, r3, #1
 8000798:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Return function status */
    return HAL_OK;
 800079c:	2000      	movs	r0, #0
 800079e:	bd30      	pop	{r4, r5, pc}
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 80007a0:	2d01      	cmp	r5, #1
 80007a2:	d1dc      	bne.n	800075e <HAL_CAN_ConfigFilter+0x7e>
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 80007a4:	f8d3 520c 	ldr.w	r5, [r3, #524]	; 0x20c
 80007a8:	4325      	orrs	r5, r4
 80007aa:	f8c3 520c 	str.w	r5, [r3, #524]	; 0x20c
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 80007ae:	680b      	ldr	r3, [r1, #0]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 80007b0:	888d      	ldrh	r5, [r1, #4]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 80007b2:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80007b6:	00c3      	lsls	r3, r0, #3
 80007b8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80007bc:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 80007c0:	8988      	ldrh	r0, [r1, #12]
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 80007c2:	f8c3 5240 	str.w	r5, [r3, #576]	; 0x240
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 80007c6:	688d      	ldr	r5, [r1, #8]
 80007c8:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 80007cc:	f8c3 0244 	str.w	r0, [r3, #580]	; 0x244
 80007d0:	e7c5      	b.n	800075e <HAL_CAN_ConfigFilter+0x7e>
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 80007d2:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
 80007d6:	4320      	orrs	r0, r4
 80007d8:	e7c8      	b.n	800076c <HAL_CAN_ConfigFilter+0x8c>
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 80007da:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 80007de:	4322      	orrs	r2, r4
 80007e0:	e7cb      	b.n	800077a <HAL_CAN_ConfigFilter+0x9a>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 80007e2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80007e4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80007e8:	6243      	str	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 80007ea:	2001      	movs	r0, #1
  }
}
 80007ec:	bd30      	pop	{r4, r5, pc}
 80007ee:	bf00      	nop
 80007f0:	40006400 	.word	0x40006400

080007f4 <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 80007f4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  if (hcan->State == HAL_CAN_STATE_READY)
 80007f6:	f890 3020 	ldrb.w	r3, [r0, #32]
 80007fa:	2b01      	cmp	r3, #1
{
 80007fc:	4604      	mov	r4, r0
  if (hcan->State == HAL_CAN_STATE_READY)
 80007fe:	d11f      	bne.n	8000840 <HAL_CAN_Start+0x4c>
  {
    /* Change CAN peripheral state */
    hcan->State = HAL_CAN_STATE_LISTENING;

    /* Request leave initialisation */
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000800:	6802      	ldr	r2, [r0, #0]
    hcan->State = HAL_CAN_STATE_LISTENING;
 8000802:	2302      	movs	r3, #2
 8000804:	f880 3020 	strb.w	r3, [r0, #32]
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000808:	6813      	ldr	r3, [r2, #0]
 800080a:	f023 0301 	bic.w	r3, r3, #1
 800080e:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8000810:	f7ff fed0 	bl	80005b4 <HAL_GetTick>
 8000814:	4605      	mov	r5, r0

    /* Wait the acknowledge */
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != RESET)
 8000816:	6823      	ldr	r3, [r4, #0]
 8000818:	6858      	ldr	r0, [r3, #4]
 800081a:	f010 0001 	ands.w	r0, r0, #1
 800081e:	d101      	bne.n	8000824 <HAL_CAN_Start+0x30>
        return HAL_ERROR;
      }
    }

    /* Reset the CAN ErrorCode */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000820:	6260      	str	r0, [r4, #36]	; 0x24

    /* Return function status */
    return HAL_OK;
 8000822:	bd38      	pop	{r3, r4, r5, pc}
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000824:	f7ff fec6 	bl	80005b4 <HAL_GetTick>
 8000828:	1b40      	subs	r0, r0, r5
 800082a:	280a      	cmp	r0, #10
 800082c:	d9f3      	bls.n	8000816 <HAL_CAN_Start+0x22>
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800082e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000830:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000834:	6263      	str	r3, [r4, #36]	; 0x24
        hcan->State = HAL_CAN_STATE_ERROR;
 8000836:	2305      	movs	r3, #5
 8000838:	f884 3020 	strb.w	r3, [r4, #32]
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;

    return HAL_ERROR;
 800083c:	2001      	movs	r0, #1
  }
}
 800083e:	bd38      	pop	{r3, r4, r5, pc}
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 8000840:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000842:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000846:	6243      	str	r3, [r0, #36]	; 0x24
 8000848:	e7f8      	b.n	800083c <HAL_CAN_Start+0x48>

0800084a <HAL_CAN_AddTxMessage>:
  *         the TxMailbox used to store the Tx message.
  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)
{
 800084a:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_CAN_EXTID(pHeader->ExtId));
  }
  assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));

  if ((hcan->State == HAL_CAN_STATE_READY) ||
 800084c:	f890 4020 	ldrb.w	r4, [r0, #32]
 8000850:	2c01      	cmp	r4, #1
 8000852:	d003      	beq.n	800085c <HAL_CAN_AddTxMessage+0x12>
      (hcan->State == HAL_CAN_STATE_LISTENING))
 8000854:	f890 4020 	ldrb.w	r4, [r0, #32]
  if ((hcan->State == HAL_CAN_STATE_READY) ||
 8000858:	2c02      	cmp	r4, #2
 800085a:	d141      	bne.n	80008e0 <HAL_CAN_AddTxMessage+0x96>
  {
    /* Check that all the Tx mailboxes are not full */
    if (((hcan->Instance->TSR & CAN_TSR_TME0) != RESET) ||
 800085c:	6804      	ldr	r4, [r0, #0]
 800085e:	68a5      	ldr	r5, [r4, #8]
 8000860:	016f      	lsls	r7, r5, #5
 8000862:	d405      	bmi.n	8000870 <HAL_CAN_AddTxMessage+0x26>
        ((hcan->Instance->TSR & CAN_TSR_TME1) != RESET) ||
 8000864:	68a5      	ldr	r5, [r4, #8]
    if (((hcan->Instance->TSR & CAN_TSR_TME0) != RESET) ||
 8000866:	012e      	lsls	r6, r5, #4
 8000868:	d402      	bmi.n	8000870 <HAL_CAN_AddTxMessage+0x26>
        ((hcan->Instance->TSR & CAN_TSR_TME2) != RESET))
 800086a:	68a5      	ldr	r5, [r4, #8]
        ((hcan->Instance->TSR & CAN_TSR_TME1) != RESET) ||
 800086c:	00ed      	lsls	r5, r5, #3
 800086e:	d531      	bpl.n	80008d4 <HAL_CAN_AddTxMessage+0x8a>
    {
      /* Select an empty transmit mailbox */
      transmitmailbox = (hcan->Instance->TSR & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
 8000870:	68a0      	ldr	r0, [r4, #8]

      /* Store the Tx mailbox */
      *pTxMailbox = 1U << transmitmailbox;
 8000872:	2501      	movs	r5, #1
      transmitmailbox = (hcan->Instance->TSR & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
 8000874:	f3c0 6001 	ubfx	r0, r0, #24, #2
      *pTxMailbox = 1U << transmitmailbox;
 8000878:	4085      	lsls	r5, r0
 800087a:	601d      	str	r5, [r3, #0]

      /* Set up the Id */
      if (pHeader->IDE == CAN_ID_STD)
 800087c:	688d      	ldr	r5, [r1, #8]
 800087e:	68cf      	ldr	r7, [r1, #12]
 8000880:	f100 0318 	add.w	r3, r0, #24
 8000884:	bb0d      	cbnz	r5, 80008ca <HAL_CAN_AddTxMessage+0x80>
      {
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
 8000886:	680d      	ldr	r5, [r1, #0]
 8000888:	ea47 5545 	orr.w	r5, r7, r5, lsl #21
                                                           pHeader->RTR);
      }
      else
      {
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 800088c:	011b      	lsls	r3, r3, #4
 800088e:	0100      	lsls	r0, r0, #4
 8000890:	50e5      	str	r5, [r4, r3]
 8000892:	1823      	adds	r3, r4, r0
                                                           pHeader->IDE |
                                                           pHeader->RTR);
      }

      /* Set up the DLC */
      hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
 8000894:	690d      	ldr	r5, [r1, #16]

      /* Set up the Transmit Global Time mode */
      if (pHeader->TransmitGlobalTime == ENABLE)
 8000896:	7d09      	ldrb	r1, [r1, #20]
      hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
 8000898:	f8c3 5184 	str.w	r5, [r3, #388]	; 0x184
      if (pHeader->TransmitGlobalTime == ENABLE)
 800089c:	2901      	cmp	r1, #1
      {
        SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
 800089e:	bf02      	ittt	eq
 80008a0:	f8d3 1184 	ldreq.w	r1, [r3, #388]	; 0x184
 80008a4:	f441 7180 	orreq.w	r1, r1, #256	; 0x100
 80008a8:	f8c3 1184 	streq.w	r1, [r3, #388]	; 0x184
      }

      /* Set up the data field */
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
 80008ac:	4404      	add	r4, r0
 80008ae:	6851      	ldr	r1, [r2, #4]
 80008b0:	f8c4 118c 	str.w	r1, [r4, #396]	; 0x18c
                ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |
                ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |
                ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |
                ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
 80008b4:	6812      	ldr	r2, [r2, #0]
 80008b6:	f8c4 2188 	str.w	r2, [r4, #392]	; 0x188
                ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |
                ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |
                ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));

      /* Request transmission */
      SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
 80008ba:	f8d3 2180 	ldr.w	r2, [r3, #384]	; 0x180
 80008be:	f042 0201 	orr.w	r2, r2, #1
 80008c2:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

      /* Return function status */
      return HAL_OK;
 80008c6:	2000      	movs	r0, #0
 80008c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 80008ca:	684e      	ldr	r6, [r1, #4]
                                                           pHeader->IDE |
 80008cc:	433d      	orrs	r5, r7
 80008ce:	ea45 05c6 	orr.w	r5, r5, r6, lsl #3
 80008d2:	e7db      	b.n	800088c <HAL_CAN_AddTxMessage+0x42>
    }
    else
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 80008d4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80008d6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    }
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 80008da:	6243      	str	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 80008dc:	2001      	movs	r0, #1
  }
}
 80008de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 80008e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80008e2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80008e6:	e7f8      	b.n	80008da <HAL_CAN_AddTxMessage+0x90>

080008e8 <HAL_CAN_GetRxMessage>:
  *         of the Rx frame will be stored.
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
 80008e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80008ea:	f890 4020 	ldrb.w	r4, [r0, #32]
 80008ee:	2c01      	cmp	r4, #1
 80008f0:	d003      	beq.n	80008fa <HAL_CAN_GetRxMessage+0x12>
      (hcan->State == HAL_CAN_STATE_LISTENING))
 80008f2:	f890 4020 	ldrb.w	r4, [r0, #32]
  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80008f6:	2c02      	cmp	r4, #2
 80008f8:	d170      	bne.n	80009dc <HAL_CAN_GetRxMessage+0xf4>
 80008fa:	6806      	ldr	r6, [r0, #0]
  {
    /* Check the Rx FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 80008fc:	b941      	cbnz	r1, 8000910 <HAL_CAN_GetRxMessage+0x28>
    {
      /* Check that the Rx FIFO 0 is not empty */
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == RESET)
 80008fe:	68f4      	ldr	r4, [r6, #12]
      }
    }
    else if (RxFifo == CAN_RX_FIFO1) /* Rx element is assigned to Rx FIFO 1 */
    {
      /* Check that the Rx FIFO 1 is not empty */
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == RESET)
 8000900:	07a4      	lsls	r4, r4, #30
 8000902:	d109      	bne.n	8000918 <HAL_CAN_GetRxMessage+0x30>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8000904:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000906:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800090a:	6243      	str	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 800090c:	2001      	movs	r0, #1
 800090e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (RxFifo == CAN_RX_FIFO1) /* Rx element is assigned to Rx FIFO 1 */
 8000910:	2901      	cmp	r1, #1
 8000912:	d101      	bne.n	8000918 <HAL_CAN_GetRxMessage+0x30>
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == RESET)
 8000914:	6934      	ldr	r4, [r6, #16]
 8000916:	e7f3      	b.n	8000900 <HAL_CAN_GetRxMessage+0x18>
 8000918:	010c      	lsls	r4, r1, #4
 800091a:	1935      	adds	r5, r6, r4
    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 800091c:	f8d5 71b0 	ldr.w	r7, [r5, #432]	; 0x1b0
 8000920:	f007 0704 	and.w	r7, r7, #4
 8000924:	6097      	str	r7, [r2, #8]
    if (pHeader->IDE == CAN_ID_STD)
 8000926:	2f00      	cmp	r7, #0
 8000928:	d14b      	bne.n	80009c2 <HAL_CAN_GetRxMessage+0xda>
      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 800092a:	f8d5 71b0 	ldr.w	r7, [r5, #432]	; 0x1b0
 800092e:	0d7f      	lsrs	r7, r7, #21
 8000930:	6017      	str	r7, [r2, #0]
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_RTR_Pos;
 8000932:	f8d5 71b0 	ldr.w	r7, [r5, #432]	; 0x1b0
 8000936:	f3c7 0740 	ubfx	r7, r7, #1, #1
 800093a:	60d7      	str	r7, [r2, #12]
    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 800093c:	f8d5 71b4 	ldr.w	r7, [r5, #436]	; 0x1b4
 8000940:	f007 070f 	and.w	r7, r7, #15
 8000944:	6117      	str	r7, [r2, #16]
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000946:	f8d5 71b4 	ldr.w	r7, [r5, #436]	; 0x1b4
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 800094a:	f8d5 51b4 	ldr.w	r5, [r5, #436]	; 0x1b4
    aData[0] = (CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos;
 800094e:	4426      	add	r6, r4
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000950:	f3c7 2707 	ubfx	r7, r7, #8, #8
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000954:	0c2d      	lsrs	r5, r5, #16
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000956:	6197      	str	r7, [r2, #24]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000958:	6155      	str	r5, [r2, #20]
    aData[0] = (CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos;
 800095a:	f8d6 21b8 	ldr.w	r2, [r6, #440]	; 0x1b8
 800095e:	701a      	strb	r2, [r3, #0]
    aData[1] = (CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos;
 8000960:	6802      	ldr	r2, [r0, #0]
 8000962:	4422      	add	r2, r4
 8000964:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000968:	0a12      	lsrs	r2, r2, #8
 800096a:	705a      	strb	r2, [r3, #1]
    aData[2] = (CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos;
 800096c:	6802      	ldr	r2, [r0, #0]
 800096e:	4422      	add	r2, r4
 8000970:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000974:	0c12      	lsrs	r2, r2, #16
 8000976:	709a      	strb	r2, [r3, #2]
    aData[3] = (CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos;
 8000978:	6802      	ldr	r2, [r0, #0]
 800097a:	4422      	add	r2, r4
 800097c:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000980:	0e12      	lsrs	r2, r2, #24
 8000982:	70da      	strb	r2, [r3, #3]
    aData[4] = (CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos;
 8000984:	6802      	ldr	r2, [r0, #0]
 8000986:	4422      	add	r2, r4
 8000988:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 800098c:	711a      	strb	r2, [r3, #4]
    aData[5] = (CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos;
 800098e:	6802      	ldr	r2, [r0, #0]
 8000990:	4422      	add	r2, r4
 8000992:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000996:	0a12      	lsrs	r2, r2, #8
 8000998:	715a      	strb	r2, [r3, #5]
    aData[6] = (CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos;
 800099a:	6802      	ldr	r2, [r0, #0]
 800099c:	4422      	add	r2, r4
 800099e:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 80009a2:	0c12      	lsrs	r2, r2, #16
 80009a4:	719a      	strb	r2, [r3, #6]
    aData[7] = (CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos;
 80009a6:	6802      	ldr	r2, [r0, #0]
 80009a8:	4414      	add	r4, r2
 80009aa:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 80009ae:	0e12      	lsrs	r2, r2, #24
 80009b0:	71da      	strb	r2, [r3, #7]
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 80009b2:	b959      	cbnz	r1, 80009cc <HAL_CAN_GetRxMessage+0xe4>
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 80009b4:	6802      	ldr	r2, [r0, #0]
 80009b6:	68d3      	ldr	r3, [r2, #12]
 80009b8:	f043 0320 	orr.w	r3, r3, #32
 80009bc:	60d3      	str	r3, [r2, #12]
    return HAL_OK;
 80009be:	2000      	movs	r0, #0
  }
}
 80009c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 80009c2:	f8d5 71b0 	ldr.w	r7, [r5, #432]	; 0x1b0
 80009c6:	08ff      	lsrs	r7, r7, #3
 80009c8:	6057      	str	r7, [r2, #4]
 80009ca:	e7b2      	b.n	8000932 <HAL_CAN_GetRxMessage+0x4a>
    else if (RxFifo == CAN_RX_FIFO1) /* Rx element is assigned to Rx FIFO 1 */
 80009cc:	2901      	cmp	r1, #1
 80009ce:	d1f6      	bne.n	80009be <HAL_CAN_GetRxMessage+0xd6>
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 80009d0:	6802      	ldr	r2, [r0, #0]
 80009d2:	6913      	ldr	r3, [r2, #16]
 80009d4:	f043 0320 	orr.w	r3, r3, #32
 80009d8:	6113      	str	r3, [r2, #16]
 80009da:	e7f0      	b.n	80009be <HAL_CAN_GetRxMessage+0xd6>
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 80009dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80009de:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80009e2:	e792      	b.n	800090a <HAL_CAN_GetRxMessage+0x22>

080009e4 <HAL_CAN_GetRxFifoFillLevel>:
  uint32_t filllevel = 0U;

  /* Check function parameters */
  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80009e4:	f890 3020 	ldrb.w	r3, [r0, #32]
 80009e8:	2b01      	cmp	r3, #1
 80009ea:	d003      	beq.n	80009f4 <HAL_CAN_GetRxFifoFillLevel+0x10>
      (hcan->State == HAL_CAN_STATE_LISTENING))
 80009ec:	f890 3020 	ldrb.w	r3, [r0, #32]
  if ((hcan->State == HAL_CAN_STATE_READY) ||
 80009f0:	2b02      	cmp	r3, #2
 80009f2:	d107      	bne.n	8000a04 <HAL_CAN_GetRxFifoFillLevel+0x20>
 80009f4:	6803      	ldr	r3, [r0, #0]
  {
    if (RxFifo == CAN_RX_FIFO0)
 80009f6:	b919      	cbnz	r1, 8000a00 <HAL_CAN_GetRxFifoFillLevel+0x1c>
    {
      filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;
 80009f8:	68d8      	ldr	r0, [r3, #12]
    }
    else /* RxFifo == CAN_RX_FIFO1 */
    {
      filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;
 80009fa:	f000 0003 	and.w	r0, r0, #3
 80009fe:	4770      	bx	lr
 8000a00:	6918      	ldr	r0, [r3, #16]
 8000a02:	e7fa      	b.n	80009fa <HAL_CAN_GetRxFifoFillLevel+0x16>
  uint32_t filllevel = 0U;
 8000a04:	2000      	movs	r0, #0
    }
  }

  /* Return Rx FIFO fill level */
  return filllevel;
}
 8000a06:	4770      	bx	lr

08000a08 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000a08:	4a07      	ldr	r2, [pc, #28]	; (8000a28 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000a0a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000a0c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000a10:	041b      	lsls	r3, r3, #16
 8000a12:	0c1b      	lsrs	r3, r3, #16
 8000a14:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000a18:	0200      	lsls	r0, r0, #8
 8000a1a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000a1e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8000a22:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000a24:	60d3      	str	r3, [r2, #12]
 8000a26:	4770      	bx	lr
 8000a28:	e000ed00 	.word	0xe000ed00

08000a2c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000a2c:	4b17      	ldr	r3, [pc, #92]	; (8000a8c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000a2e:	b530      	push	{r4, r5, lr}
 8000a30:	68dc      	ldr	r4, [r3, #12]
 8000a32:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a36:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a3a:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a3c:	2b04      	cmp	r3, #4
 8000a3e:	bf28      	it	cs
 8000a40:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a42:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a44:	f04f 0501 	mov.w	r5, #1
 8000a48:	fa05 f303 	lsl.w	r3, r5, r3
 8000a4c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a50:	bf8c      	ite	hi
 8000a52:	3c03      	subhi	r4, #3
 8000a54:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a56:	4019      	ands	r1, r3
 8000a58:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000a5a:	fa05 f404 	lsl.w	r4, r5, r4
 8000a5e:	3c01      	subs	r4, #1
 8000a60:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8000a62:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a64:	ea42 0201 	orr.w	r2, r2, r1
 8000a68:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a6c:	bfaf      	iteee	ge
 8000a6e:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a72:	f000 000f 	andlt.w	r0, r0, #15
 8000a76:	4b06      	ldrlt	r3, [pc, #24]	; (8000a90 <HAL_NVIC_SetPriority+0x64>)
 8000a78:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a7a:	bfa5      	ittet	ge
 8000a7c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000a80:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a82:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a84:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000a88:	bd30      	pop	{r4, r5, pc}
 8000a8a:	bf00      	nop
 8000a8c:	e000ed00 	.word	0xe000ed00
 8000a90:	e000ed14 	.word	0xe000ed14

08000a94 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000a94:	0942      	lsrs	r2, r0, #5
 8000a96:	2301      	movs	r3, #1
 8000a98:	f000 001f 	and.w	r0, r0, #31
 8000a9c:	fa03 f000 	lsl.w	r0, r3, r0
 8000aa0:	4b01      	ldr	r3, [pc, #4]	; (8000aa8 <HAL_NVIC_EnableIRQ+0x14>)
 8000aa2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8000aa6:	4770      	bx	lr
 8000aa8:	e000e100 	.word	0xe000e100

08000aac <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000aac:	3801      	subs	r0, #1
 8000aae:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000ab2:	d20a      	bcs.n	8000aca <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000ab4:	4b06      	ldr	r3, [pc, #24]	; (8000ad0 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ab6:	4a07      	ldr	r2, [pc, #28]	; (8000ad4 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000ab8:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000aba:	21f0      	movs	r1, #240	; 0xf0
 8000abc:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000ac0:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000ac2:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000ac4:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000ac6:	601a      	str	r2, [r3, #0]
 8000ac8:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000aca:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000acc:	4770      	bx	lr
 8000ace:	bf00      	nop
 8000ad0:	e000e010 	.word	0xe000e010
 8000ad4:	e000ed00 	.word	0xe000ed00

08000ad8 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8000ad8:	6803      	ldr	r3, [r0, #0]
 8000ada:	b2da      	uxtb	r2, r3
 8000adc:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8000ae0:	f023 0303 	bic.w	r3, r3, #3
 8000ae4:	2118      	movs	r1, #24
 8000ae6:	3a10      	subs	r2, #16
 8000ae8:	fbb2 f2f1 	udiv	r2, r2, r1
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000aec:	4904      	ldr	r1, [pc, #16]	; (8000b00 <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
 8000aee:	2a03      	cmp	r2, #3
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8000af0:	bf88      	it	hi
 8000af2:	3304      	addhi	r3, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000af4:	5c89      	ldrb	r1, [r1, r2]
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8000af6:	6583      	str	r3, [r0, #88]	; 0x58
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000af8:	65c1      	str	r1, [r0, #92]	; 0x5c
  }
  
  return hdma->StreamBaseAddress;
}
 8000afa:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8000afc:	4770      	bx	lr
 8000afe:	bf00      	nop
 8000b00:	08006f2c 	.word	0x08006f2c

08000b04 <HAL_DMA_Init>:
{
 8000b04:	b570      	push	{r4, r5, r6, lr}
 8000b06:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000b08:	f7ff fd54 	bl	80005b4 <HAL_GetTick>
 8000b0c:	4605      	mov	r5, r0
  if(hdma == NULL)
 8000b0e:	2c00      	cmp	r4, #0
 8000b10:	d071      	beq.n	8000bf6 <HAL_DMA_Init+0xf2>
  __HAL_UNLOCK(hdma);
 8000b12:	2300      	movs	r3, #0
 8000b14:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 8000b18:	6822      	ldr	r2, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 8000b1a:	2302      	movs	r3, #2
 8000b1c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8000b20:	6813      	ldr	r3, [r2, #0]
 8000b22:	f023 0301 	bic.w	r3, r3, #1
 8000b26:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000b28:	6821      	ldr	r1, [r4, #0]
 8000b2a:	680b      	ldr	r3, [r1, #0]
 8000b2c:	07d8      	lsls	r0, r3, #31
 8000b2e:	d43c      	bmi.n	8000baa <HAL_DMA_Init+0xa6>
  tmp = hdma->Instance->CR;
 8000b30:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000b32:	4d32      	ldr	r5, [pc, #200]	; (8000bfc <HAL_DMA_Init+0xf8>)
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000b34:	6862      	ldr	r2, [r4, #4]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000b36:	69a0      	ldr	r0, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000b38:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000b3a:	68a3      	ldr	r3, [r4, #8]
 8000b3c:	4313      	orrs	r3, r2
 8000b3e:	68e2      	ldr	r2, [r4, #12]
 8000b40:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000b42:	6922      	ldr	r2, [r4, #16]
 8000b44:	4313      	orrs	r3, r2
 8000b46:	6962      	ldr	r2, [r4, #20]
 8000b48:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000b4a:	69e2      	ldr	r2, [r4, #28]
 8000b4c:	4303      	orrs	r3, r0
 8000b4e:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 8000b50:	6a22      	ldr	r2, [r4, #32]
 8000b52:	4313      	orrs	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000b54:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000b56:	2a04      	cmp	r2, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000b58:	ea43 0305 	orr.w	r3, r3, r5
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8000b5c:	bf01      	itttt	eq
 8000b5e:	6b26      	ldreq	r6, [r4, #48]	; 0x30
 8000b60:	6ae5      	ldreq	r5, [r4, #44]	; 0x2c
 8000b62:	4335      	orreq	r5, r6
 8000b64:	432b      	orreq	r3, r5
  hdma->Instance->CR = tmp;  
 8000b66:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
 8000b68:	694b      	ldr	r3, [r1, #20]
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000b6a:	2a04      	cmp	r2, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8000b6c:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
 8000b70:	ea43 0302 	orr.w	r3, r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000b74:	d10b      	bne.n	8000b8e <HAL_DMA_Init+0x8a>
    tmp |= hdma->Init.FIFOThreshold;
 8000b76:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8000b78:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8000b7a:	4313      	orrs	r3, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8000b7c:	b13d      	cbz	r5, 8000b8e <HAL_DMA_Init+0x8a>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8000b7e:	b9f8      	cbnz	r0, 8000bc0 <HAL_DMA_Init+0xbc>
  {
    switch (tmp)
 8000b80:	2a01      	cmp	r2, #1
 8000b82:	d02d      	beq.n	8000be0 <HAL_DMA_Init+0xdc>
 8000b84:	d301      	bcc.n	8000b8a <HAL_DMA_Init+0x86>
 8000b86:	2a02      	cmp	r2, #2
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8000b88:	d101      	bne.n	8000b8e <HAL_DMA_Init+0x8a>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8000b8a:	01ea      	lsls	r2, r5, #7
 8000b8c:	d42b      	bmi.n	8000be6 <HAL_DMA_Init+0xe2>
  hdma->Instance->FCR = tmp;
 8000b8e:	614b      	str	r3, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8000b90:	4620      	mov	r0, r4
 8000b92:	f7ff ffa1 	bl	8000ad8 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000b96:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000b98:	233f      	movs	r3, #63	; 0x3f
 8000b9a:	4093      	lsls	r3, r2
 8000b9c:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b9e:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8000ba0:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000ba2:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8000ba4:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8000ba8:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000baa:	f7ff fd03 	bl	80005b4 <HAL_GetTick>
 8000bae:	1b40      	subs	r0, r0, r5
 8000bb0:	2805      	cmp	r0, #5
 8000bb2:	d9b9      	bls.n	8000b28 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000bb4:	2320      	movs	r3, #32
 8000bb6:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000bb8:	2003      	movs	r0, #3
        hdma->State = HAL_DMA_STATE_READY;
 8000bba:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8000bbe:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8000bc0:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8000bc4:	d113      	bne.n	8000bee <HAL_DMA_Init+0xea>
    switch (tmp)
 8000bc6:	2a03      	cmp	r2, #3
 8000bc8:	d8e1      	bhi.n	8000b8e <HAL_DMA_Init+0x8a>
 8000bca:	a001      	add	r0, pc, #4	; (adr r0, 8000bd0 <HAL_DMA_Init+0xcc>)
 8000bcc:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8000bd0:	08000be7 	.word	0x08000be7
 8000bd4:	08000b8b 	.word	0x08000b8b
 8000bd8:	08000be7 	.word	0x08000be7
 8000bdc:	08000be1 	.word	0x08000be1
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8000be0:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 8000be4:	d1d3      	bne.n	8000b8e <HAL_DMA_Init+0x8a>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8000be6:	2340      	movs	r3, #64	; 0x40
 8000be8:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8000bea:	2001      	movs	r0, #1
 8000bec:	e7e5      	b.n	8000bba <HAL_DMA_Init+0xb6>
    switch (tmp)
 8000bee:	2a02      	cmp	r2, #2
 8000bf0:	d9f9      	bls.n	8000be6 <HAL_DMA_Init+0xe2>
 8000bf2:	2a03      	cmp	r2, #3
 8000bf4:	e7c8      	b.n	8000b88 <HAL_DMA_Init+0x84>
    return HAL_ERROR;
 8000bf6:	2001      	movs	r0, #1
 8000bf8:	bd70      	pop	{r4, r5, r6, pc}
 8000bfa:	bf00      	nop
 8000bfc:	f010803f 	.word	0xf010803f

08000c00 <HAL_DMA_Start_IT>:
{
 8000c00:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 8000c02:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8000c06:	2c01      	cmp	r4, #1
 8000c08:	d036      	beq.n	8000c78 <HAL_DMA_Start_IT+0x78>
 8000c0a:	2401      	movs	r4, #1
 8000c0c:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8000c10:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8000c14:	6d86      	ldr	r6, [r0, #88]	; 0x58
  if(HAL_DMA_STATE_READY == hdma->State)
 8000c16:	2c01      	cmp	r4, #1
 8000c18:	f04f 0500 	mov.w	r5, #0
 8000c1c:	f04f 0402 	mov.w	r4, #2
 8000c20:	d128      	bne.n	8000c74 <HAL_DMA_Start_IT+0x74>
    hdma->State = HAL_DMA_STATE_BUSY;
 8000c22:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8000c26:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000c28:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8000c2a:	6825      	ldr	r5, [r4, #0]
 8000c2c:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 8000c30:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8000c32:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8000c34:	6883      	ldr	r3, [r0, #8]
 8000c36:	2b40      	cmp	r3, #64	; 0x40
    hdma->Instance->PAR = DstAddress;
 8000c38:	bf0e      	itee	eq
 8000c3a:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 8000c3c:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8000c3e:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000c40:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = SrcAddress;
 8000c42:	bf08      	it	eq
 8000c44:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000c46:	233f      	movs	r3, #63	; 0x3f
 8000c48:	4093      	lsls	r3, r2
 8000c4a:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8000c4c:	6823      	ldr	r3, [r4, #0]
 8000c4e:	f043 0316 	orr.w	r3, r3, #22
 8000c52:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8000c54:	6963      	ldr	r3, [r4, #20]
 8000c56:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c5a:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8000c5c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000c5e:	b11b      	cbz	r3, 8000c68 <HAL_DMA_Start_IT+0x68>
      hdma->Instance->CR  |= DMA_IT_HT;
 8000c60:	6823      	ldr	r3, [r4, #0]
 8000c62:	f043 0308 	orr.w	r3, r3, #8
 8000c66:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8000c68:	6823      	ldr	r3, [r4, #0]
 8000c6a:	f043 0301 	orr.w	r3, r3, #1
 8000c6e:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8000c70:	2000      	movs	r0, #0
 8000c72:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hdma);	  
 8000c74:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  __HAL_LOCK(hdma);
 8000c78:	2002      	movs	r0, #2
}
 8000c7a:	bd70      	pop	{r4, r5, r6, pc}

08000c7c <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000c7c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000c80:	2b02      	cmp	r3, #2
 8000c82:	d003      	beq.n	8000c8c <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c84:	2380      	movs	r3, #128	; 0x80
 8000c86:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8000c88:	2001      	movs	r0, #1
 8000c8a:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8000c8c:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8000c8e:	2305      	movs	r3, #5
 8000c90:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8000c94:	6813      	ldr	r3, [r2, #0]
 8000c96:	f023 0301 	bic.w	r3, r3, #1
 8000c9a:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8000c9c:	2000      	movs	r0, #0
}
 8000c9e:	4770      	bx	lr

08000ca0 <HAL_DMA_IRQHandler>:
{
 8000ca0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t count = 0U;
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8000ca6:	4b5a      	ldr	r3, [pc, #360]	; (8000e10 <HAL_DMA_IRQHandler+0x170>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8000ca8:	6d85      	ldr	r5, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 8000caa:	681f      	ldr	r7, [r3, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cac:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
 8000cae:	682e      	ldr	r6, [r5, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cb0:	2208      	movs	r2, #8
 8000cb2:	409a      	lsls	r2, r3
 8000cb4:	4216      	tst	r6, r2
{
 8000cb6:	4604      	mov	r4, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cb8:	d00c      	beq.n	8000cd4 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8000cba:	6801      	ldr	r1, [r0, #0]
 8000cbc:	6808      	ldr	r0, [r1, #0]
 8000cbe:	0740      	lsls	r0, r0, #29
 8000cc0:	d508      	bpl.n	8000cd4 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8000cc2:	6808      	ldr	r0, [r1, #0]
 8000cc4:	f020 0004 	bic.w	r0, r0, #4
 8000cc8:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8000cca:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8000ccc:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8000cce:	f042 0201 	orr.w	r2, r2, #1
 8000cd2:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cd4:	2201      	movs	r2, #1
 8000cd6:	409a      	lsls	r2, r3
 8000cd8:	4216      	tst	r6, r2
 8000cda:	d008      	beq.n	8000cee <HAL_DMA_IRQHandler+0x4e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8000cdc:	6821      	ldr	r1, [r4, #0]
 8000cde:	6949      	ldr	r1, [r1, #20]
 8000ce0:	0609      	lsls	r1, r1, #24
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8000ce2:	bf41      	itttt	mi
 8000ce4:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8000ce6:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8000ce8:	f042 0202 	orrmi.w	r2, r2, #2
 8000cec:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cee:	2204      	movs	r2, #4
 8000cf0:	409a      	lsls	r2, r3
 8000cf2:	4216      	tst	r6, r2
 8000cf4:	d008      	beq.n	8000d08 <HAL_DMA_IRQHandler+0x68>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8000cf6:	6821      	ldr	r1, [r4, #0]
 8000cf8:	6809      	ldr	r1, [r1, #0]
 8000cfa:	0788      	lsls	r0, r1, #30
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8000cfc:	bf41      	itttt	mi
 8000cfe:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8000d00:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8000d02:	f042 0204 	orrmi.w	r2, r2, #4
 8000d06:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8000d08:	2210      	movs	r2, #16
 8000d0a:	409a      	lsls	r2, r3
 8000d0c:	4216      	tst	r6, r2
 8000d0e:	d010      	beq.n	8000d32 <HAL_DMA_IRQHandler+0x92>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8000d10:	6823      	ldr	r3, [r4, #0]
 8000d12:	6819      	ldr	r1, [r3, #0]
 8000d14:	0709      	lsls	r1, r1, #28
 8000d16:	d50c      	bpl.n	8000d32 <HAL_DMA_IRQHandler+0x92>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8000d18:	60aa      	str	r2, [r5, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8000d1a:	681a      	ldr	r2, [r3, #0]
 8000d1c:	0350      	lsls	r0, r2, #13
 8000d1e:	d535      	bpl.n	8000d8c <HAL_DMA_IRQHandler+0xec>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8000d20:	681b      	ldr	r3, [r3, #0]
 8000d22:	0319      	lsls	r1, r3, #12
 8000d24:	d401      	bmi.n	8000d2a <HAL_DMA_IRQHandler+0x8a>
        if(hdma->XferHalfCpltCallback != NULL)
 8000d26:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000d28:	e000      	b.n	8000d2c <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8000d2a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
        if(hdma->XferHalfCpltCallback != NULL)
 8000d2c:	b10b      	cbz	r3, 8000d32 <HAL_DMA_IRQHandler+0x92>
          hdma->XferHalfCpltCallback(hdma);
 8000d2e:	4620      	mov	r0, r4
 8000d30:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8000d32:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8000d34:	2220      	movs	r2, #32
 8000d36:	408a      	lsls	r2, r1
 8000d38:	4216      	tst	r6, r2
 8000d3a:	d038      	beq.n	8000dae <HAL_DMA_IRQHandler+0x10e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8000d3c:	6823      	ldr	r3, [r4, #0]
 8000d3e:	6818      	ldr	r0, [r3, #0]
 8000d40:	06c6      	lsls	r6, r0, #27
 8000d42:	d534      	bpl.n	8000dae <HAL_DMA_IRQHandler+0x10e>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8000d44:	60aa      	str	r2, [r5, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8000d46:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8000d4a:	2a05      	cmp	r2, #5
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000d4c:	681a      	ldr	r2, [r3, #0]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8000d4e:	d125      	bne.n	8000d9c <HAL_DMA_IRQHandler+0xfc>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000d50:	f022 0216 	bic.w	r2, r2, #22
 8000d54:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8000d56:	695a      	ldr	r2, [r3, #20]
 8000d58:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000d5c:	615a      	str	r2, [r3, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8000d5e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000d60:	b90a      	cbnz	r2, 8000d66 <HAL_DMA_IRQHandler+0xc6>
 8000d62:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8000d64:	b11a      	cbz	r2, 8000d6e <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000d66:	681a      	ldr	r2, [r3, #0]
 8000d68:	f022 0208 	bic.w	r2, r2, #8
 8000d6c:	601a      	str	r2, [r3, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000d6e:	233f      	movs	r3, #63	; 0x3f
 8000d70:	408b      	lsls	r3, r1
 8000d72:	60ab      	str	r3, [r5, #8]
        __HAL_UNLOCK(hdma);
 8000d74:	2300      	movs	r3, #0
 8000d76:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8000d7a:	2301      	movs	r3, #1
 8000d7c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8000d80:	6d23      	ldr	r3, [r4, #80]	; 0x50
    if(hdma->XferErrorCallback != NULL)
 8000d82:	b10b      	cbz	r3, 8000d88 <HAL_DMA_IRQHandler+0xe8>
      hdma->XferErrorCallback(hdma);
 8000d84:	4620      	mov	r0, r4
 8000d86:	4798      	blx	r3
}
 8000d88:	b003      	add	sp, #12
 8000d8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8000d8c:	681a      	ldr	r2, [r3, #0]
 8000d8e:	05d2      	lsls	r2, r2, #23
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000d90:	bf5e      	ittt	pl
 8000d92:	681a      	ldrpl	r2, [r3, #0]
 8000d94:	f022 0208 	bicpl.w	r2, r2, #8
 8000d98:	601a      	strpl	r2, [r3, #0]
 8000d9a:	e7c4      	b.n	8000d26 <HAL_DMA_IRQHandler+0x86>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8000d9c:	0350      	lsls	r0, r2, #13
 8000d9e:	d528      	bpl.n	8000df2 <HAL_DMA_IRQHandler+0x152>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8000da0:	681b      	ldr	r3, [r3, #0]
 8000da2:	0319      	lsls	r1, r3, #12
 8000da4:	d432      	bmi.n	8000e0c <HAL_DMA_IRQHandler+0x16c>
          if(hdma->XferM1CpltCallback != NULL)
 8000da6:	6c63      	ldr	r3, [r4, #68]	; 0x44
        if(hdma->XferCpltCallback != NULL)
 8000da8:	b10b      	cbz	r3, 8000dae <HAL_DMA_IRQHandler+0x10e>
          hdma->XferCpltCallback(hdma);
 8000daa:	4620      	mov	r0, r4
 8000dac:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8000dae:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000db0:	2b00      	cmp	r3, #0
 8000db2:	d0e9      	beq.n	8000d88 <HAL_DMA_IRQHandler+0xe8>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8000db4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000db6:	07da      	lsls	r2, r3, #31
 8000db8:	d519      	bpl.n	8000dee <HAL_DMA_IRQHandler+0x14e>
      hdma->State = HAL_DMA_STATE_ABORT;
 8000dba:	2305      	movs	r3, #5
      __HAL_DMA_DISABLE(hdma);
 8000dbc:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_ABORT;
 8000dbe:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8000dc2:	6813      	ldr	r3, [r2, #0]
 8000dc4:	f023 0301 	bic.w	r3, r3, #1
 8000dc8:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8000dca:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8000dce:	fbb7 f7f3 	udiv	r7, r7, r3
        if (++count > timeout)
 8000dd2:	9b01      	ldr	r3, [sp, #4]
 8000dd4:	3301      	adds	r3, #1
 8000dd6:	429f      	cmp	r7, r3
 8000dd8:	9301      	str	r3, [sp, #4]
 8000dda:	d302      	bcc.n	8000de2 <HAL_DMA_IRQHandler+0x142>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8000ddc:	6813      	ldr	r3, [r2, #0]
 8000dde:	07db      	lsls	r3, r3, #31
 8000de0:	d4f7      	bmi.n	8000dd2 <HAL_DMA_IRQHandler+0x132>
      __HAL_UNLOCK(hdma);
 8000de2:	2300      	movs	r3, #0
 8000de4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8000de8:	2301      	movs	r3, #1
 8000dea:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8000dee:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000df0:	e7c7      	b.n	8000d82 <HAL_DMA_IRQHandler+0xe2>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8000df2:	681a      	ldr	r2, [r3, #0]
 8000df4:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 8000df8:	d108      	bne.n	8000e0c <HAL_DMA_IRQHandler+0x16c>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8000dfa:	6819      	ldr	r1, [r3, #0]
 8000dfc:	f021 0110 	bic.w	r1, r1, #16
 8000e00:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8000e02:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
 8000e04:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8000e08:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8000e0c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000e0e:	e7cb      	b.n	8000da8 <HAL_DMA_IRQHandler+0x108>
 8000e10:	20000010 	.word	0x20000010

08000e14 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000e14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e18:	b085      	sub	sp, #20
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e1a:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000e1c:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 8000fc0 <HAL_GPIO_Init+0x1ac>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000e20:	4a65      	ldr	r2, [pc, #404]	; (8000fb8 <HAL_GPIO_Init+0x1a4>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000e22:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8000fc4 <HAL_GPIO_Init+0x1b0>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e26:	9301      	str	r3, [sp, #4]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000e28:	2300      	movs	r3, #0
    ioposition = 0x01U << position;
 8000e2a:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e2e:	9c01      	ldr	r4, [sp, #4]
    ioposition = 0x01U << position;
 8000e30:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e34:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
 8000e38:	45b6      	cmp	lr, r6
 8000e3a:	f040 80aa 	bne.w	8000f92 <HAL_GPIO_Init+0x17e>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000e3e:	684c      	ldr	r4, [r1, #4]
 8000e40:	f024 0710 	bic.w	r7, r4, #16
 8000e44:	2f02      	cmp	r7, #2
 8000e46:	d116      	bne.n	8000e76 <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3U];
 8000e48:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8000e4c:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000e50:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8000e54:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000e58:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000e5c:	f04f 0c0f 	mov.w	ip, #15
 8000e60:	fa0c fc0b 	lsl.w	ip, ip, fp
 8000e64:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000e68:	690d      	ldr	r5, [r1, #16]
 8000e6a:	fa05 f50b 	lsl.w	r5, r5, fp
 8000e6e:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3U] = temp;
 8000e72:	f8ca 5020 	str.w	r5, [sl, #32]
 8000e76:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000e7a:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8000e7c:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000e80:	fa05 f50a 	lsl.w	r5, r5, sl
 8000e84:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000e86:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000e8a:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000e8e:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000e92:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000e94:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000e98:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8000e9a:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000e9e:	d811      	bhi.n	8000ec4 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR; 
 8000ea0:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000ea2:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000ea6:	68cf      	ldr	r7, [r1, #12]
 8000ea8:	fa07 fc0a 	lsl.w	ip, r7, sl
 8000eac:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8000eb0:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8000eb2:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000eb4:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000eb8:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8000ebc:	409f      	lsls	r7, r3
 8000ebe:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000ec2:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000ec4:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000ec6:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000ec8:	688f      	ldr	r7, [r1, #8]
 8000eca:	fa07 f70a 	lsl.w	r7, r7, sl
 8000ece:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8000ed0:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000ed2:	00e5      	lsls	r5, r4, #3
 8000ed4:	d55d      	bpl.n	8000f92 <HAL_GPIO_Init+0x17e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ed6:	f04f 0b00 	mov.w	fp, #0
 8000eda:	f8cd b00c 	str.w	fp, [sp, #12]
 8000ede:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000ee2:	4d36      	ldr	r5, [pc, #216]	; (8000fbc <HAL_GPIO_Init+0x1a8>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ee4:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 8000ee8:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
 8000eec:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 8000ef0:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 8000ef4:	9703      	str	r7, [sp, #12]
 8000ef6:	9f03      	ldr	r7, [sp, #12]
 8000ef8:	f023 0703 	bic.w	r7, r3, #3
 8000efc:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8000f00:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f04:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8000f08:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f0c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8000f10:	f04f 0e0f 	mov.w	lr, #15
 8000f14:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000f18:	42a8      	cmp	r0, r5
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f1a:	ea2a 0e0e 	bic.w	lr, sl, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000f1e:	d03f      	beq.n	8000fa0 <HAL_GPIO_Init+0x18c>
 8000f20:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000f24:	42a8      	cmp	r0, r5
 8000f26:	d03d      	beq.n	8000fa4 <HAL_GPIO_Init+0x190>
 8000f28:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000f2c:	42a8      	cmp	r0, r5
 8000f2e:	d03b      	beq.n	8000fa8 <HAL_GPIO_Init+0x194>
 8000f30:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000f34:	42a8      	cmp	r0, r5
 8000f36:	d039      	beq.n	8000fac <HAL_GPIO_Init+0x198>
 8000f38:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000f3c:	42a8      	cmp	r0, r5
 8000f3e:	d037      	beq.n	8000fb0 <HAL_GPIO_Init+0x19c>
 8000f40:	4548      	cmp	r0, r9
 8000f42:	d037      	beq.n	8000fb4 <HAL_GPIO_Init+0x1a0>
 8000f44:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8000f48:	42a8      	cmp	r0, r5
 8000f4a:	bf14      	ite	ne
 8000f4c:	2507      	movne	r5, #7
 8000f4e:	2506      	moveq	r5, #6
 8000f50:	fa05 f50c 	lsl.w	r5, r5, ip
 8000f54:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000f58:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR;
 8000f5a:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8000f5c:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000f5e:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8000f62:	bf0c      	ite	eq
 8000f64:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000f66:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 8000f68:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR;
 8000f6a:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000f6c:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8000f70:	bf0c      	ite	eq
 8000f72:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000f74:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 8000f76:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000f78:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000f7a:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8000f7e:	bf0c      	ite	eq
 8000f80:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000f82:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 8000f84:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR;
 8000f86:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000f88:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8000f8a:	bf54      	ite	pl
 8000f8c:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 8000f8e:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 8000f90:	60d5      	str	r5, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000f92:	3301      	adds	r3, #1
 8000f94:	2b10      	cmp	r3, #16
 8000f96:	f47f af48 	bne.w	8000e2a <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 8000f9a:	b005      	add	sp, #20
 8000f9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000fa0:	465d      	mov	r5, fp
 8000fa2:	e7d5      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fa4:	2501      	movs	r5, #1
 8000fa6:	e7d3      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fa8:	2502      	movs	r5, #2
 8000faa:	e7d1      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fac:	2503      	movs	r5, #3
 8000fae:	e7cf      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fb0:	2504      	movs	r5, #4
 8000fb2:	e7cd      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fb4:	2505      	movs	r5, #5
 8000fb6:	e7cb      	b.n	8000f50 <HAL_GPIO_Init+0x13c>
 8000fb8:	40013c00 	.word	0x40013c00
 8000fbc:	40020000 	.word	0x40020000
 8000fc0:	40023800 	.word	0x40023800
 8000fc4:	40021400 	.word	0x40021400

08000fc8 <HAL_I2C_Init>:
  * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8000fc8:	b570      	push	{r4, r5, r6, lr}
  uint32_t freqrange = 0U;
  uint32_t pclk1 = 0U;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 8000fca:	4604      	mov	r4, r0
 8000fcc:	2800      	cmp	r0, #0
 8000fce:	d062      	beq.n	8001096 <HAL_I2C_Init+0xce>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 8000fd0:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8000fd4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000fd8:	b91b      	cbnz	r3, 8000fe2 <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8000fda:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 8000fde:	f004 fe3b 	bl	8005c58 <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8000fe2:	6822      	ldr	r2, [r4, #0]
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000fe4:	4e2d      	ldr	r6, [pc, #180]	; (800109c <HAL_I2C_Init+0xd4>)
  freqrange = I2C_FREQRANGE(pclk1);
 8000fe6:	4d2e      	ldr	r5, [pc, #184]	; (80010a0 <HAL_I2C_Init+0xd8>)
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000fe8:	2324      	movs	r3, #36	; 0x24
 8000fea:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8000fee:	6813      	ldr	r3, [r2, #0]
 8000ff0:	f023 0301 	bic.w	r3, r3, #1
 8000ff4:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8000ff6:	f000 f971 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ffa:	6863      	ldr	r3, [r4, #4]
  hi2c->Instance->CR2 = freqrange;
 8000ffc:	6822      	ldr	r2, [r4, #0]
  freqrange = I2C_FREQRANGE(pclk1);
 8000ffe:	fbb0 f5f5 	udiv	r5, r0, r5
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8001002:	42b3      	cmp	r3, r6
 8001004:	bf84      	itt	hi
 8001006:	f44f 7196 	movhi.w	r1, #300	; 0x12c
 800100a:	4369      	mulhi	r1, r5
  hi2c->Instance->CR2 = freqrange;
 800100c:	6055      	str	r5, [r2, #4]
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 800100e:	bf91      	iteee	ls
 8001010:	1c69      	addls	r1, r5, #1
 8001012:	f44f 757a 	movhi.w	r5, #1000	; 0x3e8
 8001016:	fbb1 f1f5 	udivhi	r1, r1, r5
 800101a:	3101      	addhi	r1, #1

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 800101c:	42b3      	cmp	r3, r6
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 800101e:	6211      	str	r1, [r2, #32]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8001020:	d821      	bhi.n	8001066 <HAL_I2C_Init+0x9e>
 8001022:	005b      	lsls	r3, r3, #1
 8001024:	fbb0 f0f3 	udiv	r0, r0, r3
 8001028:	f3c0 030b 	ubfx	r3, r0, #0, #12
 800102c:	2b03      	cmp	r3, #3
 800102e:	bf98      	it	ls
 8001030:	2004      	movls	r0, #4

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001032:	6a21      	ldr	r1, [r4, #32]
 8001034:	69e3      	ldr	r3, [r4, #28]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8001036:	61d0      	str	r0, [r2, #28]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001038:	430b      	orrs	r3, r1
 800103a:	6013      	str	r3, [r2, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 800103c:	68e1      	ldr	r1, [r4, #12]
 800103e:	6923      	ldr	r3, [r4, #16]
 8001040:	430b      	orrs	r3, r1
 8001042:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8001044:	69a1      	ldr	r1, [r4, #24]
 8001046:	6963      	ldr	r3, [r4, #20]
 8001048:	430b      	orrs	r3, r1
 800104a:	60d3      	str	r3, [r2, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800104c:	6813      	ldr	r3, [r2, #0]
 800104e:	f043 0301 	orr.w	r3, r3, #1
 8001052:	6013      	str	r3, [r2, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001054:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8001056:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001058:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800105a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800105e:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001060:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e

  return HAL_OK;
 8001064:	bd70      	pop	{r4, r5, r6, pc}
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8001066:	68a1      	ldr	r1, [r4, #8]
 8001068:	b949      	cbnz	r1, 800107e <HAL_I2C_Init+0xb6>
 800106a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800106e:	fbb0 f0f3 	udiv	r0, r0, r3
 8001072:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8001076:	b163      	cbz	r3, 8001092 <HAL_I2C_Init+0xca>
 8001078:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 800107c:	e7d9      	b.n	8001032 <HAL_I2C_Init+0x6a>
 800107e:	2119      	movs	r1, #25
 8001080:	434b      	muls	r3, r1
 8001082:	fbb0 f0f3 	udiv	r0, r0, r3
 8001086:	f3c0 030b 	ubfx	r3, r0, #0, #12
 800108a:	b113      	cbz	r3, 8001092 <HAL_I2C_Init+0xca>
 800108c:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 8001090:	e7cf      	b.n	8001032 <HAL_I2C_Init+0x6a>
 8001092:	2001      	movs	r0, #1
 8001094:	e7cd      	b.n	8001032 <HAL_I2C_Init+0x6a>
    return HAL_ERROR;
 8001096:	2001      	movs	r0, #1
}
 8001098:	bd70      	pop	{r4, r5, r6, pc}
 800109a:	bf00      	nop
 800109c:	000186a0 	.word	0x000186a0
 80010a0:	000f4240 	.word	0x000f4240

080010a4 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag, 
                                                        FlagStatus State, uint32_t tickstart, uint32_t Timeout)
{
 80010a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80010a8:	9d06      	ldr	r5, [sp, #24]
 80010aa:	4604      	mov	r4, r0
 80010ac:	460f      	mov	r7, r1
 80010ae:	4616      	mov	r6, r2
 80010b0:	4698      	mov	r8, r3
  /* Wait until flag is in expected state */    
  while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80010b2:	6821      	ldr	r1, [r4, #0]
 80010b4:	688a      	ldr	r2, [r1, #8]
 80010b6:	423a      	tst	r2, r7
 80010b8:	bf14      	ite	ne
 80010ba:	2201      	movne	r2, #1
 80010bc:	2200      	moveq	r2, #0
 80010be:	42b2      	cmp	r2, r6
 80010c0:	d102      	bne.n	80010c8 <QSPI_WaitFlagStateUntilTimeout+0x24>
        
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 80010c2:	2000      	movs	r0, #0
}
 80010c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (Timeout != HAL_MAX_DELAY)
 80010c8:	1c6b      	adds	r3, r5, #1
 80010ca:	d0f3      	beq.n	80010b4 <QSPI_WaitFlagStateUntilTimeout+0x10>
      if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
 80010cc:	b94d      	cbnz	r5, 80010e2 <QSPI_WaitFlagStateUntilTimeout+0x3e>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80010ce:	2304      	movs	r3, #4
 80010d0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80010d4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80010d6:	f043 0301 	orr.w	r3, r3, #1
 80010da:	6463      	str	r3, [r4, #68]	; 0x44
 80010dc:	2001      	movs	r0, #1
 80010de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
 80010e2:	f7ff fa67 	bl	80005b4 <HAL_GetTick>
 80010e6:	eba0 0008 	sub.w	r0, r0, r8
 80010ea:	4285      	cmp	r5, r0
 80010ec:	d2e1      	bcs.n	80010b2 <QSPI_WaitFlagStateUntilTimeout+0xe>
 80010ee:	e7ee      	b.n	80010ce <QSPI_WaitFlagStateUntilTimeout+0x2a>

080010f0 <HAL_QSPI_Init>:
{
 80010f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80010f2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80010f4:	f7ff fa5e 	bl	80005b4 <HAL_GetTick>
 80010f8:	4605      	mov	r5, r0
  if(hqspi == NULL)
 80010fa:	2c00      	cmp	r4, #0
 80010fc:	d04d      	beq.n	800119a <HAL_QSPI_Init+0xaa>
  __HAL_LOCK(hqspi);
 80010fe:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8001102:	2b01      	cmp	r3, #1
 8001104:	d04b      	beq.n	800119e <HAL_QSPI_Init+0xae>
 8001106:	2301      	movs	r3, #1
 8001108:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 800110c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8001110:	f002 03ff 	and.w	r3, r2, #255	; 0xff
 8001114:	b93a      	cbnz	r2, 8001126 <HAL_QSPI_Init+0x36>
    hqspi->Lock = HAL_UNLOCKED;
 8001116:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_QSPI_MspInit(hqspi);
 800111a:	4620      	mov	r0, r4
 800111c:	f004 feea 	bl	8005ef4 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 8001120:	f241 3388 	movw	r3, #5000	; 0x1388
 8001124:	64a3      	str	r3, [r4, #72]	; 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1U) << 8U));
 8001126:	6820      	ldr	r0, [r4, #0]
 8001128:	68a1      	ldr	r1, [r4, #8]
 800112a:	6802      	ldr	r2, [r0, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 800112c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1U) << 8U));
 800112e:	3901      	subs	r1, #1
 8001130:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8001134:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001138:	6002      	str	r2, [r0, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 800113a:	2120      	movs	r1, #32
 800113c:	9300      	str	r3, [sp, #0]
 800113e:	2200      	movs	r2, #0
 8001140:	462b      	mov	r3, r5
 8001142:	4620      	mov	r0, r4
 8001144:	f7ff ffae 	bl	80010a4 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
 8001148:	bb10      	cbnz	r0, 8001190 <HAL_QSPI_Init+0xa0>
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24U)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 800114a:	69e5      	ldr	r5, [r4, #28]
 800114c:	68e3      	ldr	r3, [r4, #12]
 800114e:	6822      	ldr	r2, [r4, #0]
 8001150:	432b      	orrs	r3, r5
 8001152:	6a25      	ldr	r5, [r4, #32]
 8001154:	6811      	ldr	r1, [r2, #0]
 8001156:	432b      	orrs	r3, r5
 8001158:	6865      	ldr	r5, [r4, #4]
 800115a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 800115e:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 8001162:	f021 01d0 	bic.w	r1, r1, #208	; 0xd0
 8001166:	430b      	orrs	r3, r1
 8001168:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 800116a:	69a1      	ldr	r1, [r4, #24]
 800116c:	6963      	ldr	r3, [r4, #20]
 800116e:	6855      	ldr	r5, [r2, #4]
 8001170:	430b      	orrs	r3, r1
 8001172:	6921      	ldr	r1, [r4, #16]
 8001174:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001178:	490a      	ldr	r1, [pc, #40]	; (80011a4 <HAL_QSPI_Init+0xb4>)
 800117a:	4029      	ands	r1, r5
 800117c:	430b      	orrs	r3, r1
 800117e:	6053      	str	r3, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8001180:	6813      	ldr	r3, [r2, #0]
 8001182:	f043 0301 	orr.w	r3, r3, #1
 8001186:	6013      	str	r3, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
 8001188:	2301      	movs	r3, #1
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;  
 800118a:	6460      	str	r0, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 800118c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 8001190:	2300      	movs	r3, #0
 8001192:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8001196:	b003      	add	sp, #12
 8001198:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 800119a:	2001      	movs	r0, #1
 800119c:	e7fb      	b.n	8001196 <HAL_QSPI_Init+0xa6>
  __HAL_LOCK(hqspi);
 800119e:	2002      	movs	r0, #2
 80011a0:	e7f9      	b.n	8001196 <HAL_QSPI_Init+0xa6>
 80011a2:	bf00      	nop
 80011a4:	ffe0f8fe 	.word	0xffe0f8fe

080011a8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80011a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80011ac:	460d      	mov	r5, r1
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80011ae:	4604      	mov	r4, r0
 80011b0:	b910      	cbnz	r0, 80011b8 <HAL_RCC_ClockConfig+0x10>
  {
    return HAL_ERROR;
 80011b2:	2001      	movs	r0, #1
 80011b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80011b8:	4b44      	ldr	r3, [pc, #272]	; (80012cc <HAL_RCC_ClockConfig+0x124>)
 80011ba:	681a      	ldr	r2, [r3, #0]
 80011bc:	f002 020f 	and.w	r2, r2, #15
 80011c0:	428a      	cmp	r2, r1
 80011c2:	d328      	bcc.n	8001216 <HAL_RCC_ClockConfig+0x6e>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80011c4:	6821      	ldr	r1, [r4, #0]
 80011c6:	078f      	lsls	r7, r1, #30
 80011c8:	d42d      	bmi.n	8001226 <HAL_RCC_ClockConfig+0x7e>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80011ca:	07c8      	lsls	r0, r1, #31
 80011cc:	d440      	bmi.n	8001250 <HAL_RCC_ClockConfig+0xa8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80011ce:	4b3f      	ldr	r3, [pc, #252]	; (80012cc <HAL_RCC_ClockConfig+0x124>)
 80011d0:	681a      	ldr	r2, [r3, #0]
 80011d2:	f002 020f 	and.w	r2, r2, #15
 80011d6:	4295      	cmp	r5, r2
 80011d8:	d366      	bcc.n	80012a8 <HAL_RCC_ClockConfig+0x100>
      return HAL_ERROR;
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80011da:	6822      	ldr	r2, [r4, #0]
 80011dc:	0751      	lsls	r1, r2, #29
 80011de:	d46c      	bmi.n	80012ba <HAL_RCC_ClockConfig+0x112>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80011e0:	0713      	lsls	r3, r2, #28
 80011e2:	d507      	bpl.n	80011f4 <HAL_RCC_ClockConfig+0x4c>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80011e4:	4a3a      	ldr	r2, [pc, #232]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
 80011e6:	6921      	ldr	r1, [r4, #16]
 80011e8:	6893      	ldr	r3, [r2, #8]
 80011ea:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80011ee:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80011f2:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80011f4:	f000 fa9a 	bl	800172c <HAL_RCC_GetSysClockFreq>
 80011f8:	4b35      	ldr	r3, [pc, #212]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
 80011fa:	4a36      	ldr	r2, [pc, #216]	; (80012d4 <HAL_RCC_ClockConfig+0x12c>)
 80011fc:	689b      	ldr	r3, [r3, #8]
 80011fe:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001202:	5cd3      	ldrb	r3, [r2, r3]
 8001204:	40d8      	lsrs	r0, r3
 8001206:	4b34      	ldr	r3, [pc, #208]	; (80012d8 <HAL_RCC_ClockConfig+0x130>)
 8001208:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (TICK_INT_PRIORITY);
 800120a:	200f      	movs	r0, #15
 800120c:	f7ff f988 	bl	8000520 <HAL_InitTick>

  return HAL_OK;
 8001210:	2000      	movs	r0, #0
 8001212:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001216:	b2ca      	uxtb	r2, r1
 8001218:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	f003 030f 	and.w	r3, r3, #15
 8001220:	4299      	cmp	r1, r3
 8001222:	d1c6      	bne.n	80011b2 <HAL_RCC_ClockConfig+0xa>
 8001224:	e7ce      	b.n	80011c4 <HAL_RCC_ClockConfig+0x1c>
 8001226:	4b2a      	ldr	r3, [pc, #168]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001228:	f011 0f04 	tst.w	r1, #4
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800122c:	bf1e      	ittt	ne
 800122e:	689a      	ldrne	r2, [r3, #8]
 8001230:	f442 52e0 	orrne.w	r2, r2, #7168	; 0x1c00
 8001234:	609a      	strne	r2, [r3, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001236:	070e      	lsls	r6, r1, #28
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8001238:	bf42      	ittt	mi
 800123a:	689a      	ldrmi	r2, [r3, #8]
 800123c:	f442 4260 	orrmi.w	r2, r2, #57344	; 0xe000
 8001240:	609a      	strmi	r2, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001242:	689a      	ldr	r2, [r3, #8]
 8001244:	68a0      	ldr	r0, [r4, #8]
 8001246:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800124a:	4302      	orrs	r2, r0
 800124c:	609a      	str	r2, [r3, #8]
 800124e:	e7bc      	b.n	80011ca <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001250:	6862      	ldr	r2, [r4, #4]
 8001252:	4b1f      	ldr	r3, [pc, #124]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
 8001254:	2a01      	cmp	r2, #1
 8001256:	d11d      	bne.n	8001294 <HAL_RCC_ClockConfig+0xec>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001258:	681b      	ldr	r3, [r3, #0]
 800125a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800125e:	d0a8      	beq.n	80011b2 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001260:	4e1b      	ldr	r6, [pc, #108]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
 8001262:	68b3      	ldr	r3, [r6, #8]
 8001264:	f023 0303 	bic.w	r3, r3, #3
 8001268:	4313      	orrs	r3, r2
 800126a:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800126c:	f7ff f9a2 	bl	80005b4 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001270:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8001274:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001276:	68b3      	ldr	r3, [r6, #8]
 8001278:	6862      	ldr	r2, [r4, #4]
 800127a:	f003 030c 	and.w	r3, r3, #12
 800127e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001282:	d0a4      	beq.n	80011ce <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001284:	f7ff f996 	bl	80005b4 <HAL_GetTick>
 8001288:	1bc0      	subs	r0, r0, r7
 800128a:	4540      	cmp	r0, r8
 800128c:	d9f3      	bls.n	8001276 <HAL_RCC_ClockConfig+0xce>
        return HAL_TIMEOUT;
 800128e:	2003      	movs	r0, #3
}
 8001290:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8001294:	1e91      	subs	r1, r2, #2
 8001296:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001298:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800129a:	d802      	bhi.n	80012a2 <HAL_RCC_ClockConfig+0xfa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800129c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80012a0:	e7dd      	b.n	800125e <HAL_RCC_ClockConfig+0xb6>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80012a2:	f013 0f02 	tst.w	r3, #2
 80012a6:	e7da      	b.n	800125e <HAL_RCC_ClockConfig+0xb6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80012a8:	b2ea      	uxtb	r2, r5
 80012aa:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80012ac:	681b      	ldr	r3, [r3, #0]
 80012ae:	f003 030f 	and.w	r3, r3, #15
 80012b2:	429d      	cmp	r5, r3
 80012b4:	f47f af7d 	bne.w	80011b2 <HAL_RCC_ClockConfig+0xa>
 80012b8:	e78f      	b.n	80011da <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80012ba:	4905      	ldr	r1, [pc, #20]	; (80012d0 <HAL_RCC_ClockConfig+0x128>)
 80012bc:	68e0      	ldr	r0, [r4, #12]
 80012be:	688b      	ldr	r3, [r1, #8]
 80012c0:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80012c4:	4303      	orrs	r3, r0
 80012c6:	608b      	str	r3, [r1, #8]
 80012c8:	e78a      	b.n	80011e0 <HAL_RCC_ClockConfig+0x38>
 80012ca:	bf00      	nop
 80012cc:	40023c00 	.word	0x40023c00
 80012d0:	40023800 	.word	0x40023800
 80012d4:	08006f70 	.word	0x08006f70
 80012d8:	20000010 	.word	0x20000010

080012dc <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 80012dc:	4b04      	ldr	r3, [pc, #16]	; (80012f0 <HAL_RCC_GetPCLK1Freq+0x14>)
 80012de:	4a05      	ldr	r2, [pc, #20]	; (80012f4 <HAL_RCC_GetPCLK1Freq+0x18>)
 80012e0:	689b      	ldr	r3, [r3, #8]
 80012e2:	f3c3 2382 	ubfx	r3, r3, #10, #3
 80012e6:	5cd3      	ldrb	r3, [r2, r3]
 80012e8:	4a03      	ldr	r2, [pc, #12]	; (80012f8 <HAL_RCC_GetPCLK1Freq+0x1c>)
 80012ea:	6810      	ldr	r0, [r2, #0]
}
 80012ec:	40d8      	lsrs	r0, r3
 80012ee:	4770      	bx	lr
 80012f0:	40023800 	.word	0x40023800
 80012f4:	08006f80 	.word	0x08006f80
 80012f8:	20000010 	.word	0x20000010

080012fc <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80012fc:	4b04      	ldr	r3, [pc, #16]	; (8001310 <HAL_RCC_GetPCLK2Freq+0x14>)
 80012fe:	4a05      	ldr	r2, [pc, #20]	; (8001314 <HAL_RCC_GetPCLK2Freq+0x18>)
 8001300:	689b      	ldr	r3, [r3, #8]
 8001302:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8001306:	5cd3      	ldrb	r3, [r2, r3]
 8001308:	4a03      	ldr	r2, [pc, #12]	; (8001318 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800130a:	6810      	ldr	r0, [r2, #0]
}
 800130c:	40d8      	lsrs	r0, r3
 800130e:	4770      	bx	lr
 8001310:	40023800 	.word	0x40023800
 8001314:	08006f80 	.word	0x08006f80
 8001318:	20000010 	.word	0x20000010

0800131c <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the peripheral clock selection parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------ I2S APB1 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == (RCC_PERIPHCLK_I2S_APB1))
 800131c:	6803      	ldr	r3, [r0, #0]
{
 800131e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == (RCC_PERIPHCLK_I2S_APB1))
 8001322:	f013 0601 	ands.w	r6, r3, #1
{
 8001326:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == (RCC_PERIPHCLK_I2S_APB1))
 8001328:	d00b      	beq.n	8001342 <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SAPB1CLKSOURCE(PeriphClkInit->I2sApb1ClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_APB1_CONFIG(PeriphClkInit->I2sApb1ClockSelection);
 800132a:	49aa      	ldr	r1, [pc, #680]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 800132c:	6b86      	ldr	r6, [r0, #56]	; 0x38
 800132e:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8001332:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
 8001336:	4332      	orrs	r2, r6
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)
 8001338:	fab6 f686 	clz	r6, r6
    __HAL_RCC_I2S_APB1_CONFIG(PeriphClkInit->I2sApb1ClockSelection);
 800133c:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)
 8001340:	0976      	lsrs	r6, r6, #5
    }
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- I2S APB2 configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == (RCC_PERIPHCLK_I2S_APB2))
 8001342:	079d      	lsls	r5, r3, #30
 8001344:	d50b      	bpl.n	800135e <HAL_RCCEx_PeriphCLKConfig+0x42>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SAPB2CLKSOURCE(PeriphClkInit->I2sApb2ClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_APB2_CONFIG(PeriphClkInit->I2sApb2ClockSelection);
 8001346:	48a3      	ldr	r0, [pc, #652]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001348:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800134a:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 800134e:	f022 52c0 	bic.w	r2, r2, #402653184	; 0x18000000
 8001352:	430a      	orrs	r2, r1
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)
    {
      plli2sused = 1U;
 8001354:	2900      	cmp	r1, #0
    __HAL_RCC_I2S_APB2_CONFIG(PeriphClkInit->I2sApb2ClockSelection);
 8001356:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
      plli2sused = 1U;
 800135a:	bf08      	it	eq
 800135c:	2601      	moveq	r6, #1
    }
  }
  /*--------------------------------------------------------------------------*/

  /*--------------------------- SAI1 configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 800135e:	f013 0504 	ands.w	r5, r3, #4
 8001362:	d012      	beq.n	800138a <HAL_RCCEx_PeriphCLKConfig+0x6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001364:	499b      	ldr	r1, [pc, #620]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001366:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8001368:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800136c:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001370:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001374:	ea42 0205 	orr.w	r2, r2, r5
    {
      plli2sused = 1U;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001378:	bf18      	it	ne
 800137a:	fab5 f585 	clzne	r5, r5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800137e:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001382:	bf12      	itee	ne
 8001384:	096d      	lsrne	r5, r5, #5
  uint32_t pllsaiused = 0U;
 8001386:	2500      	moveq	r5, #0
      plli2sused = 1U;
 8001388:	2601      	moveq	r6, #1
    }
  }
  /*--------------------------------------------------------------------------*/

  /*-------------------------- SAI2 configuration ----------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 800138a:	0718      	lsls	r0, r3, #28
 800138c:	d50f      	bpl.n	80013ae <HAL_RCCEx_PeriphCLKConfig+0x92>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800138e:	4891      	ldr	r0, [pc, #580]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001390:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8001392:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8001396:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800139a:	430a      	orrs	r2, r1

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 800139c:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 80013a0:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 80013a4:	f000 8109 	beq.w	80015ba <HAL_RCCEx_PeriphCLKConfig+0x29e>
      plli2sused = 1U;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1U;
 80013a8:	2900      	cmp	r1, #0
 80013aa:	bf08      	it	eq
 80013ac:	2501      	moveq	r5, #1
    }
  }
  /*--------------------------------------------------------------------------*/

  /*----------------------------- RTC configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80013ae:	0699      	lsls	r1, r3, #26
 80013b0:	d533      	bpl.n	800141a <HAL_RCCEx_PeriphCLKConfig+0xfe>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80013b2:	2300      	movs	r3, #0
 80013b4:	9301      	str	r3, [sp, #4]
 80013b6:	4b87      	ldr	r3, [pc, #540]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80013b8:	4f87      	ldr	r7, [pc, #540]	; (80015d8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
    __HAL_RCC_PWR_CLK_ENABLE();
 80013ba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013bc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80013c0:	641a      	str	r2, [r3, #64]	; 0x40
 80013c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80013c4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80013c8:	9301      	str	r3, [sp, #4]
 80013ca:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 80013cc:	683b      	ldr	r3, [r7, #0]
 80013ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80013d2:	603b      	str	r3, [r7, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 80013d4:	f7ff f8ee 	bl	80005b4 <HAL_GetTick>
 80013d8:	4680      	mov	r8, r0

    while((PWR->CR & PWR_CR_DBP) == RESET)
 80013da:	683b      	ldr	r3, [r7, #0]
 80013dc:	05da      	lsls	r2, r3, #23
 80013de:	f140 80ee 	bpl.w	80015be <HAL_RCCEx_PeriphCLKConfig+0x2a2>
      {
        return HAL_TIMEOUT;
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80013e2:	4f7c      	ldr	r7, [pc, #496]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 80013e4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80013e6:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80013ea:	f040 80fb 	bne.w	80015e4 <HAL_RCCEx_PeriphCLKConfig+0x2c8>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80013ee:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80013f0:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80013f4:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80013f8:	4a76      	ldr	r2, [pc, #472]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 80013fa:	f040 8116 	bne.w	800162a <HAL_RCCEx_PeriphCLKConfig+0x30e>
 80013fe:	6891      	ldr	r1, [r2, #8]
 8001400:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
 8001404:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8001408:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 800140c:	4301      	orrs	r1, r0
 800140e:	6091      	str	r1, [r2, #8]
 8001410:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8001412:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8001416:	430b      	orrs	r3, r1
 8001418:	6713      	str	r3, [r2, #112]	; 0x70
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800141a:	6823      	ldr	r3, [r4, #0]
 800141c:	06d9      	lsls	r1, r3, #27
  {
    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800141e:	bf42      	ittt	mi
 8001420:	4b6e      	ldrmi	r3, [pc, #440]	; (80015dc <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8001422:	f894 2058 	ldrbmi.w	r2, [r4, #88]	; 0x58
 8001426:	601a      	strmi	r2, [r3, #0]
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- FMPI2C1 Configuration -----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMPI2C1) == RCC_PERIPHCLK_FMPI2C1)
 8001428:	6823      	ldr	r3, [r4, #0]
 800142a:	061a      	lsls	r2, r3, #24
 800142c:	d508      	bpl.n	8001440 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMPI2C1CLKSOURCE(PeriphClkInit->Fmpi2c1ClockSelection));

    /* Configure the FMPI2C1 clock source */
    __HAL_RCC_FMPI2C1_CONFIG(PeriphClkInit->Fmpi2c1ClockSelection);
 800142e:	4969      	ldr	r1, [pc, #420]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001430:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8001432:	f8d1 2094 	ldr.w	r2, [r1, #148]	; 0x94
 8001436:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800143a:	4302      	orrs	r2, r0
 800143c:	f8c1 2094 	str.w	r2, [r1, #148]	; 0x94
  }
  /*--------------------------------------------------------------------------*/

  /*------------------------------ CEC Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8001440:	065f      	lsls	r7, r3, #25
 8001442:	d508      	bpl.n	8001456 <HAL_RCCEx_PeriphCLKConfig+0x13a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8001444:	4963      	ldr	r1, [pc, #396]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001446:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8001448:	f8d1 2094 	ldr.w	r2, [r1, #148]	; 0x94
 800144c:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001450:	4302      	orrs	r2, r0
 8001452:	f8c1 2094 	str.w	r2, [r1, #148]	; 0x94
  }
  /*--------------------------------------------------------------------------*/

  /*----------------------------- CLK48 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8001456:	05d8      	lsls	r0, r3, #23
 8001458:	d50c      	bpl.n	8001474 <HAL_RCCEx_PeriphCLKConfig+0x158>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48CLKSOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 clock source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800145a:	485e      	ldr	r0, [pc, #376]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 800145c:	6d61      	ldr	r1, [r4, #84]	; 0x54
 800145e:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 8001462:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
 8001466:	430a      	orrs	r2, r1

    /* Enable the PLLSAI when it's used as clock source for CLK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP)
    {
      pllsaiused = 1U;
 8001468:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800146c:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
      pllsaiused = 1U;
 8001470:	bf08      	it	eq
 8001472:	2501      	moveq	r5, #1
    }
  }
  /*--------------------------------------------------------------------------*/

  /*----------------------------- SDIO Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDIO) == RCC_PERIPHCLK_SDIO)
 8001474:	0599      	lsls	r1, r3, #22
 8001476:	d508      	bpl.n	800148a <HAL_RCCEx_PeriphCLKConfig+0x16e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDIOCLKSOURCE(PeriphClkInit->SdioClockSelection));

    /* Configure the SDIO clock source */
    __HAL_RCC_SDIO_CONFIG(PeriphClkInit->SdioClockSelection);
 8001478:	4956      	ldr	r1, [pc, #344]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 800147a:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800147c:	f8d1 2094 	ldr.w	r2, [r1, #148]	; 0x94
 8001480:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8001484:	4302      	orrs	r2, r0
 8001486:	f8c1 2094 	str.w	r2, [r1, #148]	; 0x94
  }
  /*--------------------------------------------------------------------------*/

  /*------------------------------ SPDIFRX Configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800148a:	055a      	lsls	r2, r3, #21
 800148c:	f100 80d1 	bmi.w	8001632 <HAL_RCCEx_PeriphCLKConfig+0x316>
  /*--------------------------------------------------------------------------*/

  /*---------------------------- PLLI2S Configuration ------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S on APB1,
     I2S on APB2 or SPDIFRX */
  if((plli2sused == 1U) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8001490:	2e01      	cmp	r6, #1
 8001492:	f040 80dc 	bne.w	800164e <HAL_RCCEx_PeriphCLKConfig+0x332>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8001496:	4e52      	ldr	r6, [pc, #328]	; (80015e0 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001498:	4f4e      	ldr	r7, [pc, #312]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
    __HAL_RCC_PLLI2S_DISABLE();
 800149a:	2300      	movs	r3, #0
 800149c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 800149e:	f7ff f889 	bl	80005b4 <HAL_GetTick>
 80014a2:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80014a4:	683b      	ldr	r3, [r7, #0]
 80014a6:	011b      	lsls	r3, r3, #4
 80014a8:	f100 8125 	bmi.w	80016f6 <HAL_RCCEx_PeriphCLKConfig+0x3da>
    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*------ In Case of PLLI2S is selected as source clock for I2S -----------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == RCC_PERIPHCLK_I2S_APB1) && (PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)) ||
 80014ac:	6822      	ldr	r2, [r4, #0]
 80014ae:	07d0      	lsls	r0, r2, #31
 80014b0:	d501      	bpl.n	80014b6 <HAL_RCCEx_PeriphCLKConfig+0x19a>
 80014b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80014b4:	b11b      	cbz	r3, 80014be <HAL_RCCEx_PeriphCLKConfig+0x1a2>
 80014b6:	0791      	lsls	r1, r2, #30
 80014b8:	d515      	bpl.n	80014e6 <HAL_RCCEx_PeriphCLKConfig+0x1ca>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == RCC_PERIPHCLK_I2S_APB2) && (PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)))
 80014ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80014bc:	b99b      	cbnz	r3, 80014e6 <HAL_RCCEx_PeriphCLKConfig+0x1ca>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP/PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      plli2sp = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);
 80014be:	4945      	ldr	r1, [pc, #276]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 80014c0:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      plli2sq = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 80014c4:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , plli2sp, plli2sq, PeriphClkInit->PLLI2S.PLLI2SR);
 80014c8:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80014cc:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
 80014d0:	4303      	orrs	r3, r0
 80014d2:	6860      	ldr	r0, [r4, #4]
 80014d4:	4303      	orrs	r3, r0
 80014d6:	68a0      	ldr	r0, [r4, #8]
 80014d8:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 80014dc:	6960      	ldr	r0, [r4, #20]
 80014de:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 80014e2:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*------- In Case of PLLI2S is selected as source clock for SAI ----------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 80014e6:	0753      	lsls	r3, r2, #29
 80014e8:	d503      	bpl.n	80014f2 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
 80014ea:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80014ec:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80014f0:	d005      	beq.n	80014fe <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 80014f2:	0717      	lsls	r7, r2, #28
 80014f4:	d520      	bpl.n	8001538 <HAL_RCCEx_PeriphCLKConfig+0x21c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 80014f6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80014f8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80014fc:	d11c      	bne.n	8001538 <HAL_RCCEx_PeriphCLKConfig+0x21c>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP/PLLI2SR value from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      plli2sp = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);
 80014fe:	4935      	ldr	r1, [pc, #212]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001500:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      plli2sr = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8001504:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , plli2sp, PeriphClkInit->PLLI2S.PLLI2SQ, plli2sr);
 8001508:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800150c:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8001510:	4303      	orrs	r3, r0
 8001512:	6860      	ldr	r0, [r4, #4]
 8001514:	4303      	orrs	r3, r0
 8001516:	68a0      	ldr	r0, [r4, #8]
 8001518:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 800151c:	6920      	ldr	r0, [r4, #16]
 800151e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8001522:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8001526:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
 800152a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800152c:	f020 001f 	bic.w	r0, r0, #31
 8001530:	3b01      	subs	r3, #1
 8001532:	4303      	orrs	r3, r0
 8001534:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*------ In Case of PLLI2S is selected as source clock for SPDIFRX -------*/
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX) && (PeriphClkInit->SpdifClockSelection == RCC_SPDIFRXCLKSOURCE_PLLI2SP))
 8001538:	0550      	lsls	r0, r2, #21
 800153a:	d51b      	bpl.n	8001574 <HAL_RCCEx_PeriphCLKConfig+0x258>
 800153c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800153e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8001542:	d117      	bne.n	8001574 <HAL_RCCEx_PeriphCLKConfig+0x258>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */
      plli2sq = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);
 8001544:	4823      	ldr	r0, [pc, #140]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
      plli2sr = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, plli2sq, plli2sr);
 8001546:	6867      	ldr	r7, [r4, #4]
      plli2sq = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);
 8001548:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
      plli2sr = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800154c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, plli2sq, plli2sr);
 8001550:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
 8001554:	433b      	orrs	r3, r7
 8001556:	68a7      	ldr	r7, [r4, #8]
      plli2sq = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);
 8001558:	f3c1 4101 	ubfx	r1, r1, #16, #2
 800155c:	3101      	adds	r1, #1
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, plli2sq, plli2sr);
 800155e:	ea43 1387 	orr.w	r3, r3, r7, lsl #6
 8001562:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
 8001566:	68e1      	ldr	r1, [r4, #12]
 8001568:	0849      	lsrs	r1, r1, #1
 800156a:	3901      	subs	r1, #1
 800156c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001570:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    }

     /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8001574:	0511      	lsls	r1, r2, #20
 8001576:	d511      	bpl.n	800159c <HAL_RCCEx_PeriphCLKConfig+0x280>
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8001578:	6923      	ldr	r3, [r4, #16]
 800157a:	68a2      	ldr	r2, [r4, #8]
 800157c:	061b      	lsls	r3, r3, #24
 800157e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001582:	6862      	ldr	r2, [r4, #4]
 8001584:	4313      	orrs	r3, r2
 8001586:	6962      	ldr	r2, [r4, #20]
 8001588:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 800158c:	68e2      	ldr	r2, [r4, #12]
 800158e:	0852      	lsrs	r2, r2, #1
 8001590:	3a01      	subs	r2, #1
 8001592:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001596:	4a0f      	ldr	r2, [pc, #60]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
 8001598:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 800159c:	2301      	movs	r3, #1
 800159e:	6033      	str	r3, [r6, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80015a0:	f7ff f808 	bl	80005b4 <HAL_GetTick>
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80015a4:	4e0b      	ldr	r6, [pc, #44]	; (80015d4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
    tickstart = HAL_GetTick();
 80015a6:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80015a8:	6833      	ldr	r3, [r6, #0]
 80015aa:	011a      	lsls	r2, r3, #4
 80015ac:	d453      	bmi.n	8001656 <HAL_RCCEx_PeriphCLKConfig+0x33a>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80015ae:	f7ff f801 	bl	80005b4 <HAL_GetTick>
 80015b2:	1bc0      	subs	r0, r0, r7
 80015b4:	2802      	cmp	r0, #2
 80015b6:	d9f7      	bls.n	80015a8 <HAL_RCCEx_PeriphCLKConfig+0x28c>
 80015b8:	e008      	b.n	80015cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
      plli2sused = 1U;
 80015ba:	2601      	movs	r6, #1
 80015bc:	e6f7      	b.n	80013ae <HAL_RCCEx_PeriphCLKConfig+0x92>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80015be:	f7fe fff9 	bl	80005b4 <HAL_GetTick>
 80015c2:	eba0 0008 	sub.w	r0, r0, r8
 80015c6:	2802      	cmp	r0, #2
 80015c8:	f67f af07 	bls.w	80013da <HAL_RCCEx_PeriphCLKConfig+0xbe>
        return HAL_TIMEOUT;
 80015cc:	2003      	movs	r0, #3
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
}
 80015ce:	b003      	add	sp, #12
 80015d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80015d4:	40023800 	.word	0x40023800
 80015d8:	40007000 	.word	0x40007000
 80015dc:	424711e0 	.word	0x424711e0
 80015e0:	42470068 	.word	0x42470068
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80015e4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80015e6:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80015ea:	4293      	cmp	r3, r2
 80015ec:	f43f aeff 	beq.w	80013ee <HAL_RCCEx_PeriphCLKConfig+0xd2>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80015f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 80015f2:	4a4b      	ldr	r2, [pc, #300]	; (8001720 <HAL_RCCEx_PeriphCLKConfig+0x404>)
 80015f4:	2101      	movs	r1, #1
 80015f6:	6011      	str	r1, [r2, #0]
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80015f8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_RELEASE();
 80015fc:	2100      	movs	r1, #0
 80015fe:	6011      	str	r1, [r2, #0]
      RCC->BDCR = tmpreg1;
 8001600:	673b      	str	r3, [r7, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8001602:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001604:	07db      	lsls	r3, r3, #31
 8001606:	f57f aef2 	bpl.w	80013ee <HAL_RCCEx_PeriphCLKConfig+0xd2>
        tickstart = HAL_GetTick();
 800160a:	f7fe ffd3 	bl	80005b4 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800160e:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8001612:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001614:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001616:	0798      	lsls	r0, r3, #30
 8001618:	f53f aee9 	bmi.w	80013ee <HAL_RCCEx_PeriphCLKConfig+0xd2>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800161c:	f7fe ffca 	bl	80005b4 <HAL_GetTick>
 8001620:	eba0 0008 	sub.w	r0, r0, r8
 8001624:	4548      	cmp	r0, r9
 8001626:	d9f5      	bls.n	8001614 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
 8001628:	e7d0      	b.n	80015cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800162a:	6891      	ldr	r1, [r2, #8]
 800162c:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8001630:	e6ed      	b.n	800140e <HAL_RCCEx_PeriphCLKConfig+0xf2>
    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifClockSelection);
 8001632:	483c      	ldr	r0, [pc, #240]	; (8001724 <HAL_RCCEx_PeriphCLKConfig+0x408>)
 8001634:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001636:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 800163a:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 800163e:	430a      	orrs	r2, r1
    if(PeriphClkInit->SpdifClockSelection == RCC_SPDIFRXCLKSOURCE_PLLI2SP)
 8001640:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifClockSelection);
 8001644:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
    if(PeriphClkInit->SpdifClockSelection == RCC_SPDIFRXCLKSOURCE_PLLI2SP)
 8001648:	f47f af22 	bne.w	8001490 <HAL_RCCEx_PeriphCLKConfig+0x174>
 800164c:	e723      	b.n	8001496 <HAL_RCCEx_PeriphCLKConfig+0x17a>
  if((plli2sused == 1U) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 800164e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8001652:	f43f af20 	beq.w	8001496 <HAL_RCCEx_PeriphCLKConfig+0x17a>
  if(pllsaiused == 1U)
 8001656:	2d01      	cmp	r5, #1
 8001658:	d14b      	bne.n	80016f2 <HAL_RCCEx_PeriphCLKConfig+0x3d6>
    __HAL_RCC_PLLSAI_DISABLE();
 800165a:	4d33      	ldr	r5, [pc, #204]	; (8001728 <HAL_RCCEx_PeriphCLKConfig+0x40c>)
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800165c:	4e31      	ldr	r6, [pc, #196]	; (8001724 <HAL_RCCEx_PeriphCLKConfig+0x408>)
    __HAL_RCC_PLLSAI_DISABLE();
 800165e:	2300      	movs	r3, #0
 8001660:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8001662:	f7fe ffa7 	bl	80005b4 <HAL_GetTick>
 8001666:	4607      	mov	r7, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8001668:	6833      	ldr	r3, [r6, #0]
 800166a:	009b      	lsls	r3, r3, #2
 800166c:	d44b      	bmi.n	8001706 <HAL_RCCEx_PeriphCLKConfig+0x3ea>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||
 800166e:	6821      	ldr	r1, [r4, #0]
 8001670:	074e      	lsls	r6, r1, #29
 8001672:	d501      	bpl.n	8001678 <HAL_RCCEx_PeriphCLKConfig+0x35c>
 8001674:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001676:	b11b      	cbz	r3, 8001680 <HAL_RCCEx_PeriphCLKConfig+0x364>
 8001678:	0708      	lsls	r0, r1, #28
 800167a:	d51a      	bpl.n	80016b2 <HAL_RCCEx_PeriphCLKConfig+0x396>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800167c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800167e:	b9c3      	cbnz	r3, 80016b2 <HAL_RCCEx_PeriphCLKConfig+0x396>
      pllsaip = ((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);
 8001680:	4a28      	ldr	r2, [pc, #160]	; (8001724 <HAL_RCCEx_PeriphCLKConfig+0x408>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , pllsaip, PeriphClkInit->PLLSAI.PLLSAIQ, 0U);
 8001682:	69a0      	ldr	r0, [r4, #24]
      pllsaip = ((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);
 8001684:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , pllsaip, PeriphClkInit->PLLSAI.PLLSAIQ, 0U);
 8001688:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800168c:	4303      	orrs	r3, r0
 800168e:	69e0      	ldr	r0, [r4, #28]
 8001690:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8001694:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001696:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800169a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800169e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80016a2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80016a4:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 80016a8:	3801      	subs	r0, #1
 80016aa:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80016ae:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP))
 80016b2:	05ca      	lsls	r2, r1, #23
 80016b4:	d514      	bpl.n	80016e0 <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 80016b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80016b8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80016bc:	d110      	bne.n	80016e0 <HAL_RCCEx_PeriphCLKConfig+0x3c4>
      pllsaiq = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80016be:	4919      	ldr	r1, [pc, #100]	; (8001724 <HAL_RCCEx_PeriphCLKConfig+0x408>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, pllsaiq, 0U);
 80016c0:	69a2      	ldr	r2, [r4, #24]
      pllsaiq = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80016c2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, pllsaiq, 0U);
 80016c6:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 80016ca:	4313      	orrs	r3, r2
 80016cc:	69e2      	ldr	r2, [r4, #28]
 80016ce:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80016d2:	6a22      	ldr	r2, [r4, #32]
 80016d4:	0852      	lsrs	r2, r2, #1
 80016d6:	3a01      	subs	r2, #1
 80016d8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80016dc:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    __HAL_RCC_PLLSAI_ENABLE();
 80016e0:	2301      	movs	r3, #1
 80016e2:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 80016e4:	f7fe ff66 	bl	80005b4 <HAL_GetTick>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80016e8:	4c0e      	ldr	r4, [pc, #56]	; (8001724 <HAL_RCCEx_PeriphCLKConfig+0x408>)
    tickstart = HAL_GetTick();
 80016ea:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80016ec:	6823      	ldr	r3, [r4, #0]
 80016ee:	009b      	lsls	r3, r3, #2
 80016f0:	d50f      	bpl.n	8001712 <HAL_RCCEx_PeriphCLKConfig+0x3f6>
  return HAL_OK;
 80016f2:	2000      	movs	r0, #0
 80016f4:	e76b      	b.n	80015ce <HAL_RCCEx_PeriphCLKConfig+0x2b2>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80016f6:	f7fe ff5d 	bl	80005b4 <HAL_GetTick>
 80016fa:	eba0 0008 	sub.w	r0, r0, r8
 80016fe:	2802      	cmp	r0, #2
 8001700:	f67f aed0 	bls.w	80014a4 <HAL_RCCEx_PeriphCLKConfig+0x188>
 8001704:	e762      	b.n	80015cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 8001706:	f7fe ff55 	bl	80005b4 <HAL_GetTick>
 800170a:	1bc0      	subs	r0, r0, r7
 800170c:	2802      	cmp	r0, #2
 800170e:	d9ab      	bls.n	8001668 <HAL_RCCEx_PeriphCLKConfig+0x34c>
 8001710:	e75c      	b.n	80015cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 8001712:	f7fe ff4f 	bl	80005b4 <HAL_GetTick>
 8001716:	1b40      	subs	r0, r0, r5
 8001718:	2802      	cmp	r0, #2
 800171a:	d9e7      	bls.n	80016ec <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 800171c:	e756      	b.n	80015cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 800171e:	bf00      	nop
 8001720:	42470e40 	.word	0x42470e40
 8001724:	40023800 	.word	0x40023800
 8001728:	42470070 	.word	0x42470070

0800172c <HAL_RCC_GetSysClockFreq>:
  uint32_t pllp = 0U;
  uint32_t pllr = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800172c:	4920      	ldr	r1, [pc, #128]	; (80017b0 <HAL_RCC_GetSysClockFreq+0x84>)
{
 800172e:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001730:	688b      	ldr	r3, [r1, #8]
 8001732:	f003 030c 	and.w	r3, r3, #12
 8001736:	2b08      	cmp	r3, #8
 8001738:	d007      	beq.n	800174a <HAL_RCC_GetSysClockFreq+0x1e>
 800173a:	2b0c      	cmp	r3, #12
 800173c:	d020      	beq.n	8001780 <HAL_RCC_GetSysClockFreq+0x54>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800173e:	4a1d      	ldr	r2, [pc, #116]	; (80017b4 <HAL_RCC_GetSysClockFreq+0x88>)
 8001740:	481d      	ldr	r0, [pc, #116]	; (80017b8 <HAL_RCC_GetSysClockFreq+0x8c>)
 8001742:	2b04      	cmp	r3, #4
 8001744:	bf18      	it	ne
 8001746:	4610      	movne	r0, r2
 8001748:	bd08      	pop	{r3, pc}
    }
    case RCC_CFGR_SWS_PLL:  /* PLL/PLLP used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800174a:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800174c:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800174e:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001750:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001754:	bf14      	ite	ne
 8001756:	4818      	ldrne	r0, [pc, #96]	; (80017b8 <HAL_RCC_GetSysClockFreq+0x8c>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001758:	4816      	ldreq	r0, [pc, #88]	; (80017b4 <HAL_RCC_GetSysClockFreq+0x88>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800175a:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800175e:	bf18      	it	ne
 8001760:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001762:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001766:	fba1 0100 	umull	r0, r1, r1, r0
 800176a:	f7fe fd51 	bl	8000210 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800176e:	4b10      	ldr	r3, [pc, #64]	; (80017b0 <HAL_RCC_GetSysClockFreq+0x84>)
 8001770:	685b      	ldr	r3, [r3, #4]
 8001772:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8001776:	3301      	adds	r3, #1
 8001778:	005b      	lsls	r3, r3, #1
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllr = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos);

      sysclockfreq = pllvco/pllr;
 800177a:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800177e:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001780:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001782:	684b      	ldr	r3, [r1, #4]
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001784:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001786:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800178a:	bf14      	ite	ne
 800178c:	480a      	ldrne	r0, [pc, #40]	; (80017b8 <HAL_RCC_GetSysClockFreq+0x8c>)
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800178e:	4809      	ldreq	r0, [pc, #36]	; (80017b4 <HAL_RCC_GetSysClockFreq+0x88>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001790:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8001794:	bf18      	it	ne
 8001796:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001798:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800179c:	fba1 0100 	umull	r0, r1, r1, r0
 80017a0:	f7fe fd36 	bl	8000210 <__aeabi_uldivmod>
      pllr = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos);
 80017a4:	4b02      	ldr	r3, [pc, #8]	; (80017b0 <HAL_RCC_GetSysClockFreq+0x84>)
 80017a6:	685b      	ldr	r3, [r3, #4]
 80017a8:	f3c3 7302 	ubfx	r3, r3, #28, #3
 80017ac:	e7e5      	b.n	800177a <HAL_RCC_GetSysClockFreq+0x4e>
 80017ae:	bf00      	nop
 80017b0:	40023800 	.word	0x40023800
 80017b4:	00f42400 	.word	0x00f42400
 80017b8:	007a1200 	.word	0x007a1200

080017bc <HAL_RCC_OscConfig>:
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017bc:	6803      	ldr	r3, [r0, #0]
{
 80017be:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017c2:	07df      	lsls	r7, r3, #31
{
 80017c4:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017c6:	d410      	bmi.n	80017ea <HAL_RCC_OscConfig+0x2e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80017c8:	6823      	ldr	r3, [r4, #0]
 80017ca:	079e      	lsls	r6, r3, #30
 80017cc:	d467      	bmi.n	800189e <HAL_RCC_OscConfig+0xe2>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80017ce:	6823      	ldr	r3, [r4, #0]
 80017d0:	071a      	lsls	r2, r3, #28
 80017d2:	f100 80b2 	bmi.w	800193a <HAL_RCC_OscConfig+0x17e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80017d6:	6823      	ldr	r3, [r4, #0]
 80017d8:	075b      	lsls	r3, r3, #29
 80017da:	f100 80d0 	bmi.w	800197e <HAL_RCC_OscConfig+0x1c2>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80017de:	69a2      	ldr	r2, [r4, #24]
 80017e0:	2a00      	cmp	r2, #0
 80017e2:	f040 8139 	bne.w	8001a58 <HAL_RCC_OscConfig+0x29c>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80017e6:	2000      	movs	r0, #0
 80017e8:	e01e      	b.n	8001828 <HAL_RCC_OscConfig+0x6c>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 80017ea:	4b97      	ldr	r3, [pc, #604]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80017ec:	689a      	ldr	r2, [r3, #8]
 80017ee:	f002 020c 	and.w	r2, r2, #12
 80017f2:	2a04      	cmp	r2, #4
 80017f4:	d010      	beq.n	8001818 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 80017f6:	689a      	ldr	r2, [r3, #8]
 80017f8:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 80017fc:	2a08      	cmp	r2, #8
 80017fe:	d102      	bne.n	8001806 <HAL_RCC_OscConfig+0x4a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 8001800:	685b      	ldr	r3, [r3, #4]
 8001802:	025d      	lsls	r5, r3, #9
 8001804:	d408      	bmi.n	8001818 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001806:	4b90      	ldr	r3, [pc, #576]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 8001808:	689a      	ldr	r2, [r3, #8]
 800180a:	f002 020c 	and.w	r2, r2, #12
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 800180e:	2a0c      	cmp	r2, #12
 8001810:	d10d      	bne.n	800182e <HAL_RCC_OscConfig+0x72>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001812:	685a      	ldr	r2, [r3, #4]
 8001814:	0250      	lsls	r0, r2, #9
 8001816:	d50a      	bpl.n	800182e <HAL_RCC_OscConfig+0x72>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001818:	4b8b      	ldr	r3, [pc, #556]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 800181a:	681b      	ldr	r3, [r3, #0]
 800181c:	0399      	lsls	r1, r3, #14
 800181e:	d5d3      	bpl.n	80017c8 <HAL_RCC_OscConfig+0xc>
 8001820:	6863      	ldr	r3, [r4, #4]
 8001822:	2b00      	cmp	r3, #0
 8001824:	d1d0      	bne.n	80017c8 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 8001826:	2001      	movs	r0, #1
}
 8001828:	b002      	add	sp, #8
 800182a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800182e:	6862      	ldr	r2, [r4, #4]
 8001830:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8001834:	d111      	bne.n	800185a <HAL_RCC_OscConfig+0x9e>
 8001836:	681a      	ldr	r2, [r3, #0]
 8001838:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800183c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800183e:	f7fe feb9 	bl	80005b4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001842:	4d81      	ldr	r5, [pc, #516]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
 8001844:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001846:	682b      	ldr	r3, [r5, #0]
 8001848:	039a      	lsls	r2, r3, #14
 800184a:	d4bd      	bmi.n	80017c8 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800184c:	f7fe feb2 	bl	80005b4 <HAL_GetTick>
 8001850:	1b80      	subs	r0, r0, r6
 8001852:	2864      	cmp	r0, #100	; 0x64
 8001854:	d9f7      	bls.n	8001846 <HAL_RCC_OscConfig+0x8a>
            return HAL_TIMEOUT;
 8001856:	2003      	movs	r0, #3
 8001858:	e7e6      	b.n	8001828 <HAL_RCC_OscConfig+0x6c>
 800185a:	4d7b      	ldr	r5, [pc, #492]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800185c:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 8001860:	682b      	ldr	r3, [r5, #0]
 8001862:	d107      	bne.n	8001874 <HAL_RCC_OscConfig+0xb8>
 8001864:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001868:	602b      	str	r3, [r5, #0]
 800186a:	682b      	ldr	r3, [r5, #0]
 800186c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001870:	602b      	str	r3, [r5, #0]
 8001872:	e7e4      	b.n	800183e <HAL_RCC_OscConfig+0x82>
 8001874:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001878:	602b      	str	r3, [r5, #0]
 800187a:	682b      	ldr	r3, [r5, #0]
 800187c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001880:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001882:	2a00      	cmp	r2, #0
 8001884:	d1db      	bne.n	800183e <HAL_RCC_OscConfig+0x82>
        tickstart = HAL_GetTick();
 8001886:	f7fe fe95 	bl	80005b4 <HAL_GetTick>
 800188a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800188c:	682b      	ldr	r3, [r5, #0]
 800188e:	039b      	lsls	r3, r3, #14
 8001890:	d59a      	bpl.n	80017c8 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001892:	f7fe fe8f 	bl	80005b4 <HAL_GetTick>
 8001896:	1b80      	subs	r0, r0, r6
 8001898:	2864      	cmp	r0, #100	; 0x64
 800189a:	d9f7      	bls.n	800188c <HAL_RCC_OscConfig+0xd0>
 800189c:	e7db      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 800189e:	4b6a      	ldr	r3, [pc, #424]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80018a0:	689a      	ldr	r2, [r3, #8]
 80018a2:	f012 0f0c 	tst.w	r2, #12
 80018a6:	d010      	beq.n	80018ca <HAL_RCC_OscConfig+0x10e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 80018a8:	689a      	ldr	r2, [r3, #8]
 80018aa:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 80018ae:	2a08      	cmp	r2, #8
 80018b0:	d102      	bne.n	80018b8 <HAL_RCC_OscConfig+0xfc>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 80018b2:	685b      	ldr	r3, [r3, #4]
 80018b4:	025f      	lsls	r7, r3, #9
 80018b6:	d508      	bpl.n	80018ca <HAL_RCC_OscConfig+0x10e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80018b8:	4a63      	ldr	r2, [pc, #396]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80018ba:	6893      	ldr	r3, [r2, #8]
 80018bc:	f003 030c 	and.w	r3, r3, #12
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 80018c0:	2b0c      	cmp	r3, #12
 80018c2:	d111      	bne.n	80018e8 <HAL_RCC_OscConfig+0x12c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80018c4:	6853      	ldr	r3, [r2, #4]
 80018c6:	025e      	lsls	r6, r3, #9
 80018c8:	d40e      	bmi.n	80018e8 <HAL_RCC_OscConfig+0x12c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80018ca:	4b5f      	ldr	r3, [pc, #380]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80018cc:	681a      	ldr	r2, [r3, #0]
 80018ce:	0795      	lsls	r5, r2, #30
 80018d0:	d502      	bpl.n	80018d8 <HAL_RCC_OscConfig+0x11c>
 80018d2:	68e2      	ldr	r2, [r4, #12]
 80018d4:	2a01      	cmp	r2, #1
 80018d6:	d1a6      	bne.n	8001826 <HAL_RCC_OscConfig+0x6a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80018d8:	681a      	ldr	r2, [r3, #0]
 80018da:	6921      	ldr	r1, [r4, #16]
 80018dc:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80018e0:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80018e4:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80018e6:	e772      	b.n	80017ce <HAL_RCC_OscConfig+0x12>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80018e8:	68e2      	ldr	r2, [r4, #12]
 80018ea:	4b58      	ldr	r3, [pc, #352]	; (8001a4c <HAL_RCC_OscConfig+0x290>)
 80018ec:	b1b2      	cbz	r2, 800191c <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_HSI_ENABLE();
 80018ee:	2201      	movs	r2, #1
 80018f0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80018f2:	f7fe fe5f 	bl	80005b4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80018f6:	4d54      	ldr	r5, [pc, #336]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
 80018f8:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80018fa:	682b      	ldr	r3, [r5, #0]
 80018fc:	0798      	lsls	r0, r3, #30
 80018fe:	d507      	bpl.n	8001910 <HAL_RCC_OscConfig+0x154>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001900:	682b      	ldr	r3, [r5, #0]
 8001902:	6922      	ldr	r2, [r4, #16]
 8001904:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001908:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800190c:	602b      	str	r3, [r5, #0]
 800190e:	e75e      	b.n	80017ce <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001910:	f7fe fe50 	bl	80005b4 <HAL_GetTick>
 8001914:	1b80      	subs	r0, r0, r6
 8001916:	2802      	cmp	r0, #2
 8001918:	d9ef      	bls.n	80018fa <HAL_RCC_OscConfig+0x13e>
 800191a:	e79c      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
        __HAL_RCC_HSI_DISABLE();
 800191c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800191e:	f7fe fe49 	bl	80005b4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001922:	4d49      	ldr	r5, [pc, #292]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
 8001924:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001926:	682b      	ldr	r3, [r5, #0]
 8001928:	0799      	lsls	r1, r3, #30
 800192a:	f57f af50 	bpl.w	80017ce <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800192e:	f7fe fe41 	bl	80005b4 <HAL_GetTick>
 8001932:	1b80      	subs	r0, r0, r6
 8001934:	2802      	cmp	r0, #2
 8001936:	d9f6      	bls.n	8001926 <HAL_RCC_OscConfig+0x16a>
 8001938:	e78d      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800193a:	6962      	ldr	r2, [r4, #20]
 800193c:	4b44      	ldr	r3, [pc, #272]	; (8001a50 <HAL_RCC_OscConfig+0x294>)
 800193e:	b17a      	cbz	r2, 8001960 <HAL_RCC_OscConfig+0x1a4>
      __HAL_RCC_LSI_ENABLE();
 8001940:	2201      	movs	r2, #1
 8001942:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001944:	f7fe fe36 	bl	80005b4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001948:	4d3f      	ldr	r5, [pc, #252]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
 800194a:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800194c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800194e:	079f      	lsls	r7, r3, #30
 8001950:	f53f af41 	bmi.w	80017d6 <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001954:	f7fe fe2e 	bl	80005b4 <HAL_GetTick>
 8001958:	1b80      	subs	r0, r0, r6
 800195a:	2802      	cmp	r0, #2
 800195c:	d9f6      	bls.n	800194c <HAL_RCC_OscConfig+0x190>
 800195e:	e77a      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
      __HAL_RCC_LSI_DISABLE();
 8001960:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001962:	f7fe fe27 	bl	80005b4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001966:	4d38      	ldr	r5, [pc, #224]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
 8001968:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800196a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800196c:	0798      	lsls	r0, r3, #30
 800196e:	f57f af32 	bpl.w	80017d6 <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001972:	f7fe fe1f 	bl	80005b4 <HAL_GetTick>
 8001976:	1b80      	subs	r0, r0, r6
 8001978:	2802      	cmp	r0, #2
 800197a:	d9f6      	bls.n	800196a <HAL_RCC_OscConfig+0x1ae>
 800197c:	e76b      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800197e:	4b32      	ldr	r3, [pc, #200]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 8001980:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001982:	f012 5280 	ands.w	r2, r2, #268435456	; 0x10000000
 8001986:	d128      	bne.n	80019da <HAL_RCC_OscConfig+0x21e>
      __HAL_RCC_PWR_CLK_ENABLE();
 8001988:	9201      	str	r2, [sp, #4]
 800198a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800198c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001990:	641a      	str	r2, [r3, #64]	; 0x40
 8001992:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001994:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001998:	9301      	str	r3, [sp, #4]
 800199a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800199c:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800199e:	4d2d      	ldr	r5, [pc, #180]	; (8001a54 <HAL_RCC_OscConfig+0x298>)
 80019a0:	682b      	ldr	r3, [r5, #0]
 80019a2:	05d9      	lsls	r1, r3, #23
 80019a4:	d51b      	bpl.n	80019de <HAL_RCC_OscConfig+0x222>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80019a6:	68a3      	ldr	r3, [r4, #8]
 80019a8:	4d27      	ldr	r5, [pc, #156]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80019aa:	2b01      	cmp	r3, #1
 80019ac:	d127      	bne.n	80019fe <HAL_RCC_OscConfig+0x242>
 80019ae:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80019b0:	f043 0301 	orr.w	r3, r3, #1
 80019b4:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 80019b6:	f7fe fdfd 	bl	80005b4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019ba:	4d23      	ldr	r5, [pc, #140]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
 80019bc:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019be:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019c2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80019c4:	079b      	lsls	r3, r3, #30
 80019c6:	d539      	bpl.n	8001a3c <HAL_RCC_OscConfig+0x280>
    if(pwrclkchanged == SET)
 80019c8:	2e00      	cmp	r6, #0
 80019ca:	f43f af08 	beq.w	80017de <HAL_RCC_OscConfig+0x22>
      __HAL_RCC_PWR_CLK_DISABLE();
 80019ce:	4a1e      	ldr	r2, [pc, #120]	; (8001a48 <HAL_RCC_OscConfig+0x28c>)
 80019d0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80019d2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80019d6:	6413      	str	r3, [r2, #64]	; 0x40
 80019d8:	e701      	b.n	80017de <HAL_RCC_OscConfig+0x22>
    FlagStatus       pwrclkchanged = RESET;
 80019da:	2600      	movs	r6, #0
 80019dc:	e7df      	b.n	800199e <HAL_RCC_OscConfig+0x1e2>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80019de:	682b      	ldr	r3, [r5, #0]
 80019e0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80019e4:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 80019e6:	f7fe fde5 	bl	80005b4 <HAL_GetTick>
 80019ea:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80019ec:	682b      	ldr	r3, [r5, #0]
 80019ee:	05da      	lsls	r2, r3, #23
 80019f0:	d4d9      	bmi.n	80019a6 <HAL_RCC_OscConfig+0x1ea>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80019f2:	f7fe fddf 	bl	80005b4 <HAL_GetTick>
 80019f6:	1bc0      	subs	r0, r0, r7
 80019f8:	2802      	cmp	r0, #2
 80019fa:	d9f7      	bls.n	80019ec <HAL_RCC_OscConfig+0x230>
 80019fc:	e72b      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80019fe:	2b05      	cmp	r3, #5
 8001a00:	d104      	bne.n	8001a0c <HAL_RCC_OscConfig+0x250>
 8001a02:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001a04:	f043 0304 	orr.w	r3, r3, #4
 8001a08:	672b      	str	r3, [r5, #112]	; 0x70
 8001a0a:	e7d0      	b.n	80019ae <HAL_RCC_OscConfig+0x1f2>
 8001a0c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8001a0e:	f022 0201 	bic.w	r2, r2, #1
 8001a12:	672a      	str	r2, [r5, #112]	; 0x70
 8001a14:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8001a16:	f022 0204 	bic.w	r2, r2, #4
 8001a1a:	672a      	str	r2, [r5, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001a1c:	2b00      	cmp	r3, #0
 8001a1e:	d1ca      	bne.n	80019b6 <HAL_RCC_OscConfig+0x1fa>
      tickstart = HAL_GetTick();
 8001a20:	f7fe fdc8 	bl	80005b4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001a24:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8001a28:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001a2a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001a2c:	0798      	lsls	r0, r3, #30
 8001a2e:	d5cb      	bpl.n	80019c8 <HAL_RCC_OscConfig+0x20c>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001a30:	f7fe fdc0 	bl	80005b4 <HAL_GetTick>
 8001a34:	1bc0      	subs	r0, r0, r7
 8001a36:	4540      	cmp	r0, r8
 8001a38:	d9f7      	bls.n	8001a2a <HAL_RCC_OscConfig+0x26e>
 8001a3a:	e70c      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001a3c:	f7fe fdba 	bl	80005b4 <HAL_GetTick>
 8001a40:	1bc0      	subs	r0, r0, r7
 8001a42:	4540      	cmp	r0, r8
 8001a44:	d9bd      	bls.n	80019c2 <HAL_RCC_OscConfig+0x206>
 8001a46:	e706      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
 8001a48:	40023800 	.word	0x40023800
 8001a4c:	42470000 	.word	0x42470000
 8001a50:	42470e80 	.word	0x42470e80
 8001a54:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001a58:	4d23      	ldr	r5, [pc, #140]	; (8001ae8 <HAL_RCC_OscConfig+0x32c>)
 8001a5a:	68ab      	ldr	r3, [r5, #8]
 8001a5c:	f003 030c 	and.w	r3, r3, #12
 8001a60:	2b08      	cmp	r3, #8
 8001a62:	f43f aee0 	beq.w	8001826 <HAL_RCC_OscConfig+0x6a>
 8001a66:	4e21      	ldr	r6, [pc, #132]	; (8001aec <HAL_RCC_OscConfig+0x330>)
 8001a68:	2300      	movs	r3, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001a6a:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8001a6c:	6033      	str	r3, [r6, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001a6e:	d12d      	bne.n	8001acc <HAL_RCC_OscConfig+0x310>
        tickstart = HAL_GetTick();
 8001a70:	f7fe fda0 	bl	80005b4 <HAL_GetTick>
 8001a74:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001a76:	682b      	ldr	r3, [r5, #0]
 8001a78:	0199      	lsls	r1, r3, #6
 8001a7a:	d421      	bmi.n	8001ac0 <HAL_RCC_OscConfig+0x304>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001a7c:	6a22      	ldr	r2, [r4, #32]
 8001a7e:	69e3      	ldr	r3, [r4, #28]
 8001a80:	4313      	orrs	r3, r2
 8001a82:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001a84:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001a88:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a8a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001a8e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001a90:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8001a94:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001a96:	4c14      	ldr	r4, [pc, #80]	; (8001ae8 <HAL_RCC_OscConfig+0x32c>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001a98:	0852      	lsrs	r2, r2, #1
 8001a9a:	3a01      	subs	r2, #1
 8001a9c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001aa0:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8001aa2:	2301      	movs	r3, #1
 8001aa4:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8001aa6:	f7fe fd85 	bl	80005b4 <HAL_GetTick>
 8001aaa:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001aac:	6823      	ldr	r3, [r4, #0]
 8001aae:	019a      	lsls	r2, r3, #6
 8001ab0:	f53f ae99 	bmi.w	80017e6 <HAL_RCC_OscConfig+0x2a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001ab4:	f7fe fd7e 	bl	80005b4 <HAL_GetTick>
 8001ab8:	1b40      	subs	r0, r0, r5
 8001aba:	2802      	cmp	r0, #2
 8001abc:	d9f6      	bls.n	8001aac <HAL_RCC_OscConfig+0x2f0>
 8001abe:	e6ca      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001ac0:	f7fe fd78 	bl	80005b4 <HAL_GetTick>
 8001ac4:	1bc0      	subs	r0, r0, r7
 8001ac6:	2802      	cmp	r0, #2
 8001ac8:	d9d5      	bls.n	8001a76 <HAL_RCC_OscConfig+0x2ba>
 8001aca:	e6c4      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
        tickstart = HAL_GetTick();
 8001acc:	f7fe fd72 	bl	80005b4 <HAL_GetTick>
 8001ad0:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001ad2:	682b      	ldr	r3, [r5, #0]
 8001ad4:	019b      	lsls	r3, r3, #6
 8001ad6:	f57f ae86 	bpl.w	80017e6 <HAL_RCC_OscConfig+0x2a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001ada:	f7fe fd6b 	bl	80005b4 <HAL_GetTick>
 8001ade:	1b00      	subs	r0, r0, r4
 8001ae0:	2802      	cmp	r0, #2
 8001ae2:	d9f6      	bls.n	8001ad2 <HAL_RCC_OscConfig+0x316>
 8001ae4:	e6b7      	b.n	8001856 <HAL_RCC_OscConfig+0x9a>
 8001ae6:	bf00      	nop
 8001ae8:	40023800 	.word	0x40023800
 8001aec:	42470060 	.word	0x42470060

08001af0 <SD_DMATransmitCplt>:
static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
{
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  
  /* Enable DATAEND Interrupt */
  __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DATAEND));
 8001af0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001af2:	681a      	ldr	r2, [r3, #0]
 8001af4:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8001af6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001afa:	63d3      	str	r3, [r2, #60]	; 0x3c
 8001afc:	4770      	bx	lr

08001afe <SD_FindSCR>:
  * @param  hsd Pointer to SD handle
  * @param  pSCR pointer to the buffer that will contain the SCR value  
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8001afe:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001b02:	b089      	sub	sp, #36	; 0x24
 8001b04:	4605      	mov	r5, r0
 8001b06:	460e      	mov	r6, r1
  SDIO_DataInitTypeDef config;
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  uint32_t tickstart = HAL_GetTick();
 8001b08:	f7fe fd54 	bl	80005b4 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8001b0c:	2300      	movs	r3, #0
  uint32_t tickstart = HAL_GetTick();
 8001b0e:	4681      	mov	r9, r0
  
  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8001b10:	2108      	movs	r1, #8
 8001b12:	6828      	ldr	r0, [r5, #0]
  uint32_t tempscr[2U] = {0U, 0U};
 8001b14:	9300      	str	r3, [sp, #0]
 8001b16:	9301      	str	r3, [sp, #4]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8001b18:	f001 fcd7 	bl	80034ca <SDMMC_CmdBlockLength>
  if(errorstate != HAL_OK)
 8001b1c:	4604      	mov	r4, r0
 8001b1e:	bb40      	cbnz	r0, 8001b72 <SD_FindSCR+0x74>
  {
    return errorstate;
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8001b20:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8001b22:	6828      	ldr	r0, [r5, #0]
 8001b24:	0409      	lsls	r1, r1, #16
 8001b26:	f001 fddb 	bl	80036e0 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_OK)
 8001b2a:	4604      	mov	r4, r0
 8001b2c:	bb08      	cbnz	r0, 8001b72 <SD_FindSCR+0x74>
  {
    return errorstate;
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8001b2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001b32:	9302      	str	r3, [sp, #8]
  config.DataLength    = 8U;
 8001b34:	2308      	movs	r3, #8
 8001b36:	9303      	str	r3, [sp, #12]
  config.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 8001b38:	2330      	movs	r3, #48	; 0x30
 8001b3a:	9304      	str	r3, [sp, #16]
  config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8001b3c:	2302      	movs	r3, #2
 8001b3e:	9305      	str	r3, [sp, #20]
  config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001b40:	9006      	str	r0, [sp, #24]
  config.DPSM          = SDIO_DPSM_ENABLE;
 8001b42:	2301      	movs	r3, #1
  SDIO_ConfigData(hsd->Instance, &config);
 8001b44:	a902      	add	r1, sp, #8
 8001b46:	6828      	ldr	r0, [r5, #0]
  config.DPSM          = SDIO_DPSM_ENABLE;
 8001b48:	9307      	str	r3, [sp, #28]
  SDIO_ConfigData(hsd->Instance, &config);
 8001b4a:	f001 fcab 	bl	80034a4 <SDIO_ConfigData>
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8001b4e:	6828      	ldr	r0, [r5, #0]
 8001b50:	f001 fdf7 	bl	8003742 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_OK)
 8001b54:	4604      	mov	r4, r0
 8001b56:	b960      	cbnz	r0, 8001b72 <SD_FindSCR+0x74>
 8001b58:	4607      	mov	r7, r0
  {
    return errorstate;
  }
  
  while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
 8001b5a:	f240 482a 	movw	r8, #1066	; 0x42a
 8001b5e:	6828      	ldr	r0, [r5, #0]
 8001b60:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001b62:	ea13 0f08 	tst.w	r3, r8
  {
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8001b66:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
 8001b68:	d007      	beq.n	8001b7a <SD_FindSCR+0x7c>
    {
      return HAL_SD_ERROR_TIMEOUT;
    }
  }
  
  if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8001b6a:	0719      	lsls	r1, r3, #28
 8001b6c:	d518      	bpl.n	8001ba0 <SD_FindSCR+0xa2>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001b6e:	2408      	movs	r4, #8
    
    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8001b70:	6384      	str	r4, [r0, #56]	; 0x38
    *(pSCR) = ((tempscr[1U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1U] & SDMMC_8TO15BITS) << 8U) |\
      ((tempscr[1U] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1U] & SDMMC_24TO31BITS) >> 24U);
  }

  return HAL_SD_ERROR_NONE;
}
 8001b72:	4620      	mov	r0, r4
 8001b74:	b009      	add	sp, #36	; 0x24
 8001b76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8001b7a:	029b      	lsls	r3, r3, #10
 8001b7c:	d507      	bpl.n	8001b8e <SD_FindSCR+0x90>
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8001b7e:	f001 fbd3 	bl	8003328 <SDIO_ReadFIFO>
 8001b82:	ab08      	add	r3, sp, #32
 8001b84:	eb03 0387 	add.w	r3, r3, r7, lsl #2
      index++;
 8001b88:	3701      	adds	r7, #1
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8001b8a:	f843 0c20 	str.w	r0, [r3, #-32]
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8001b8e:	f7fe fd11 	bl	80005b4 <HAL_GetTick>
 8001b92:	eba0 0009 	sub.w	r0, r0, r9
 8001b96:	3001      	adds	r0, #1
 8001b98:	d1e1      	bne.n	8001b5e <SD_FindSCR+0x60>
      return HAL_SD_ERROR_TIMEOUT;
 8001b9a:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8001b9e:	e7e8      	b.n	8001b72 <SD_FindSCR+0x74>
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8001ba0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001ba2:	079a      	lsls	r2, r3, #30
 8001ba4:	d501      	bpl.n	8001baa <SD_FindSCR+0xac>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8001ba6:	2402      	movs	r4, #2
 8001ba8:	e7e2      	b.n	8001b70 <SD_FindSCR+0x72>
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8001baa:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001bac:	069b      	lsls	r3, r3, #26
 8001bae:	d501      	bpl.n	8001bb4 <SD_FindSCR+0xb6>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8001bb0:	2420      	movs	r4, #32
 8001bb2:	e7dd      	b.n	8001b70 <SD_FindSCR+0x72>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001bb4:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8001bb8:	6383      	str	r3, [r0, #56]	; 0x38
 8001bba:	9b00      	ldr	r3, [sp, #0]
 8001bbc:	ba1b      	rev	r3, r3
    *(pSCR + 1U) = ((tempscr[0U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0U] & SDMMC_8TO15BITS) << 8U) |\
 8001bbe:	6073      	str	r3, [r6, #4]
 8001bc0:	9b01      	ldr	r3, [sp, #4]
 8001bc2:	ba1b      	rev	r3, r3
    *(pSCR) = ((tempscr[1U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1U] & SDMMC_8TO15BITS) << 8U) |\
 8001bc4:	6033      	str	r3, [r6, #0]
  return HAL_SD_ERROR_NONE;
 8001bc6:	e7d4      	b.n	8001b72 <SD_FindSCR+0x74>

08001bc8 <HAL_SD_ReadBlocks_DMA>:
{
 8001bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001bcc:	4616      	mov	r6, r2
 8001bce:	b087      	sub	sp, #28
 8001bd0:	4605      	mov	r5, r0
 8001bd2:	4698      	mov	r8, r3
  if(NULL == pData)
 8001bd4:	460a      	mov	r2, r1
 8001bd6:	b939      	cbnz	r1, 8001be8 <HAL_SD_ReadBlocks_DMA+0x20>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8001bd8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001bda:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8001bde:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 8001be0:	2001      	movs	r0, #1
}
 8001be2:	b007      	add	sp, #28
 8001be4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if(hsd->State == HAL_SD_STATE_READY)
 8001be8:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8001bec:	b2c4      	uxtb	r4, r0
 8001bee:	2c01      	cmp	r4, #1
 8001bf0:	d168      	bne.n	8001cc4 <HAL_SD_ReadBlocks_DMA+0xfc>
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001bf2:	6def      	ldr	r7, [r5, #92]	; 0x5c
 8001bf4:	eb06 0008 	add.w	r0, r6, r8
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8001bf8:	2300      	movs	r3, #0
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001bfa:	42b8      	cmp	r0, r7
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8001bfc:	63ab      	str	r3, [r5, #56]	; 0x38
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001bfe:	d903      	bls.n	8001c08 <HAL_SD_ReadBlocks_DMA+0x40>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8001c00:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001c02:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8001c06:	e7ea      	b.n	8001bde <HAL_SD_ReadBlocks_DMA+0x16>
    hsd->Instance->DCTRL = 0U;
 8001c08:	682f      	ldr	r7, [r5, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 8001c0a:	2103      	movs	r1, #3
 8001c0c:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8001c10:	62fb      	str	r3, [r7, #44]	; 0x2c
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
 8001c12:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8001c14:	492c      	ldr	r1, [pc, #176]	; (8001cc8 <HAL_SD_ReadBlocks_DMA+0x100>)
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
 8001c16:	f440 7095 	orr.w	r0, r0, #298	; 0x12a
 8001c1a:	63f8      	str	r0, [r7, #60]	; 0x3c
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8001c1c:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
 8001c1e:	ea4f 2948 	mov.w	r9, r8, lsl #9
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8001c22:	63c1      	str	r1, [r0, #60]	; 0x3c
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 8001c24:	4929      	ldr	r1, [pc, #164]	; (8001ccc <HAL_SD_ReadBlocks_DMA+0x104>)
 8001c26:	64c1      	str	r1, [r0, #76]	; 0x4c
    hsd->hdmarx->XferAbortCallback = NULL;
 8001c28:	6503      	str	r3, [r0, #80]	; 0x50
    HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
 8001c2a:	f107 0180 	add.w	r1, r7, #128	; 0x80
 8001c2e:	ea4f 0399 	mov.w	r3, r9, lsr #2
 8001c32:	f7fe ffe5 	bl	8000c00 <HAL_DMA_Start_IT>
    __HAL_SD_DMA_ENABLE(hsd);
 8001c36:	4b26      	ldr	r3, [pc, #152]	; (8001cd0 <HAL_SD_ReadBlocks_DMA+0x108>)
    SDIO_ConfigData(hsd->Instance, &config);
 8001c38:	6828      	ldr	r0, [r5, #0]
    __HAL_SD_DMA_ENABLE(hsd);
 8001c3a:	601c      	str	r4, [r3, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8001c3c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8001c3e:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8001c40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8001c44:	e88d 0208 	stmia.w	sp, {r3, r9}
    config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8001c48:	f04f 0390 	mov.w	r3, #144	; 0x90
 8001c4c:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8001c4e:	f04f 0302 	mov.w	r3, #2
 8001c52:	9303      	str	r3, [sp, #12]
    SDIO_ConfigData(hsd->Instance, &config);
 8001c54:	4669      	mov	r1, sp
    config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001c56:	f04f 0300 	mov.w	r3, #0
    config.DPSM          = SDIO_DPSM_ENABLE;
 8001c5a:	f04f 0401 	mov.w	r4, #1
      BlockAdd *= 512U;
 8001c5e:	bf18      	it	ne
 8001c60:	0276      	lslne	r6, r6, #9
    config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001c62:	9304      	str	r3, [sp, #16]
    config.DPSM          = SDIO_DPSM_ENABLE;
 8001c64:	9405      	str	r4, [sp, #20]
    SDIO_ConfigData(hsd->Instance, &config);
 8001c66:	f001 fc1d 	bl	80034a4 <SDIO_ConfigData>
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8001c6a:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001c6e:	6828      	ldr	r0, [r5, #0]
 8001c70:	f001 fc2b 	bl	80034ca <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001c74:	b148      	cbz	r0, 8001c8a <HAL_SD_ReadBlocks_DMA+0xc2>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
 8001c76:	682b      	ldr	r3, [r5, #0]
 8001c78:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001c7c:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8001c7e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001c80:	4318      	orrs	r0, r3
 8001c82:	63a8      	str	r0, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8001c84:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
 8001c88:	e7aa      	b.n	8001be0 <HAL_SD_ReadBlocks_DMA+0x18>
    if(NumberOfBlocks > 1U)
 8001c8a:	f1b8 0f01 	cmp.w	r8, #1
 8001c8e:	d912      	bls.n	8001cb6 <HAL_SD_ReadBlocks_DMA+0xee>
      hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8001c90:	2382      	movs	r3, #130	; 0x82
 8001c92:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
 8001c94:	4631      	mov	r1, r6
 8001c96:	6828      	ldr	r0, [r5, #0]
 8001c98:	f001 fc47 	bl	800352a <SDMMC_CmdReadMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001c9c:	2800      	cmp	r0, #0
 8001c9e:	d0a0      	beq.n	8001be2 <HAL_SD_ReadBlocks_DMA+0x1a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
 8001ca0:	682b      	ldr	r3, [r5, #0]
 8001ca2:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001ca6:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8001ca8:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001caa:	4318      	orrs	r0, r3
 8001cac:	63a8      	str	r0, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8001cae:	2001      	movs	r0, #1
 8001cb0:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      return HAL_ERROR;
 8001cb4:	e795      	b.n	8001be2 <HAL_SD_ReadBlocks_DMA+0x1a>
      hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8001cb6:	2381      	movs	r3, #129	; 0x81
 8001cb8:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
 8001cba:	4631      	mov	r1, r6
 8001cbc:	6828      	ldr	r0, [r5, #0]
 8001cbe:	f001 fc1c 	bl	80034fa <SDMMC_CmdReadSingleBlock>
 8001cc2:	e7eb      	b.n	8001c9c <HAL_SD_ReadBlocks_DMA+0xd4>
    return HAL_BUSY;
 8001cc4:	2002      	movs	r0, #2
 8001cc6:	e78c      	b.n	8001be2 <HAL_SD_ReadBlocks_DMA+0x1a>
 8001cc8:	08001dd7 	.word	0x08001dd7
 8001ccc:	08002335 	.word	0x08002335
 8001cd0:	4225858c 	.word	0x4225858c

08001cd4 <HAL_SD_WriteBlocks_DMA>:
{
 8001cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001cd8:	4604      	mov	r4, r0
 8001cda:	b086      	sub	sp, #24
 8001cdc:	4615      	mov	r5, r2
 8001cde:	461e      	mov	r6, r3
  if(NULL == pData)
 8001ce0:	460f      	mov	r7, r1
 8001ce2:	b939      	cbnz	r1, 8001cf4 <HAL_SD_WriteBlocks_DMA+0x20>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8001ce4:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001ce6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8001cea:	6383      	str	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8001cec:	2001      	movs	r0, #1
}
 8001cee:	b006      	add	sp, #24
 8001cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(hsd->State == HAL_SD_STATE_READY)
 8001cf4:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8001cf8:	b2c0      	uxtb	r0, r0
 8001cfa:	2801      	cmp	r0, #1
 8001cfc:	d162      	bne.n	8001dc4 <HAL_SD_WriteBlocks_DMA+0xf0>
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001cfe:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8001d00:	18eb      	adds	r3, r5, r3
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8001d02:	2200      	movs	r2, #0
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001d04:	428b      	cmp	r3, r1
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8001d06:	63a2      	str	r2, [r4, #56]	; 0x38
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8001d08:	d904      	bls.n	8001d14 <HAL_SD_WriteBlocks_DMA+0x40>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8001d0a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001d0c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8001d10:	63a3      	str	r3, [r4, #56]	; 0x38
      return HAL_ERROR;
 8001d12:	e7ec      	b.n	8001cee <HAL_SD_WriteBlocks_DMA+0x1a>
    hsd->Instance->DCTRL = 0U;
 8001d14:	6820      	ldr	r0, [r4, #0]
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8001d16:	492c      	ldr	r1, [pc, #176]	; (8001dc8 <HAL_SD_WriteBlocks_DMA+0xf4>)
    hsd->State = HAL_SD_STATE_BUSY;
 8001d18:	2303      	movs	r3, #3
 8001d1a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8001d1e:	62c2      	str	r2, [r0, #44]	; 0x2c
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR));    
 8001d20:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001d22:	f043 031a 	orr.w	r3, r3, #26
 8001d26:	63c3      	str	r3, [r0, #60]	; 0x3c
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8001d28:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001d2a:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsd->hdmatx->XferErrorCallback = SD_DMAError;
 8001d2c:	4927      	ldr	r1, [pc, #156]	; (8001dcc <HAL_SD_WriteBlocks_DMA+0xf8>)
 8001d2e:	64d9      	str	r1, [r3, #76]	; 0x4c
    hsd->hdmatx->XferAbortCallback = NULL;
 8001d30:	651a      	str	r2, [r3, #80]	; 0x50
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8001d32:	6c63      	ldr	r3, [r4, #68]	; 0x44
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8001d34:	f44f 7100 	mov.w	r1, #512	; 0x200
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8001d38:	2b01      	cmp	r3, #1
      BlockAdd *= 512U;
 8001d3a:	bf18      	it	ne
 8001d3c:	026d      	lslne	r5, r5, #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8001d3e:	f001 fbc4 	bl	80034ca <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001d42:	b150      	cbz	r0, 8001d5a <HAL_SD_WriteBlocks_DMA+0x86>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
 8001d44:	6823      	ldr	r3, [r4, #0]
 8001d46:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001d4a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8001d4c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001d4e:	4318      	orrs	r0, r3
 8001d50:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8001d52:	2001      	movs	r0, #1
 8001d54:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      return HAL_ERROR;
 8001d58:	e7c9      	b.n	8001cee <HAL_SD_WriteBlocks_DMA+0x1a>
    if(NumberOfBlocks > 1U)
 8001d5a:	2e01      	cmp	r6, #1
 8001d5c:	d90f      	bls.n	8001d7e <HAL_SD_WriteBlocks_DMA+0xaa>
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8001d5e:	23a0      	movs	r3, #160	; 0xa0
 8001d60:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
 8001d62:	4629      	mov	r1, r5
 8001d64:	6820      	ldr	r0, [r4, #0]
 8001d66:	f001 fc10 	bl	800358a <SDMMC_CmdWriteMultiBlock>
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
 8001d6a:	4605      	mov	r5, r0
 8001d6c:	6822      	ldr	r2, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 8001d6e:	b168      	cbz	r0, 8001d8c <HAL_SD_WriteBlocks_DMA+0xb8>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
 8001d70:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8001d74:	6393      	str	r3, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8001d76:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001d78:	4305      	orrs	r5, r0
 8001d7a:	63a5      	str	r5, [r4, #56]	; 0x38
 8001d7c:	e7e9      	b.n	8001d52 <HAL_SD_WriteBlocks_DMA+0x7e>
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8001d7e:	2390      	movs	r3, #144	; 0x90
 8001d80:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
 8001d82:	4629      	mov	r1, r5
 8001d84:	6820      	ldr	r0, [r4, #0]
 8001d86:	f001 fbe8 	bl	800355a <SDMMC_CmdWriteSingleBlock>
 8001d8a:	e7ee      	b.n	8001d6a <HAL_SD_WriteBlocks_DMA+0x96>
    __HAL_SD_DMA_ENABLE(hsd);
 8001d8c:	4b10      	ldr	r3, [pc, #64]	; (8001dd0 <HAL_SD_WriteBlocks_DMA+0xfc>)
    HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
 8001d8e:	6c20      	ldr	r0, [r4, #64]	; 0x40
    __HAL_SD_DMA_ENABLE(hsd);
 8001d90:	f04f 0801 	mov.w	r8, #1
    HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
 8001d94:	0276      	lsls	r6, r6, #9
    __HAL_SD_DMA_ENABLE(hsd);
 8001d96:	f8c3 8000 	str.w	r8, [r3]
    HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
 8001d9a:	3280      	adds	r2, #128	; 0x80
 8001d9c:	08b3      	lsrs	r3, r6, #2
 8001d9e:	4639      	mov	r1, r7
 8001da0:	f7fe ff2e 	bl	8000c00 <HAL_DMA_Start_IT>
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8001da4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8001da8:	e88d 0048 	stmia.w	sp, {r3, r6}
    SDIO_ConfigData(hsd->Instance, &config);
 8001dac:	4669      	mov	r1, sp
    config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8001dae:	2390      	movs	r3, #144	; 0x90
    SDIO_ConfigData(hsd->Instance, &config);
 8001db0:	6820      	ldr	r0, [r4, #0]
    config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8001db2:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8001db4:	9503      	str	r5, [sp, #12]
    config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001db6:	9504      	str	r5, [sp, #16]
    config.DPSM          = SDIO_DPSM_ENABLE;
 8001db8:	f8cd 8014 	str.w	r8, [sp, #20]
    SDIO_ConfigData(hsd->Instance, &config);
 8001dbc:	f001 fb72 	bl	80034a4 <SDIO_ConfigData>
    return HAL_OK;
 8001dc0:	4628      	mov	r0, r5
 8001dc2:	e794      	b.n	8001cee <HAL_SD_WriteBlocks_DMA+0x1a>
    return HAL_BUSY;
 8001dc4:	2002      	movs	r0, #2
 8001dc6:	e792      	b.n	8001cee <HAL_SD_WriteBlocks_DMA+0x1a>
 8001dc8:	08001af1 	.word	0x08001af1
 8001dcc:	08002335 	.word	0x08002335
 8001dd0:	4225858c 	.word	0x4225858c

08001dd4 <HAL_SD_ErrorCallback>:
 8001dd4:	4770      	bx	lr

08001dd6 <SD_DMAReceiveCplt>:
{
 8001dd6:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8001dd8:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
 8001dda:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001ddc:	2b82      	cmp	r3, #130	; 0x82
 8001dde:	d109      	bne.n	8001df4 <SD_DMAReceiveCplt+0x1e>
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8001de0:	6820      	ldr	r0, [r4, #0]
 8001de2:	f001 fbeb 	bl	80035bc <SDMMC_CmdStopTransfer>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001de6:	b128      	cbz	r0, 8001df4 <SD_DMAReceiveCplt+0x1e>
      hsd->ErrorCode |= errorstate;
 8001de8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001dea:	4318      	orrs	r0, r3
 8001dec:	63a0      	str	r0, [r4, #56]	; 0x38
      HAL_SD_ErrorCallback(hsd);
 8001dee:	4620      	mov	r0, r4
 8001df0:	f7ff fff0 	bl	8001dd4 <HAL_SD_ErrorCallback>
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
 8001df4:	6823      	ldr	r3, [r4, #0]
 8001df6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001df8:	f022 0208 	bic.w	r2, r2, #8
 8001dfc:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001dfe:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001e02:	639a      	str	r2, [r3, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 8001e04:	2301      	movs	r3, #1
 8001e06:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  HAL_SD_RxCpltCallback(hsd);
 8001e0a:	4620      	mov	r0, r4
 8001e0c:	f003 fd5f 	bl	80058ce <HAL_SD_RxCpltCallback>
 8001e10:	bd10      	pop	{r4, pc}

08001e12 <HAL_SD_GetCardCSD>:
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 8001e12:	6e43      	ldr	r3, [r0, #100]	; 0x64
  pCSD->CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 8001e14:	0f9a      	lsrs	r2, r3, #30
 8001e16:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001e18:	f3c3 6283 	ubfx	r2, r3, #26, #4
 8001e1c:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1      = tmp & 0x03U;
 8001e1e:	f3c3 6201 	ubfx	r2, r3, #24, #2
 8001e22:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)tmp;
 8001e24:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8001e28:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)tmp;
 8001e2a:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)tmp;
 8001e2e:	b2db      	uxtb	r3, r3
  pCSD->NSAC = (uint8_t)tmp;
 8001e30:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)tmp;
 8001e32:	714b      	strb	r3, [r1, #5]
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 8001e34:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8001e36:	0e1a      	lsrs	r2, r3, #24
  pCSD->CardComdClasses = (uint16_t)(tmp << 4U);
 8001e38:	0112      	lsls	r2, r2, #4
 8001e3a:	80ca      	strh	r2, [r1, #6]
  pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0U) >> 4U);
 8001e3c:	88ca      	ldrh	r2, [r1, #6]
{
 8001e3e:	b530      	push	{r4, r5, lr}
  pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0U) >> 4U);
 8001e40:	b292      	uxth	r2, r2
 8001e42:	f3c3 5403 	ubfx	r4, r3, #20, #4
 8001e46:	4322      	orrs	r2, r4
 8001e48:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001e4a:	f3c3 4203 	ubfx	r2, r3, #16, #4
 8001e4e:	720a      	strb	r2, [r1, #8]
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 8001e50:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 8001e54:	09d4      	lsrs	r4, r2, #7
 8001e56:	724c      	strb	r4, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 8001e58:	f3c2 1480 	ubfx	r4, r2, #6, #1
 8001e5c:	728c      	strb	r4, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 8001e5e:	f3c2 1440 	ubfx	r4, r2, #5, #1
 8001e62:	72cc      	strb	r4, [r1, #11]
  pCSD->DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8001e64:	f3c2 1400 	ubfx	r4, r2, #4, #1
 8001e68:	730c      	strb	r4, [r1, #12]
  pCSD->Reserved2       = 0U; /*!< Reserved */
 8001e6a:	2400      	movs	r4, #0
 8001e6c:	734c      	strb	r4, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 8001e6e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8001e70:	2c00      	cmp	r4, #0
 8001e72:	f040 8083 	bne.w	8001f7c <HAL_SD_GetCardCSD+0x16a>
    pCSD->DeviceSize = (tmp & 0x03U) << 10U;
 8001e76:	0292      	lsls	r2, r2, #10
 8001e78:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8001e7c:	610a      	str	r2, [r1, #16]
    pCSD->DeviceSize |= (tmp) << 2U;
 8001e7e:	690a      	ldr	r2, [r1, #16]
 8001e80:	009b      	lsls	r3, r3, #2
 8001e82:	f403 737f 	and.w	r3, r3, #1020	; 0x3fc
 8001e86:	4313      	orrs	r3, r2
 8001e88:	610b      	str	r3, [r1, #16]
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001e8a:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    pCSD->DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001e8c:	690b      	ldr	r3, [r1, #16]
 8001e8e:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
 8001e92:	610b      	str	r3, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001e94:	f3c2 63c2 	ubfx	r3, r2, #27, #3
 8001e98:	750b      	strb	r3, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001e9a:	f3c2 6302 	ubfx	r3, r2, #24, #3
 8001e9e:	754b      	strb	r3, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8001ea0:	f3c2 5342 	ubfx	r3, r2, #21, #3
 8001ea4:	758b      	strb	r3, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8001ea6:	f3c2 4382 	ubfx	r3, r2, #18, #3
 8001eaa:	75cb      	strb	r3, [r1, #23]
    pCSD->DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001eac:	0bd3      	lsrs	r3, r2, #15
 8001eae:	f003 0306 	and.w	r3, r3, #6
 8001eb2:	760b      	strb	r3, [r1, #24]
    pCSD->DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8001eb4:	7e0c      	ldrb	r4, [r1, #24]
 8001eb6:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8001eba:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 8001ebe:	4322      	orrs	r2, r4
 8001ec0:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8001ec2:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockNbr *= (1U << (pCSD->DeviceSizeMul + 2U));
 8001ec4:	7e0c      	ldrb	r4, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8001ec6:	3201      	adds	r2, #1
    hsd->SdCard.BlockNbr *= (1U << (pCSD->DeviceSizeMul + 2U));
 8001ec8:	3402      	adds	r4, #2
 8001eca:	40a2      	lsls	r2, r4
 8001ecc:	6542      	str	r2, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = 1U << (pCSD->RdBlockLen);
 8001ece:	7a0d      	ldrb	r5, [r1, #8]
 8001ed0:	2401      	movs	r4, #1
 8001ed2:	40ac      	lsls	r4, r5
 8001ed4:	6584      	str	r4, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U); 
 8001ed6:	0a64      	lsrs	r4, r4, #9
 8001ed8:	4362      	muls	r2, r4
 8001eda:	65c2      	str	r2, [r0, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = 512U;
 8001edc:	f44f 7200 	mov.w	r2, #512	; 0x200
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512U;
 8001ee0:	6602      	str	r2, [r0, #96]	; 0x60
  pCSD->EraseGrSize = (tmp & 0x40U) >> 6U;
 8001ee2:	f3c3 1280 	ubfx	r2, r3, #6, #1
  pCSD->EraseGrMul  = (tmp & 0x3FU) << 1U;
 8001ee6:	005b      	lsls	r3, r3, #1
 8001ee8:	f003 037e 	and.w	r3, r3, #126	; 0x7e
  pCSD->EraseGrSize = (tmp & 0x40U) >> 6U;
 8001eec:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul  = (tmp & 0x3FU) << 1U;
 8001eee:	768b      	strb	r3, [r1, #26]
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 8001ef0:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  pCSD->EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8001ef2:	7e8a      	ldrb	r2, [r1, #26]
 8001ef4:	f3c3 14c0 	ubfx	r4, r3, #7, #1
 8001ef8:	4322      	orrs	r2, r4
  pCSD->WrProtectGrSize = (tmp & 0x7FU);
 8001efa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  pCSD->EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8001efe:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (tmp & 0x7FU);
 8001f00:	76cb      	strb	r3, [r1, #27]
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 8001f02:	6f03      	ldr	r3, [r0, #112]	; 0x70
  pCSD->WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 8001f04:	0fda      	lsrs	r2, r3, #31
 8001f06:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC        = (tmp & 0x60U) >> 5U;
 8001f08:	f3c3 7241 	ubfx	r2, r3, #29, #2
 8001f0c:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8001f0e:	f3c3 6282 	ubfx	r2, r3, #26, #3
 8001f12:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8001f14:	0d9a      	lsrs	r2, r3, #22
 8001f16:	f002 020c 	and.w	r2, r2, #12
 8001f1a:	77ca      	strb	r2, [r1, #31]
  pCSD->MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8001f1c:	7fca      	ldrb	r2, [r1, #31]
 8001f1e:	f3c3 5081 	ubfx	r0, r3, #22, #2
 8001f22:	4302      	orrs	r2, r0
 8001f24:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8001f26:	f3c3 5240 	ubfx	r2, r3, #21, #1
 8001f2a:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3           = 0U;
 8001f2e:	2000      	movs	r0, #0
  pCSD->ContentProtectAppli = (tmp & 0x01U);
 8001f30:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->Reserved3           = 0U;
 8001f34:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (tmp & 0x01U);
 8001f38:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGrouop = (tmp & 0x80U) >> 7U;
 8001f3c:	f3c3 32c0 	ubfx	r2, r3, #15, #1
 8001f40:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag         = (tmp & 0x40U) >> 6U;
 8001f44:	f3c3 3280 	ubfx	r2, r3, #14, #1
 8001f48:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect    = (tmp & 0x20U) >> 5U;
 8001f4c:	f3c3 3240 	ubfx	r2, r3, #13, #1
 8001f50:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect    = (tmp & 0x10U) >> 4U;
 8001f54:	f3c3 3200 	ubfx	r2, r3, #12, #1
 8001f58:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat       = (tmp & 0x0CU) >> 2U;
 8001f5c:	f3c3 2281 	ubfx	r2, r3, #10, #2
 8001f60:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC              = (tmp & 0x03U);
 8001f64:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8001f68:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC              = (tmp & 0x03U);
 8001f6c:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8001f70:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1U;
 8001f74:	2301      	movs	r3, #1
 8001f76:	f881 302a 	strb.w	r3, [r1, #42]	; 0x2a
}
 8001f7a:	bd30      	pop	{r4, r5, pc}
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8001f7c:	2c01      	cmp	r4, #1
 8001f7e:	d11a      	bne.n	8001fb6 <HAL_SD_GetCardCSD+0x1a4>
    pCSD->DeviceSize = (tmp & 0x3FU) << 16U;
 8001f80:	041b      	lsls	r3, r3, #16
 8001f82:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 8001f86:	610b      	str	r3, [r1, #16]
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001f88:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    pCSD->DeviceSize |= (tmp << 8U);
 8001f8a:	690a      	ldr	r2, [r1, #16]
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001f8c:	0e1c      	lsrs	r4, r3, #24
    pCSD->DeviceSize |= (tmp << 8U);
 8001f8e:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 8001f92:	610a      	str	r2, [r1, #16]
    pCSD->DeviceSize |= (tmp);
 8001f94:	690c      	ldr	r4, [r1, #16]
 8001f96:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8001f9a:	4322      	orrs	r2, r4
 8001f9c:	610a      	str	r2, [r1, #16]
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1U) * 1024U);
 8001f9e:	690a      	ldr	r2, [r1, #16]
 8001fa0:	0292      	lsls	r2, r2, #10
 8001fa2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001fa6:	6542      	str	r2, [r0, #84]	; 0x54
 8001fa8:	65c2      	str	r2, [r0, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512U;
 8001faa:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001fae:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8001fb2:	6582      	str	r2, [r0, #88]	; 0x58
 8001fb4:	e794      	b.n	8001ee0 <HAL_SD_GetCardCSD+0xce>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);   
 8001fb6:	6803      	ldr	r3, [r0, #0]
 8001fb8:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001fbc:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8001fbe:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001fc0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001fc4:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8001fc6:	2301      	movs	r3, #1
 8001fc8:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
 8001fcc:	4618      	mov	r0, r3
 8001fce:	bd30      	pop	{r4, r5, pc}

08001fd0 <HAL_SD_InitCard>:
{
 8001fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001fd2:	b099      	sub	sp, #100	; 0x64
  Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 8001fd4:	2500      	movs	r5, #0
  Init.ClockDiv            = SDIO_INIT_CLK_DIV;
 8001fd6:	2376      	movs	r3, #118	; 0x76
 8001fd8:	930c      	str	r3, [sp, #48]	; 0x30
  Init.BusWide             = SDIO_BUS_WIDE_1B;
 8001fda:	950a      	str	r5, [sp, #40]	; 0x28
  Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8001fdc:	950b      	str	r5, [sp, #44]	; 0x2c
  SDIO_Init(hsd->Instance, Init);
 8001fde:	ab0a      	add	r3, sp, #40	; 0x28
{
 8001fe0:	4604      	mov	r4, r0
  SDIO_Init(hsd->Instance, Init);
 8001fe2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8001fe6:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  __HAL_SD_DISABLE(hsd); 
 8001fea:	4e6f      	ldr	r6, [pc, #444]	; (80021a8 <HAL_SD_InitCard+0x1d8>)
  Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 8001fec:	9507      	str	r5, [sp, #28]
  Init.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 8001fee:	9508      	str	r5, [sp, #32]
  Init.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8001ff0:	9509      	str	r5, [sp, #36]	; 0x24
  SDIO_Init(hsd->Instance, Init);
 8001ff2:	ab07      	add	r3, sp, #28
 8001ff4:	cb0e      	ldmia	r3, {r1, r2, r3}
 8001ff6:	6820      	ldr	r0, [r4, #0]
 8001ff8:	f001 f97a 	bl	80032f0 <SDIO_Init>
  __HAL_SD_ENABLE(hsd);
 8001ffc:	2701      	movs	r7, #1
  __HAL_SD_DISABLE(hsd); 
 8001ffe:	6035      	str	r5, [r6, #0]
  SDIO_PowerState_ON(hsd->Instance);
 8002000:	6820      	ldr	r0, [r4, #0]
 8002002:	f001 f999 	bl	8003338 <SDIO_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
 8002006:	6037      	str	r7, [r6, #0]
  HAL_Delay(2U);
 8002008:	2002      	movs	r0, #2
 800200a:	f7fe fad9 	bl	80005c0 <HAL_Delay>
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800200e:	6820      	ldr	r0, [r4, #0]
  __IO uint32_t count = 0U;
 8002010:	9506      	str	r5, [sp, #24]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8002012:	f001 fb05 	bl	8003620 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8002016:	4606      	mov	r6, r0
 8002018:	b968      	cbnz	r0, 8002036 <HAL_SD_InitCard+0x66>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800201a:	6820      	ldr	r0, [r4, #0]
 800201c:	f001 fb28 	bl	8003670 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 8002020:	b380      	cbz	r0, 8002084 <HAL_SD_InitCard+0xb4>
    hsd->SdCard.CardVersion = CARD_V1_X;
 8002022:	64a6      	str	r6, [r4, #72]	; 0x48
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8002024:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8002028:	9b06      	ldr	r3, [sp, #24]
 800202a:	1c5a      	adds	r2, r3, #1
 800202c:	42ab      	cmp	r3, r5
 800202e:	9206      	str	r2, [sp, #24]
 8002030:	d108      	bne.n	8002044 <HAL_SD_InitCard+0x74>
        return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8002032:	f04f 7680 	mov.w	r6, #16777216	; 0x1000000
    hsd->State = HAL_SD_STATE_READY;
 8002036:	2001      	movs	r0, #1
 8002038:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800203c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800203e:	430e      	orrs	r6, r1
 8002040:	63a6      	str	r6, [r4, #56]	; 0x38
    return HAL_ERROR;
 8002042:	e081      	b.n	8002148 <HAL_SD_InitCard+0x178>
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0U);
 8002044:	2100      	movs	r1, #0
 8002046:	6820      	ldr	r0, [r4, #0]
 8002048:	f001 fb4a 	bl	80036e0 <SDMMC_CmdAppCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 800204c:	4601      	mov	r1, r0
 800204e:	b110      	cbz	r0, 8002056 <HAL_SD_InitCard+0x86>
        return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8002050:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8002054:	e7ef      	b.n	8002036 <HAL_SD_InitCard+0x66>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_STD_CAPACITY);
 8002056:	6820      	ldr	r0, [r4, #0]
 8002058:	f001 fb5a 	bl	8003710 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 800205c:	4601      	mov	r1, r0
 800205e:	2800      	cmp	r0, #0
 8002060:	d1f6      	bne.n	8002050 <HAL_SD_InitCard+0x80>
      response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8002062:	6820      	ldr	r0, [r4, #0]
 8002064:	f001 f983 	bl	800336e <SDIO_GetResponse>
    while(validvoltage == 0U)
 8002068:	2800      	cmp	r0, #0
 800206a:	dadd      	bge.n	8002028 <HAL_SD_InitCard+0x58>
    hsd->SdCard.CardType = CARD_SDSC;
 800206c:	2300      	movs	r3, #0
      hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800206e:	6463      	str	r3, [r4, #68]	; 0x44
  if(SDIO_GetPowerState(hsd->Instance) == 0U) 
 8002070:	6820      	ldr	r0, [r4, #0]
  uint16_t sd_rca = 1U;
 8002072:	2301      	movs	r3, #1
 8002074:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDIO_GetPowerState(hsd->Instance) == 0U) 
 8002078:	f001 f962 	bl	8003340 <SDIO_GetPowerState>
 800207c:	bb10      	cbnz	r0, 80020c4 <HAL_SD_InitCard+0xf4>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800207e:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 8002082:	e06b      	b.n	800215c <HAL_SD_InitCard+0x18c>
    hsd->SdCard.CardVersion = CARD_V2_X;
 8002084:	64a7      	str	r7, [r4, #72]	; 0x48
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8002086:	f64f 75ff 	movw	r5, #65535	; 0xffff
 800208a:	9b06      	ldr	r3, [sp, #24]
 800208c:	1c5a      	adds	r2, r3, #1
 800208e:	42ab      	cmp	r3, r5
 8002090:	9206      	str	r2, [sp, #24]
 8002092:	d0ce      	beq.n	8002032 <HAL_SD_InitCard+0x62>
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0U);
 8002094:	2100      	movs	r1, #0
 8002096:	6820      	ldr	r0, [r4, #0]
 8002098:	f001 fb22 	bl	80036e0 <SDMMC_CmdAppCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 800209c:	4606      	mov	r6, r0
 800209e:	2800      	cmp	r0, #0
 80020a0:	d1c9      	bne.n	8002036 <HAL_SD_InitCard+0x66>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_HIGH_CAPACITY);
 80020a2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80020a6:	6820      	ldr	r0, [r4, #0]
 80020a8:	f001 fb32 	bl	8003710 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 80020ac:	4606      	mov	r6, r0
 80020ae:	2800      	cmp	r0, #0
 80020b0:	d1c1      	bne.n	8002036 <HAL_SD_InitCard+0x66>
      response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 80020b2:	4601      	mov	r1, r0
 80020b4:	6820      	ldr	r0, [r4, #0]
 80020b6:	f001 f95a 	bl	800336e <SDIO_GetResponse>
    while(validvoltage == 0U)
 80020ba:	0fc3      	lsrs	r3, r0, #31
 80020bc:	d0e5      	beq.n	800208a <HAL_SD_InitCard+0xba>
    if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 80020be:	0042      	lsls	r2, r0, #1
 80020c0:	d5d4      	bpl.n	800206c <HAL_SD_InitCard+0x9c>
 80020c2:	e7d4      	b.n	800206e <HAL_SD_InitCard+0x9e>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 80020c4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80020c6:	2b03      	cmp	r3, #3
 80020c8:	d01a      	beq.n	8002100 <HAL_SD_InitCard+0x130>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 80020ca:	6820      	ldr	r0, [r4, #0]
 80020cc:	f001 fb51 	bl	8003772 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 80020d0:	4605      	mov	r5, r0
 80020d2:	2800      	cmp	r0, #0
 80020d4:	d142      	bne.n	800215c <HAL_SD_InitCard+0x18c>
      hsd->CID[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 80020d6:	4601      	mov	r1, r0
 80020d8:	6820      	ldr	r0, [r4, #0]
 80020da:	f001 f948 	bl	800336e <SDIO_GetResponse>
      hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 80020de:	2104      	movs	r1, #4
      hsd->CID[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 80020e0:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 80020e2:	6820      	ldr	r0, [r4, #0]
 80020e4:	f001 f943 	bl	800336e <SDIO_GetResponse>
      hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 80020e8:	2108      	movs	r1, #8
      hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 80020ea:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 80020ec:	6820      	ldr	r0, [r4, #0]
 80020ee:	f001 f93e 	bl	800336e <SDIO_GetResponse>
      hsd->CID[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 80020f2:	210c      	movs	r1, #12
      hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 80020f4:	67e0      	str	r0, [r4, #124]	; 0x7c
      hsd->CID[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 80020f6:	6820      	ldr	r0, [r4, #0]
 80020f8:	f001 f939 	bl	800336e <SDIO_GetResponse>
 80020fc:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED) 
 8002100:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002102:	2b03      	cmp	r3, #3
 8002104:	d122      	bne.n	800214c <HAL_SD_InitCard+0x17c>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 8002106:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002108:	2b03      	cmp	r3, #3
 800210a:	d12e      	bne.n	800216a <HAL_SD_InitCard+0x19a>
  hsd->SdCard.Class = (SDIO_GetResponse(hsd->Instance, SDIO_RESP2) >> 20U);
 800210c:	2104      	movs	r1, #4
 800210e:	6820      	ldr	r0, [r4, #0]
 8002110:	f001 f92d 	bl	800336e <SDIO_GetResponse>
 8002114:	0d00      	lsrs	r0, r0, #20
 8002116:	64e0      	str	r0, [r4, #76]	; 0x4c
  HAL_SD_GetCardCSD(hsd, &CSD);
 8002118:	a90d      	add	r1, sp, #52	; 0x34
 800211a:	4620      	mov	r0, r4
 800211c:	f7ff fe79 	bl	8001e12 <HAL_SD_GetCardCSD>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 8002120:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8002122:	6820      	ldr	r0, [r4, #0]
 8002124:	0412      	lsls	r2, r2, #16
 8002126:	2300      	movs	r3, #0
 8002128:	f001 fa62 	bl	80035f0 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 800212c:	4605      	mov	r5, r0
 800212e:	b9a8      	cbnz	r0, 800215c <HAL_SD_InitCard+0x18c>
  SDIO_Init(hsd->Instance, hsd->Init);
 8002130:	f104 0310 	add.w	r3, r4, #16
 8002134:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8002138:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800213c:	1d23      	adds	r3, r4, #4
 800213e:	cb0e      	ldmia	r3, {r1, r2, r3}
 8002140:	6820      	ldr	r0, [r4, #0]
 8002142:	f001 f8d5 	bl	80032f0 <SDIO_Init>
  return HAL_OK;
 8002146:	4628      	mov	r0, r5
}
 8002148:	b019      	add	sp, #100	; 0x64
 800214a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800214c:	f10d 0116 	add.w	r1, sp, #22
 8002150:	6820      	ldr	r0, [r4, #0]
 8002152:	f001 fb39 	bl	80037c8 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002156:	4605      	mov	r5, r0
 8002158:	2800      	cmp	r0, #0
 800215a:	d0d4      	beq.n	8002106 <HAL_SD_InitCard+0x136>
    hsd->State = HAL_SD_STATE_READY;
 800215c:	2001      	movs	r0, #1
 800215e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8002162:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002164:	431d      	orrs	r5, r3
 8002166:	63a5      	str	r5, [r4, #56]	; 0x38
 8002168:	e7ee      	b.n	8002148 <HAL_SD_InitCard+0x178>
    hsd->SdCard.RelCardAdd = sd_rca;
 800216a:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 800216e:	6521      	str	r1, [r4, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002170:	6820      	ldr	r0, [r4, #0]
 8002172:	0409      	lsls	r1, r1, #16
 8002174:	f001 fb12 	bl	800379c <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002178:	4605      	mov	r5, r0
 800217a:	2800      	cmp	r0, #0
 800217c:	d1ee      	bne.n	800215c <HAL_SD_InitCard+0x18c>
      hsd->CSD[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 800217e:	4601      	mov	r1, r0
 8002180:	6820      	ldr	r0, [r4, #0]
 8002182:	f001 f8f4 	bl	800336e <SDIO_GetResponse>
      hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8002186:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8002188:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 800218a:	6820      	ldr	r0, [r4, #0]
 800218c:	f001 f8ef 	bl	800336e <SDIO_GetResponse>
      hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 8002190:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8002192:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 8002194:	6820      	ldr	r0, [r4, #0]
 8002196:	f001 f8ea 	bl	800336e <SDIO_GetResponse>
      hsd->CSD[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 800219a:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 800219c:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CSD[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 800219e:	6820      	ldr	r0, [r4, #0]
 80021a0:	f001 f8e5 	bl	800336e <SDIO_GetResponse>
 80021a4:	6720      	str	r0, [r4, #112]	; 0x70
 80021a6:	e7b1      	b.n	800210c <HAL_SD_InitCard+0x13c>
 80021a8:	422580a0 	.word	0x422580a0

080021ac <HAL_SD_Init>:
{
 80021ac:	b510      	push	{r4, lr}
  if(hsd == NULL)
 80021ae:	4604      	mov	r4, r0
 80021b0:	b1a0      	cbz	r0, 80021dc <HAL_SD_Init+0x30>
  if(hsd->State == HAL_SD_STATE_RESET)
 80021b2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 80021b6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80021ba:	b913      	cbnz	r3, 80021c2 <HAL_SD_Init+0x16>
    hsd->Lock = HAL_UNLOCKED;
 80021bc:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 80021be:	f003 ffc5 	bl	800614c <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
 80021c2:	2303      	movs	r3, #3
 80021c4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  HAL_SD_InitCard(hsd);
 80021c8:	4620      	mov	r0, r4
 80021ca:	f7ff ff01 	bl	8001fd0 <HAL_SD_InitCard>
  hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 80021ce:	2000      	movs	r0, #0
  hsd->State = HAL_SD_STATE_READY;
 80021d0:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 80021d2:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 80021d4:	6320      	str	r0, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 80021d6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 80021da:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80021dc:	2001      	movs	r0, #1
}
 80021de:	bd10      	pop	{r4, pc}

080021e0 <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 80021e0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80021e2:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 80021e4:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80021e6:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 80021e8:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80021ea:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 80021ec:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80021ee:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 80021f0:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80021f2:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 80021f4:	6d83      	ldr	r3, [r0, #88]	; 0x58
 80021f6:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 80021f8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80021fa:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 80021fc:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80021fe:	61cb      	str	r3, [r1, #28]
}
 8002200:	2000      	movs	r0, #0
 8002202:	4770      	bx	lr

08002204 <HAL_SD_ConfigWideBusOperation>:
{
 8002204:	b570      	push	{r4, r5, r6, lr}
  hsd->State = HAL_SD_STATE_BUSY;
 8002206:	2303      	movs	r3, #3
 8002208:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED) 
 800220c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800220e:	2b03      	cmp	r3, #3
{
 8002210:	b08a      	sub	sp, #40	; 0x28
 8002212:	4604      	mov	r4, r0
 8002214:	460e      	mov	r6, r1
  if(hsd->SdCard.CardType != CARD_SECURED) 
 8002216:	d002      	beq.n	800221e <HAL_SD_ConfigWideBusOperation+0x1a>
    if(WideMode == SDIO_BUS_WIDE_8B)
 8002218:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 800221c:	d103      	bne.n	8002226 <HAL_SD_ConfigWideBusOperation+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800221e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002220:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002224:	e056      	b.n	80022d4 <HAL_SD_ConfigWideBusOperation+0xd0>
    else if(WideMode == SDIO_BUS_WIDE_4B)
 8002226:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 800222a:	d12d      	bne.n	8002288 <HAL_SD_ConfigWideBusOperation+0x84>
  uint32_t scr[2U] = {0U, 0U};
 800222c:	2100      	movs	r1, #0
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800222e:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0U, 0U};
 8002230:	9104      	str	r1, [sp, #16]
 8002232:	9105      	str	r1, [sp, #20]
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8002234:	f001 f89b 	bl	800336e <SDIO_GetResponse>
 8002238:	0180      	lsls	r0, r0, #6
 800223a:	d420      	bmi.n	800227e <HAL_SD_ConfigWideBusOperation+0x7a>
  errorstate = SD_FindSCR(hsd, scr);
 800223c:	a904      	add	r1, sp, #16
 800223e:	4620      	mov	r0, r4
 8002240:	f7ff fc5d 	bl	8001afe <SD_FindSCR>
  if(errorstate != HAL_OK)
 8002244:	b960      	cbnz	r0, 8002260 <HAL_SD_ConfigWideBusOperation+0x5c>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8002246:	9b05      	ldr	r3, [sp, #20]
 8002248:	0359      	lsls	r1, r3, #13
 800224a:	d51a      	bpl.n	8002282 <HAL_SD_ConfigWideBusOperation+0x7e>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800224c:	6d21      	ldr	r1, [r4, #80]	; 0x50
 800224e:	6820      	ldr	r0, [r4, #0]
 8002250:	0409      	lsls	r1, r1, #16
 8002252:	f001 fa45 	bl	80036e0 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_OK)
 8002256:	b918      	cbnz	r0, 8002260 <HAL_SD_ConfigWideBusOperation+0x5c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 8002258:	2102      	movs	r1, #2
 800225a:	6820      	ldr	r0, [r4, #0]
 800225c:	f001 fb38 	bl	80038d0 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 8002260:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002262:	4318      	orrs	r0, r3
      hsd->ErrorCode |= errorstate;
 8002264:	63a0      	str	r0, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8002266:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8002268:	2d00      	cmp	r5, #0
 800226a:	d035      	beq.n	80022d8 <HAL_SD_ConfigWideBusOperation+0xd4>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800226c:	6823      	ldr	r3, [r4, #0]
 800226e:	f240 52ff 	movw	r2, #1535	; 0x5ff
    hsd->State = HAL_SD_STATE_READY;
 8002272:	2001      	movs	r0, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002274:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8002276:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
}
 800227a:	b00a      	add	sp, #40	; 0x28
 800227c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800227e:	4630      	mov	r0, r6
 8002280:	e7ee      	b.n	8002260 <HAL_SD_ConfigWideBusOperation+0x5c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8002282:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8002286:	e7eb      	b.n	8002260 <HAL_SD_ConfigWideBusOperation+0x5c>
    else if(WideMode == SDIO_BUS_WIDE_1B)
 8002288:	bb09      	cbnz	r1, 80022ce <HAL_SD_ConfigWideBusOperation+0xca>
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800228a:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0U, 0U};
 800228c:	9104      	str	r1, [sp, #16]
 800228e:	9105      	str	r1, [sp, #20]
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8002290:	f001 f86d 	bl	800336e <SDIO_GetResponse>
 8002294:	0182      	lsls	r2, r0, #6
 8002296:	d414      	bmi.n	80022c2 <HAL_SD_ConfigWideBusOperation+0xbe>
  errorstate = SD_FindSCR(hsd, scr);
 8002298:	a904      	add	r1, sp, #16
 800229a:	4620      	mov	r0, r4
 800229c:	f7ff fc2f 	bl	8001afe <SD_FindSCR>
  if(errorstate != HAL_OK)
 80022a0:	b960      	cbnz	r0, 80022bc <HAL_SD_ConfigWideBusOperation+0xb8>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 80022a2:	9b05      	ldr	r3, [sp, #20]
 80022a4:	03db      	lsls	r3, r3, #15
 80022a6:	d50f      	bpl.n	80022c8 <HAL_SD_ConfigWideBusOperation+0xc4>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80022a8:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80022aa:	6820      	ldr	r0, [r4, #0]
 80022ac:	0409      	lsls	r1, r1, #16
 80022ae:	f001 fa17 	bl	80036e0 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_OK)
 80022b2:	b918      	cbnz	r0, 80022bc <HAL_SD_ConfigWideBusOperation+0xb8>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 80022b4:	4601      	mov	r1, r0
 80022b6:	6820      	ldr	r0, [r4, #0]
 80022b8:	f001 fb0a 	bl	80038d0 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 80022bc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80022be:	4308      	orrs	r0, r1
 80022c0:	e7d0      	b.n	8002264 <HAL_SD_ConfigWideBusOperation+0x60>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 80022c2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80022c6:	e7f9      	b.n	80022bc <HAL_SD_ConfigWideBusOperation+0xb8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80022c8:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80022cc:	e7f6      	b.n	80022bc <HAL_SD_ConfigWideBusOperation+0xb8>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80022ce:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80022d0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80022d4:	63a3      	str	r3, [r4, #56]	; 0x38
 80022d6:	e7c6      	b.n	8002266 <HAL_SD_ConfigWideBusOperation+0x62>
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80022d8:	6863      	ldr	r3, [r4, #4]
 80022da:	9304      	str	r3, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 80022dc:	68a3      	ldr	r3, [r4, #8]
 80022de:	9305      	str	r3, [sp, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80022e0:	68e3      	ldr	r3, [r4, #12]
 80022e2:	9306      	str	r3, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 80022e4:	6963      	ldr	r3, [r4, #20]
 80022e6:	9308      	str	r3, [sp, #32]
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80022e8:	69a3      	ldr	r3, [r4, #24]
 80022ea:	9309      	str	r3, [sp, #36]	; 0x24
    Init.BusWide             = WideMode;
 80022ec:	9607      	str	r6, [sp, #28]
    SDIO_Init(hsd->Instance, Init);
 80022ee:	ab0a      	add	r3, sp, #40	; 0x28
 80022f0:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80022f4:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80022f8:	ab04      	add	r3, sp, #16
 80022fa:	cb0e      	ldmia	r3, {r1, r2, r3}
 80022fc:	6820      	ldr	r0, [r4, #0]
 80022fe:	f000 fff7 	bl	80032f0 <SDIO_Init>
  hsd->State = HAL_SD_STATE_READY;
 8002302:	2301      	movs	r3, #1
 8002304:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 8002308:	4628      	mov	r0, r5
 800230a:	e7b6      	b.n	800227a <HAL_SD_ConfigWideBusOperation+0x76>

0800230c <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800230c:	6d01      	ldr	r1, [r0, #80]	; 0x50
{
 800230e:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002310:	0409      	lsls	r1, r1, #16
{
 8002312:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002314:	6800      	ldr	r0, [r0, #0]
 8002316:	f001 faab 	bl	8003870 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_OK)
 800231a:	4601      	mov	r1, r0
 800231c:	b928      	cbnz	r0, 800232a <HAL_SD_GetCardState+0x1e>
  *pCardStatus = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 800231e:	6820      	ldr	r0, [r4, #0]
 8002320:	f001 f825 	bl	800336e <SDIO_GetResponse>
  return cardstate;
 8002324:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 8002328:	bd10      	pop	{r4, pc}
    hsd->ErrorCode |= errorstate;
 800232a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800232c:	4319      	orrs	r1, r3
 800232e:	63a1      	str	r1, [r4, #56]	; 0x38
  uint32_t resp1 = 0;
 8002330:	2000      	movs	r0, #0
 8002332:	e7f7      	b.n	8002324 <HAL_SD_GetCardState+0x18>

08002334 <SD_DMAError>:
{
 8002334:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8002336:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if((hsd->hdmarx->ErrorCode == HAL_DMA_ERROR_TE) || (hsd->hdmatx->ErrorCode == HAL_DMA_ERROR_TE))
 8002338:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800233a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800233c:	2b01      	cmp	r3, #1
 800233e:	d003      	beq.n	8002348 <SD_DMAError+0x14>
 8002340:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002342:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002344:	2b01      	cmp	r3, #1
 8002346:	d11b      	bne.n	8002380 <SD_DMAError+0x4c>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002348:	6823      	ldr	r3, [r4, #0]
 800234a:	f240 52ff 	movw	r2, #1535	; 0x5ff
 800234e:	639a      	str	r2, [r3, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 8002350:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002352:	f422 729d 	bic.w	r2, r2, #314	; 0x13a
 8002356:	63da      	str	r2, [r3, #60]	; 0x3c
    hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8002358:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800235a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800235e:	63a3      	str	r3, [r4, #56]	; 0x38
    CardState = HAL_SD_GetCardState(hsd);
 8002360:	4620      	mov	r0, r4
 8002362:	f7ff ffd3 	bl	800230c <HAL_SD_GetCardState>
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 8002366:	3805      	subs	r0, #5
 8002368:	b2c0      	uxtb	r0, r0
 800236a:	2801      	cmp	r0, #1
 800236c:	d805      	bhi.n	800237a <SD_DMAError+0x46>
      hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 800236e:	6820      	ldr	r0, [r4, #0]
 8002370:	f001 f924 	bl	80035bc <SDMMC_CmdStopTransfer>
 8002374:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002376:	4318      	orrs	r0, r3
 8002378:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State= HAL_SD_STATE_READY;
 800237a:	2301      	movs	r3, #1
 800237c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  HAL_SD_ErrorCallback(hsd);
 8002380:	4620      	mov	r0, r4
 8002382:	f7ff fd27 	bl	8001dd4 <HAL_SD_ErrorCallback>
 8002386:	bd10      	pop	{r4, pc}

08002388 <SD_DMATxAbort>:
{
 8002388:	b538      	push	{r3, r4, r5, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 800238a:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if(hsd->hdmatx != NULL)
 800238c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800238e:	b10b      	cbz	r3, 8002394 <SD_DMATxAbort+0xc>
    hsd->hdmatx = NULL;
 8002390:	2300      	movs	r3, #0
 8002392:	6423      	str	r3, [r4, #64]	; 0x40
  if(hsd->hdmarx == NULL)
 8002394:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8002396:	b9c5      	cbnz	r5, 80023ca <SD_DMATxAbort+0x42>
    CardState = HAL_SD_GetCardState(hsd);
 8002398:	4620      	mov	r0, r4
 800239a:	f7ff ffb7 	bl	800230c <HAL_SD_GetCardState>
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 800239e:	3805      	subs	r0, #5
    hsd->State = HAL_SD_STATE_READY;
 80023a0:	2301      	movs	r3, #1
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80023a2:	b2c0      	uxtb	r0, r0
 80023a4:	4298      	cmp	r0, r3
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80023a6:	63a5      	str	r5, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80023a8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80023ac:	d80d      	bhi.n	80023ca <SD_DMATxAbort+0x42>
      hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 80023ae:	6820      	ldr	r0, [r4, #0]
 80023b0:	f001 f904 	bl	80035bc <SDMMC_CmdStopTransfer>
 80023b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80023b6:	4318      	orrs	r0, r3
 80023b8:	63a0      	str	r0, [r4, #56]	; 0x38
      if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80023ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        HAL_SD_AbortCallback(hsd);
 80023bc:	4620      	mov	r0, r4
      if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80023be:	b113      	cbz	r3, 80023c6 <SD_DMATxAbort+0x3e>
        HAL_SD_AbortCallback(hsd);
 80023c0:	f003 fa7d 	bl	80058be <HAL_SD_AbortCallback>
 80023c4:	bd38      	pop	{r3, r4, r5, pc}
        HAL_SD_ErrorCallback(hsd);
 80023c6:	f7ff fd05 	bl	8001dd4 <HAL_SD_ErrorCallback>
 80023ca:	bd38      	pop	{r3, r4, r5, pc}

080023cc <SD_DMARxAbort>:
{
 80023cc:	b538      	push	{r3, r4, r5, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 80023ce:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if(hsd->hdmarx != NULL)
 80023d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80023d2:	b10b      	cbz	r3, 80023d8 <SD_DMARxAbort+0xc>
    hsd->hdmarx = NULL;
 80023d4:	2300      	movs	r3, #0
 80023d6:	63e3      	str	r3, [r4, #60]	; 0x3c
  if(hsd->hdmatx == NULL)
 80023d8:	6c25      	ldr	r5, [r4, #64]	; 0x40
 80023da:	b9c5      	cbnz	r5, 800240e <SD_DMARxAbort+0x42>
    CardState = HAL_SD_GetCardState(hsd);
 80023dc:	4620      	mov	r0, r4
 80023de:	f7ff ff95 	bl	800230c <HAL_SD_GetCardState>
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80023e2:	3805      	subs	r0, #5
    hsd->State = HAL_SD_STATE_READY;
 80023e4:	2301      	movs	r3, #1
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80023e6:	b2c0      	uxtb	r0, r0
 80023e8:	4298      	cmp	r0, r3
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80023ea:	63a5      	str	r5, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80023ec:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80023f0:	d80d      	bhi.n	800240e <SD_DMARxAbort+0x42>
      hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 80023f2:	6820      	ldr	r0, [r4, #0]
 80023f4:	f001 f8e2 	bl	80035bc <SDMMC_CmdStopTransfer>
 80023f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80023fa:	4318      	orrs	r0, r3
 80023fc:	63a0      	str	r0, [r4, #56]	; 0x38
      if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80023fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        HAL_SD_AbortCallback(hsd);
 8002400:	4620      	mov	r0, r4
      if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8002402:	b113      	cbz	r3, 800240a <SD_DMARxAbort+0x3e>
        HAL_SD_AbortCallback(hsd);
 8002404:	f003 fa5b 	bl	80058be <HAL_SD_AbortCallback>
 8002408:	bd38      	pop	{r3, r4, r5, pc}
        HAL_SD_ErrorCallback(hsd);
 800240a:	f7ff fce3 	bl	8001dd4 <HAL_SD_ErrorCallback>
 800240e:	bd38      	pop	{r3, r4, r5, pc}

08002410 <HAL_SD_IRQHandler>:
{
 8002410:	b570      	push	{r4, r5, r6, lr}
 8002412:	4604      	mov	r4, r0
  if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DATAEND) != RESET)
 8002414:	6800      	ldr	r0, [r0, #0]
 8002416:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002418:	05db      	lsls	r3, r3, #23
 800241a:	d54d      	bpl.n	80024b8 <HAL_SD_IRQHandler+0xa8>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DATAEND); 
 800241c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002420:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 8002422:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8002424:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
 8002428:	63c3      	str	r3, [r0, #60]	; 0x3c
    if((hsd->Context & SD_CONTEXT_IT) != RESET)
 800242a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800242c:	f013 0f08 	tst.w	r3, #8
      if(((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET))
 8002430:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if((hsd->Context & SD_CONTEXT_IT) != RESET)
 8002432:	d01e      	beq.n	8002472 <HAL_SD_IRQHandler+0x62>
      if(((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET))
 8002434:	079e      	lsls	r6, r3, #30
 8002436:	d402      	bmi.n	800243e <HAL_SD_IRQHandler+0x2e>
 8002438:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800243a:	069d      	lsls	r5, r3, #26
 800243c:	d508      	bpl.n	8002450 <HAL_SD_IRQHandler+0x40>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800243e:	f001 f8bd 	bl	80035bc <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8002442:	b128      	cbz	r0, 8002450 <HAL_SD_IRQHandler+0x40>
          hsd->ErrorCode |= errorstate;
 8002444:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002446:	4318      	orrs	r0, r3
 8002448:	63a0      	str	r0, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 800244a:	4620      	mov	r0, r4
 800244c:	f7ff fcc2 	bl	8001dd4 <HAL_SD_ErrorCallback>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002450:	6823      	ldr	r3, [r4, #0]
 8002452:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8002456:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8002458:	2301      	movs	r3, #1
 800245a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET))
 800245e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002460:	07d9      	lsls	r1, r3, #31
        HAL_SD_RxCpltCallback(hsd);
 8002462:	4620      	mov	r0, r4
      if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET))
 8002464:	d402      	bmi.n	800246c <HAL_SD_IRQHandler+0x5c>
 8002466:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002468:	079a      	lsls	r2, r3, #30
 800246a:	d522      	bpl.n	80024b2 <HAL_SD_IRQHandler+0xa2>
        HAL_SD_RxCpltCallback(hsd);
 800246c:	f003 fa2f 	bl	80058ce <HAL_SD_RxCpltCallback>
 8002470:	bd70      	pop	{r4, r5, r6, pc}
    else if((hsd->Context & SD_CONTEXT_DMA) != RESET)
 8002472:	061b      	lsls	r3, r3, #24
 8002474:	f140 809b 	bpl.w	80025ae <HAL_SD_IRQHandler+0x19e>
      if((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET)
 8002478:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800247a:	069e      	lsls	r6, r3, #26
 800247c:	d508      	bpl.n	8002490 <HAL_SD_IRQHandler+0x80>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800247e:	f001 f89d 	bl	80035bc <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8002482:	b128      	cbz	r0, 8002490 <HAL_SD_IRQHandler+0x80>
          hsd->ErrorCode |= errorstate;
 8002484:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002486:	4318      	orrs	r0, r3
 8002488:	63a0      	str	r0, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 800248a:	4620      	mov	r0, r4
 800248c:	f7ff fca2 	bl	8001dd4 <HAL_SD_ErrorCallback>
      if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) == RESET) && ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == RESET))
 8002490:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002492:	07dd      	lsls	r5, r3, #31
 8002494:	f100 808b 	bmi.w	80025ae <HAL_SD_IRQHandler+0x19e>
 8002498:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800249a:	0798      	lsls	r0, r3, #30
 800249c:	f100 8087 	bmi.w	80025ae <HAL_SD_IRQHandler+0x19e>
        hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
 80024a0:	6822      	ldr	r2, [r4, #0]
 80024a2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80024a4:	f023 0308 	bic.w	r3, r3, #8
 80024a8:	62d3      	str	r3, [r2, #44]	; 0x2c
        hsd->State = HAL_SD_STATE_READY;
 80024aa:	2301      	movs	r3, #1
 80024ac:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        HAL_SD_TxCpltCallback(hsd);
 80024b0:	4620      	mov	r0, r4
 80024b2:	f003 fa08 	bl	80058c6 <HAL_SD_TxCpltCallback>
 80024b6:	bd70      	pop	{r4, r5, r6, pc}
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXFIFOHE) != RESET)
 80024b8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80024ba:	0459      	lsls	r1, r3, #17
 80024bc:	d510      	bpl.n	80024e0 <HAL_SD_IRQHandler+0xd0>
static HAL_StatusTypeDef SD_Write_IT(SD_HandleTypeDef *hsd)
{
  uint32_t count = 0U;
  uint32_t* tmp;
  
  tmp = (uint32_t*)hsd->pTxBuffPtr;
 80024be:	6a25      	ldr	r5, [r4, #32]
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_TXFIFOHE);
 80024c0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80024c4:	6383      	str	r3, [r0, #56]	; 0x38
 80024c6:	f105 0620 	add.w	r6, r5, #32
  
  /* Write data to SDIO Tx FIFO */
  for(count = 0U; count < 8U; count++)
  {
    SDIO_WriteFIFO(hsd->Instance, (tmp + count));
 80024ca:	4629      	mov	r1, r5
 80024cc:	6820      	ldr	r0, [r4, #0]
 80024ce:	3504      	adds	r5, #4
 80024d0:	f000 ff2d 	bl	800332e <SDIO_WriteFIFO>
  for(count = 0U; count < 8U; count++)
 80024d4:	42ae      	cmp	r6, r5
 80024d6:	d1f8      	bne.n	80024ca <HAL_SD_IRQHandler+0xba>
  }
  
  hsd->pTxBuffPtr += 8U;
 80024d8:	6a23      	ldr	r3, [r4, #32]
 80024da:	3320      	adds	r3, #32
 80024dc:	6223      	str	r3, [r4, #32]
 80024de:	bd70      	pop	{r4, r5, r6, pc}
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXFIFOHF) != RESET)
 80024e0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80024e2:	041a      	lsls	r2, r3, #16
 80024e4:	d510      	bpl.n	8002508 <HAL_SD_IRQHandler+0xf8>
  tmp = (uint32_t*)hsd->pRxBuffPtr;
 80024e6:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXFIFOHF);
 80024e8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80024ec:	1f2e      	subs	r6, r5, #4
 80024ee:	6383      	str	r3, [r0, #56]	; 0x38
 80024f0:	351c      	adds	r5, #28
    *(tmp + count) = SDIO_ReadFIFO(hsd->Instance);
 80024f2:	6820      	ldr	r0, [r4, #0]
 80024f4:	f000 ff18 	bl	8003328 <SDIO_ReadFIFO>
 80024f8:	f846 0f04 	str.w	r0, [r6, #4]!
  for(count = 0U; count < 8U; count++)
 80024fc:	42ae      	cmp	r6, r5
 80024fe:	d1f8      	bne.n	80024f2 <HAL_SD_IRQHandler+0xe2>
  hsd->pRxBuffPtr += 8U;
 8002500:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002502:	3320      	adds	r3, #32
 8002504:	62a3      	str	r3, [r4, #40]	; 0x28
 8002506:	bd70      	pop	{r4, r5, r6, pc}
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_TXUNDERR) != RESET)
 8002508:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800250a:	f013 0f3a 	tst.w	r3, #58	; 0x3a
 800250e:	d04e      	beq.n	80025ae <HAL_SD_IRQHandler+0x19e>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL) != RESET)
 8002510:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002512:	079b      	lsls	r3, r3, #30
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL; 
 8002514:	bf42      	ittt	mi
 8002516:	6ba3      	ldrmi	r3, [r4, #56]	; 0x38
 8002518:	f043 0302 	orrmi.w	r3, r3, #2
 800251c:	63a3      	strmi	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DTIMEOUT) != RESET)
 800251e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002520:	071e      	lsls	r6, r3, #28
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT; 
 8002522:	bf42      	ittt	mi
 8002524:	6ba3      	ldrmi	r3, [r4, #56]	; 0x38
 8002526:	f043 0308 	orrmi.w	r3, r3, #8
 800252a:	63a3      	strmi	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXOVERR) != RESET)
 800252c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800252e:	069d      	lsls	r5, r3, #26
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN; 
 8002530:	bf42      	ittt	mi
 8002532:	6ba3      	ldrmi	r3, [r4, #56]	; 0x38
 8002534:	f043 0320 	orrmi.w	r3, r3, #32
 8002538:	63a3      	strmi	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXUNDERR) != RESET)
 800253a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800253c:	06d9      	lsls	r1, r3, #27
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN; 
 800253e:	bf42      	ittt	mi
 8002540:	6ba3      	ldrmi	r3, [r4, #56]	; 0x38
 8002542:	f043 0310 	orrmi.w	r3, r3, #16
 8002546:	63a3      	strmi	r3, [r4, #56]	; 0x38
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002548:	f240 53ff 	movw	r3, #1535	; 0x5ff
 800254c:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 800254e:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8002550:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
 8002554:	63c3      	str	r3, [r0, #60]	; 0x3c
    if((hsd->Context & SD_CONTEXT_DMA) != RESET)
 8002556:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002558:	061a      	lsls	r2, r3, #24
 800255a:	d51f      	bpl.n	800259c <HAL_SD_IRQHandler+0x18c>
      if(hsd->hdmatx != NULL)
 800255c:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800255e:	b148      	cbz	r0, 8002574 <HAL_SD_IRQHandler+0x164>
        hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
 8002560:	4b13      	ldr	r3, [pc, #76]	; (80025b0 <HAL_SD_IRQHandler+0x1a0>)
 8002562:	6503      	str	r3, [r0, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
 8002564:	f7fe fb8a 	bl	8000c7c <HAL_DMA_Abort_IT>
 8002568:	b308      	cbz	r0, 80025ae <HAL_SD_IRQHandler+0x19e>
          SD_DMATxAbort(hsd->hdmatx);
 800256a:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
 800256c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          SD_DMATxAbort(hsd->hdmatx);
 8002570:	f7ff bf0a 	b.w	8002388 <SD_DMATxAbort>
      else if(hsd->hdmarx != NULL)
 8002574:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8002576:	b148      	cbz	r0, 800258c <HAL_SD_IRQHandler+0x17c>
        hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
 8002578:	4b0e      	ldr	r3, [pc, #56]	; (80025b4 <HAL_SD_IRQHandler+0x1a4>)
 800257a:	6503      	str	r3, [r0, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
 800257c:	f7fe fb7e 	bl	8000c7c <HAL_DMA_Abort_IT>
 8002580:	b1a8      	cbz	r0, 80025ae <HAL_SD_IRQHandler+0x19e>
          SD_DMARxAbort(hsd->hdmarx);
 8002582:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 8002584:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          SD_DMARxAbort(hsd->hdmarx);
 8002588:	f7ff bf20 	b.w	80023cc <SD_DMARxAbort>
        hsd->State = HAL_SD_STATE_READY;
 800258c:	2301      	movs	r3, #1
        hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800258e:	63a0      	str	r0, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 8002590:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        HAL_SD_AbortCallback(hsd);
 8002594:	4620      	mov	r0, r4
 8002596:	f003 f992 	bl	80058be <HAL_SD_AbortCallback>
 800259a:	bd70      	pop	{r4, r5, r6, pc}
    else if((hsd->Context & SD_CONTEXT_IT) != RESET)
 800259c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800259e:	071b      	lsls	r3, r3, #28
 80025a0:	d505      	bpl.n	80025ae <HAL_SD_IRQHandler+0x19e>
      hsd->State = HAL_SD_STATE_READY;
 80025a2:	2301      	movs	r3, #1
 80025a4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      HAL_SD_ErrorCallback(hsd);
 80025a8:	4620      	mov	r0, r4
 80025aa:	f7ff fc13 	bl	8001dd4 <HAL_SD_ErrorCallback>
 80025ae:	bd70      	pop	{r4, r5, r6, pc}
 80025b0:	08002389 	.word	0x08002389
 80025b4:	080023cd 	.word	0x080023cd

080025b8 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80025b8:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80025ba:	4604      	mov	r4, r0
 80025bc:	2800      	cmp	r0, #0
 80025be:	d036      	beq.n	800262e <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80025c0:	2300      	movs	r3, #0
 80025c2:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 80025c4:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80025c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80025cc:	b91b      	cbnz	r3, 80025d6 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80025ce:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80025d2:	f003 fea5 	bl	8006320 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80025d6:	6821      	ldr	r1, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80025d8:	68a0      	ldr	r0, [r4, #8]
 80025da:	69a2      	ldr	r2, [r4, #24]
  hspi->State = HAL_SPI_STATE_BUSY;
 80025dc:	2302      	movs	r3, #2
 80025de:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 80025e2:	680b      	ldr	r3, [r1, #0]
 80025e4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80025e8:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80025ea:	6863      	ldr	r3, [r4, #4]
 80025ec:	4303      	orrs	r3, r0
 80025ee:	68e0      	ldr	r0, [r4, #12]
 80025f0:	4303      	orrs	r3, r0
 80025f2:	6920      	ldr	r0, [r4, #16]
 80025f4:	4303      	orrs	r3, r0
 80025f6:	6960      	ldr	r0, [r4, #20]
 80025f8:	4303      	orrs	r3, r0
 80025fa:	69e0      	ldr	r0, [r4, #28]
 80025fc:	4303      	orrs	r3, r0
 80025fe:	6a20      	ldr	r0, [r4, #32]
 8002600:	4303      	orrs	r3, r0
 8002602:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8002604:	4303      	orrs	r3, r0
 8002606:	f402 7000 	and.w	r0, r2, #512	; 0x200
 800260a:	4303      	orrs	r3, r0
 800260c:	600b      	str	r3, [r1, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 800260e:	0c12      	lsrs	r2, r2, #16
 8002610:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002612:	f002 0204 	and.w	r2, r2, #4
 8002616:	431a      	orrs	r2, r3
 8002618:	604a      	str	r2, [r1, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800261a:	69cb      	ldr	r3, [r1, #28]
 800261c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002620:	61cb      	str	r3, [r1, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002622:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8002624:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002626:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8002628:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 800262c:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800262e:	2001      	movs	r0, #1
}
 8002630:	bd10      	pop	{r4, pc}
	...

08002634 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;  

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002634:	6a03      	ldr	r3, [r0, #32]
 8002636:	f023 0301 	bic.w	r3, r3, #1
 800263a:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800263c:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800263e:	6842      	ldr	r2, [r0, #4]
{
 8002640:	b570      	push	{r4, r5, r6, lr}
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8002642:	6984      	ldr	r4, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8002644:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8002646:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800264a:	4325      	orrs	r5, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800264c:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 800264e:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 8002652:	4323      	orrs	r3, r4

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8002654:	4c0c      	ldr	r4, [pc, #48]	; (8002688 <TIM_OC1_SetConfig+0x54>)
 8002656:	42a0      	cmp	r0, r4
 8002658:	d009      	beq.n	800266e <TIM_OC1_SetConfig+0x3a>
 800265a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 800265e:	42a0      	cmp	r0, r4
 8002660:	d005      	beq.n	800266e <TIM_OC1_SetConfig+0x3a>
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002662:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8002664:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8002666:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8002668:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800266a:	6203      	str	r3, [r0, #32]
} 
 800266c:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= OC_Config->OCNPolarity;
 800266e:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= OC_Config->OCNIdleState;
 8002670:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC1NP;
 8002672:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8002676:	4323      	orrs	r3, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8002678:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800267a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 800267e:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC1NE;
 8002680:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8002684:	4322      	orrs	r2, r4
 8002686:	e7ec      	b.n	8002662 <TIM_OC1_SetConfig+0x2e>
 8002688:	40010000 	.word	0x40010000

0800268c <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800268c:	6a03      	ldr	r3, [r0, #32]
 800268e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002692:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002694:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8002696:	6842      	ldr	r2, [r0, #4]
{
 8002698:	b570      	push	{r4, r5, r6, lr}
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800269a:	69c4      	ldr	r4, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800269c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 800269e:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80026a2:	4325      	orrs	r5, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80026a4:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 80026a6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80026aa:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 80026ae:	4c0e      	ldr	r4, [pc, #56]	; (80026e8 <TIM_OC3_SetConfig+0x5c>)
 80026b0:	42a0      	cmp	r0, r4
 80026b2:	d009      	beq.n	80026c8 <TIM_OC3_SetConfig+0x3c>
 80026b4:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80026b8:	42a0      	cmp	r0, r4
 80026ba:	d005      	beq.n	80026c8 <TIM_OC3_SetConfig+0x3c>
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80026bc:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 80026be:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 80026c0:	61c5      	str	r5, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 80026c2:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80026c4:	6203      	str	r3, [r0, #32]
}
 80026c6:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80026c8:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80026ca:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC3NP;
 80026cc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80026d0:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 80026d4:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80026d6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80026da:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC3NE;
 80026dc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80026e0:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
 80026e4:	e7ea      	b.n	80026bc <TIM_OC3_SetConfig+0x30>
 80026e6:	bf00      	nop
 80026e8:	40010000 	.word	0x40010000

080026ec <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80026ec:	6a03      	ldr	r3, [r0, #32]
 80026ee:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80026f2:	6203      	str	r3, [r0, #32]
{
 80026f4:	b530      	push	{r4, r5, lr}
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80026f6:	6a04      	ldr	r4, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 80026f8:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80026fa:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80026fc:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80026fe:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002702:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8002706:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 8002708:	f424 5400 	bic.w	r4, r4, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800270c:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8002710:	4d09      	ldr	r5, [pc, #36]	; (8002738 <TIM_OC4_SetConfig+0x4c>)
 8002712:	42a8      	cmp	r0, r5
 8002714:	d009      	beq.n	800272a <TIM_OC4_SetConfig+0x3e>
 8002716:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800271a:	42a8      	cmp	r0, r5
 800271c:	d005      	beq.n	800272a <TIM_OC4_SetConfig+0x3e>
    tmpcr2 &= ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800271e:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8002720:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8002722:	61c2      	str	r2, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8002724:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002726:	6204      	str	r4, [r0, #32]
}
 8002728:	bd30      	pop	{r4, r5, pc}
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800272a:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 800272c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8002730:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8002734:	e7f3      	b.n	800271e <TIM_OC4_SetConfig+0x32>
 8002736:	bf00      	nop
 8002738:	40010000 	.word	0x40010000

0800273c <TIM_SlaveTimer_SetConfig>:
  uint32_t tmpsmcr = 0U;
  uint32_t tmpccmr1 = 0U;
  uint32_t tmpccer = 0U;

 /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800273c:	6803      	ldr	r3, [r0, #0]

  /* Reset the Trigger Selection Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
  /* Set the Input Trigger source */
  tmpsmcr |= sSlaveConfig->InputTrigger;
 800273e:	6848      	ldr	r0, [r1, #4]
  tmpsmcr = htim->Instance->SMCR;
 8002740:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002742:	f022 0270 	bic.w	r2, r2, #112	; 0x70
{
 8002746:	b530      	push	{r4, r5, lr}
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8002748:	4302      	orrs	r2, r0

  /* Reset the slave mode Bits */
  tmpsmcr &= ~TIM_SMCR_SMS;
  /* Set the slave mode */
  tmpsmcr |= sSlaveConfig->SlaveMode;
 800274a:	680c      	ldr	r4, [r1, #0]
  tmpsmcr &= ~TIM_SMCR_SMS;
 800274c:	f022 0207 	bic.w	r2, r2, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8002750:	4322      	orrs	r2, r4

  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
  
  /* Configure the trigger prescaler, filter, and polarity */
  switch (sSlaveConfig->InputTrigger)
 8002752:	2850      	cmp	r0, #80	; 0x50
  htim->Instance->SMCR = tmpsmcr;
 8002754:	609a      	str	r2, [r3, #8]
  switch (sSlaveConfig->InputTrigger)
 8002756:	d021      	beq.n	800279c <TIM_SlaveTimer_SetConfig+0x60>
 8002758:	d802      	bhi.n	8002760 <TIM_SlaveTimer_SetConfig+0x24>
 800275a:	2840      	cmp	r0, #64	; 0x40
 800275c:	d010      	beq.n	8002780 <TIM_SlaveTimer_SetConfig+0x44>
 800275e:	bd30      	pop	{r4, r5, pc}
 8002760:	2860      	cmp	r0, #96	; 0x60
 8002762:	d02d      	beq.n	80027c0 <TIM_SlaveTimer_SetConfig+0x84>
 8002764:	2870      	cmp	r0, #112	; 0x70
 8002766:	d13d      	bne.n	80027e4 <TIM_SlaveTimer_SetConfig+0xa8>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 8002768:	68ca      	ldr	r2, [r1, #12]
 800276a:	688c      	ldr	r4, [r1, #8]
  tmpsmcr = TIMx->SMCR;
 800276c:	6898      	ldr	r0, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 800276e:	6909      	ldr	r1, [r1, #16]
 8002770:	4322      	orrs	r2, r4
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002772:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 8002776:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800277a:	4302      	orrs	r2, r0

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800277c:	609a      	str	r2, [r3, #8]
 800277e:	bd30      	pop	{r4, r5, pc}
      tmpccer = htim->Instance->CCER;
 8002780:	6a18      	ldr	r0, [r3, #32]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 8002782:	6a1a      	ldr	r2, [r3, #32]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 8002784:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 8002786:	f022 0201 	bic.w	r2, r2, #1
 800278a:	621a      	str	r2, [r3, #32]
      tmpccmr1 = htim->Instance->CCMR1;    
 800278c:	699a      	ldr	r2, [r3, #24]
      tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800278e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 8002792:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
      htim->Instance->CCMR1 = tmpccmr1;
 8002796:	619a      	str	r2, [r3, #24]
      htim->Instance->CCER = tmpccer;                               
 8002798:	6218      	str	r0, [r3, #32]
    break;
 800279a:	bd30      	pop	{r4, r5, pc}
      TIM_TI1_ConfigInputStage(htim->Instance,
 800279c:	6888      	ldr	r0, [r1, #8]
 800279e:	690d      	ldr	r5, [r1, #16]
  tmpccer = TIMx->CCER;
 80027a0:	6a19      	ldr	r1, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80027a2:	6a1c      	ldr	r4, [r3, #32]
 80027a4:	f024 0401 	bic.w	r4, r4, #1
 80027a8:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;    
 80027aa:	699a      	ldr	r2, [r3, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 80027ac:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80027b0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80027b4:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  tmpccer |= TIM_ICPolarity;
 80027b8:	4301      	orrs	r1, r0
  TIMx->CCMR1 = tmpccmr1;
 80027ba:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 80027bc:	6219      	str	r1, [r3, #32]
 80027be:	bd30      	pop	{r4, r5, pc}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80027c0:	6a18      	ldr	r0, [r3, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 80027c2:	688c      	ldr	r4, [r1, #8]
 80027c4:	690d      	ldr	r5, [r1, #16]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80027c6:	f020 0010 	bic.w	r0, r0, #16
 80027ca:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 80027cc:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 80027ce:	6a1a      	ldr	r2, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80027d0:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80027d4:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 80027d8:	ea41 3105 	orr.w	r1, r1, r5, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 80027dc:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 80027e0:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 80027e2:	621a      	str	r2, [r3, #32]
 80027e4:	bd30      	pop	{r4, r5, pc}

080027e6 <HAL_TIM_OC_MspInit>:
 80027e6:	4770      	bx	lr

080027e8 <HAL_TIM_IC_MspInit>:
 80027e8:	4770      	bx	lr

080027ea <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 80027ea:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 80027ee:	2b01      	cmp	r3, #1
{
 80027f0:	b570      	push	{r4, r5, r6, lr}
 80027f2:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 80027f6:	d01c      	beq.n	8002832 <HAL_TIM_ConfigClockSource+0x48>
  htim->State = HAL_TIM_STATE_BUSY;
 80027f8:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  tmpsmcr = htim->Instance->SMCR;
 80027fc:	6803      	ldr	r3, [r0, #0]
  __HAL_LOCK(htim);
 80027fe:	2201      	movs	r2, #1
 8002800:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
  tmpsmcr = htim->Instance->SMCR;
 8002804:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002806:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800280a:	f022 0277 	bic.w	r2, r2, #119	; 0x77
  htim->Instance->SMCR = tmpsmcr;
 800280e:	609a      	str	r2, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 8002810:	680a      	ldr	r2, [r1, #0]
 8002812:	2a40      	cmp	r2, #64	; 0x40
 8002814:	d079      	beq.n	800290a <HAL_TIM_ConfigClockSource+0x120>
 8002816:	d819      	bhi.n	800284c <HAL_TIM_ConfigClockSource+0x62>
 8002818:	2a10      	cmp	r2, #16
 800281a:	f000 8093 	beq.w	8002944 <HAL_TIM_ConfigClockSource+0x15a>
 800281e:	d80a      	bhi.n	8002836 <HAL_TIM_ConfigClockSource+0x4c>
 8002820:	2a00      	cmp	r2, #0
 8002822:	f000 8089 	beq.w	8002938 <HAL_TIM_ConfigClockSource+0x14e>
  htim->State = HAL_TIM_STATE_READY;
 8002826:	2301      	movs	r3, #1
 8002828:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_UNLOCK(htim);
 800282c:	2300      	movs	r3, #0
 800282e:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  __HAL_LOCK(htim);
 8002832:	4618      	mov	r0, r3
}
 8002834:	bd70      	pop	{r4, r5, r6, pc}
  switch (sClockSourceConfig->ClockSource)
 8002836:	2a20      	cmp	r2, #32
 8002838:	f000 808a 	beq.w	8002950 <HAL_TIM_ConfigClockSource+0x166>
 800283c:	2a30      	cmp	r2, #48	; 0x30
 800283e:	d1f2      	bne.n	8002826 <HAL_TIM_ConfigClockSource+0x3c>
   tmpsmcr = TIMx->SMCR;
 8002840:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8002842:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 8002846:	f042 0237 	orr.w	r2, r2, #55	; 0x37
 800284a:	e036      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
  switch (sClockSourceConfig->ClockSource)
 800284c:	2a70      	cmp	r2, #112	; 0x70
 800284e:	d036      	beq.n	80028be <HAL_TIM_ConfigClockSource+0xd4>
 8002850:	d81b      	bhi.n	800288a <HAL_TIM_ConfigClockSource+0xa0>
 8002852:	2a50      	cmp	r2, #80	; 0x50
 8002854:	d042      	beq.n	80028dc <HAL_TIM_ConfigClockSource+0xf2>
 8002856:	2a60      	cmp	r2, #96	; 0x60
 8002858:	d1e5      	bne.n	8002826 <HAL_TIM_ConfigClockSource+0x3c>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800285a:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI2_ConfigInputStage(htim->Instance, 
 800285c:	684d      	ldr	r5, [r1, #4]
 800285e:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002860:	f024 0410 	bic.w	r4, r4, #16
 8002864:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002866:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 8002868:	6a1a      	ldr	r2, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800286a:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800286e:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8002872:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8002876:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 800287a:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 800287c:	621a      	str	r2, [r3, #32]
   tmpsmcr = TIMx->SMCR;
 800287e:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8002880:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 8002884:	f042 0267 	orr.w	r2, r2, #103	; 0x67
 8002888:	e017      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
  switch (sClockSourceConfig->ClockSource)
 800288a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800288e:	d011      	beq.n	80028b4 <HAL_TIM_ConfigClockSource+0xca>
 8002890:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002894:	d1c7      	bne.n	8002826 <HAL_TIM_ConfigClockSource+0x3c>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 8002896:	688a      	ldr	r2, [r1, #8]
 8002898:	684d      	ldr	r5, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 800289a:	689c      	ldr	r4, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 800289c:	68c9      	ldr	r1, [r1, #12]
 800289e:	432a      	orrs	r2, r5
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80028a0:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 80028a4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80028a8:	4322      	orrs	r2, r4
  TIMx->SMCR = tmpsmcr;
 80028aa:	609a      	str	r2, [r3, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80028ac:	689a      	ldr	r2, [r3, #8]
 80028ae:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80028b2:	e002      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 80028b4:	689a      	ldr	r2, [r3, #8]
 80028b6:	f022 0207 	bic.w	r2, r2, #7
   TIMx->SMCR = tmpsmcr;
 80028ba:	609a      	str	r2, [r3, #8]
 80028bc:	e7b3      	b.n	8002826 <HAL_TIM_ConfigClockSource+0x3c>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 80028be:	688a      	ldr	r2, [r1, #8]
 80028c0:	684d      	ldr	r5, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 80028c2:	689c      	ldr	r4, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 80028c4:	68c9      	ldr	r1, [r1, #12]
 80028c6:	432a      	orrs	r2, r5
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80028c8:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 80028cc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80028d0:	4322      	orrs	r2, r4
  TIMx->SMCR = tmpsmcr;
 80028d2:	609a      	str	r2, [r3, #8]
      tmpsmcr = htim->Instance->SMCR;
 80028d4:	689a      	ldr	r2, [r3, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 80028d6:	f042 0277 	orr.w	r2, r2, #119	; 0x77
 80028da:	e7ee      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
      TIM_TI1_ConfigInputStage(htim->Instance, 
 80028dc:	684c      	ldr	r4, [r1, #4]
 80028de:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 80028e0:	6a19      	ldr	r1, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80028e2:	6a1d      	ldr	r5, [r3, #32]
 80028e4:	f025 0501 	bic.w	r5, r5, #1
 80028e8:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;    
 80028ea:	699a      	ldr	r2, [r3, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 80028ec:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80028f0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80028f4:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 80028f8:	4321      	orrs	r1, r4
  TIMx->CCMR1 = tmpccmr1;
 80028fa:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 80028fc:	6219      	str	r1, [r3, #32]
   tmpsmcr = TIMx->SMCR;
 80028fe:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8002900:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 8002904:	f042 0257 	orr.w	r2, r2, #87	; 0x57
 8002908:	e7d7      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
      TIM_TI1_ConfigInputStage(htim->Instance, 
 800290a:	684c      	ldr	r4, [r1, #4]
 800290c:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 800290e:	6a19      	ldr	r1, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002910:	6a1d      	ldr	r5, [r3, #32]
 8002912:	f025 0501 	bic.w	r5, r5, #1
 8002916:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;    
 8002918:	699a      	ldr	r2, [r3, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800291a:	f021 010a 	bic.w	r1, r1, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800291e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8002922:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
  tmpccer |= TIM_ICPolarity;
 8002926:	4321      	orrs	r1, r4
  TIMx->CCMR1 = tmpccmr1;
 8002928:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800292a:	6219      	str	r1, [r3, #32]
   tmpsmcr = TIMx->SMCR;
 800292c:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 800292e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 8002932:	f042 0247 	orr.w	r2, r2, #71	; 0x47
 8002936:	e7c0      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
   tmpsmcr = TIMx->SMCR;
 8002938:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 800293a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 800293e:	f042 0207 	orr.w	r2, r2, #7
 8002942:	e7ba      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
   tmpsmcr = TIMx->SMCR;
 8002944:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8002946:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 800294a:	f042 0217 	orr.w	r2, r2, #23
 800294e:	e7b4      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>
   tmpsmcr = TIMx->SMCR;
 8002950:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8002952:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
 8002956:	f042 0227 	orr.w	r2, r2, #39	; 0x27
 800295a:	e7ae      	b.n	80028ba <HAL_TIM_ConfigClockSource+0xd0>

0800295c <HAL_TIM_SlaveConfigSynchronization>:
{
 800295c:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 800295e:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002962:	2b01      	cmp	r3, #1
{
 8002964:	4604      	mov	r4, r0
 8002966:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 800296a:	d015      	beq.n	8002998 <HAL_TIM_SlaveConfigSynchronization+0x3c>
 800296c:	2501      	movs	r5, #1
 800296e:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
  htim->State = HAL_TIM_STATE_BUSY;
 8002972:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
 8002976:	f7ff fee1 	bl	800273c <TIM_SlaveTimer_SetConfig>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
 800297a:	6823      	ldr	r3, [r4, #0]
 800297c:	68da      	ldr	r2, [r3, #12]
 800297e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002982:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8002984:	68da      	ldr	r2, [r3, #12]
  __HAL_UNLOCK(htim);  
 8002986:	2000      	movs	r0, #0
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8002988:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800298c:	60da      	str	r2, [r3, #12]
  htim->State = HAL_TIM_STATE_READY;
 800298e:	f884 5039 	strb.w	r5, [r4, #57]	; 0x39
  __HAL_UNLOCK(htim);  
 8002992:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
  return HAL_OK;
 8002996:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(htim);
 8002998:	4618      	mov	r0, r3
} 
 800299a:	bd38      	pop	{r3, r4, r5, pc}

0800299c <TIM_Base_SetConfig>:
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 800299c:	4a2e      	ldr	r2, [pc, #184]	; (8002a58 <TIM_Base_SetConfig+0xbc>)
  tmpcr1 = TIMx->CR1;
 800299e:	6803      	ldr	r3, [r0, #0]
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 80029a0:	4290      	cmp	r0, r2
 80029a2:	d012      	beq.n	80029ca <TIM_Base_SetConfig+0x2e>
 80029a4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80029a8:	d00f      	beq.n	80029ca <TIM_Base_SetConfig+0x2e>
 80029aa:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 80029ae:	4290      	cmp	r0, r2
 80029b0:	d00b      	beq.n	80029ca <TIM_Base_SetConfig+0x2e>
 80029b2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80029b6:	4290      	cmp	r0, r2
 80029b8:	d007      	beq.n	80029ca <TIM_Base_SetConfig+0x2e>
 80029ba:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80029be:	4290      	cmp	r0, r2
 80029c0:	d003      	beq.n	80029ca <TIM_Base_SetConfig+0x2e>
 80029c2:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 80029c6:	4290      	cmp	r0, r2
 80029c8:	d11d      	bne.n	8002a06 <TIM_Base_SetConfig+0x6a>
    tmpcr1 |= Structure->CounterMode;
 80029ca:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80029cc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80029d0:	4313      	orrs	r3, r2
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 80029d2:	4a21      	ldr	r2, [pc, #132]	; (8002a58 <TIM_Base_SetConfig+0xbc>)
 80029d4:	4290      	cmp	r0, r2
 80029d6:	d104      	bne.n	80029e2 <TIM_Base_SetConfig+0x46>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80029d8:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 80029da:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80029de:	4313      	orrs	r3, r2
 80029e0:	e028      	b.n	8002a34 <TIM_Base_SetConfig+0x98>
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 80029e2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80029e6:	d0f7      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 80029e8:	4a1c      	ldr	r2, [pc, #112]	; (8002a5c <TIM_Base_SetConfig+0xc0>)
 80029ea:	4290      	cmp	r0, r2
 80029ec:	d0f4      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 80029ee:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80029f2:	4290      	cmp	r0, r2
 80029f4:	d0f0      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 80029f6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80029fa:	4290      	cmp	r0, r2
 80029fc:	d0ec      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 80029fe:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002a02:	4290      	cmp	r0, r2
 8002a04:	d0e8      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a06:	4a16      	ldr	r2, [pc, #88]	; (8002a60 <TIM_Base_SetConfig+0xc4>)
 8002a08:	4290      	cmp	r0, r2
 8002a0a:	d0e5      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a0c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002a10:	4290      	cmp	r0, r2
 8002a12:	d0e1      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a14:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002a18:	4290      	cmp	r0, r2
 8002a1a:	d0dd      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a1c:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8002a20:	4290      	cmp	r0, r2
 8002a22:	d0d9      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a24:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002a28:	4290      	cmp	r0, r2
 8002a2a:	d0d5      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
 8002a2c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002a30:	4290      	cmp	r0, r2
 8002a32:	d0d1      	beq.n	80029d8 <TIM_Base_SetConfig+0x3c>
  TIMx->CR1 = tmpcr1;
 8002a34:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002a36:	688b      	ldr	r3, [r1, #8]
 8002a38:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002a3a:	680b      	ldr	r3, [r1, #0]
 8002a3c:	6283      	str	r3, [r0, #40]	; 0x28
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 8002a3e:	4b06      	ldr	r3, [pc, #24]	; (8002a58 <TIM_Base_SetConfig+0xbc>)
 8002a40:	4298      	cmp	r0, r3
 8002a42:	d006      	beq.n	8002a52 <TIM_Base_SetConfig+0xb6>
 8002a44:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002a48:	4298      	cmp	r0, r3
 8002a4a:	d002      	beq.n	8002a52 <TIM_Base_SetConfig+0xb6>
  TIMx->EGR = TIM_EGR_UG;
 8002a4c:	2301      	movs	r3, #1
 8002a4e:	6143      	str	r3, [r0, #20]
}
 8002a50:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 8002a52:	690b      	ldr	r3, [r1, #16]
 8002a54:	6303      	str	r3, [r0, #48]	; 0x30
 8002a56:	e7f9      	b.n	8002a4c <TIM_Base_SetConfig+0xb0>
 8002a58:	40010000 	.word	0x40010000
 8002a5c:	40000400 	.word	0x40000400
 8002a60:	40014000 	.word	0x40014000

08002a64 <HAL_TIM_Base_Init>:
{ 
 8002a64:	b510      	push	{r4, lr}
  if(htim == NULL)
 8002a66:	4604      	mov	r4, r0
 8002a68:	b1a0      	cbz	r0, 8002a94 <HAL_TIM_Base_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8002a6a:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002a6e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002a72:	b91b      	cbnz	r3, 8002a7c <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8002a74:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_Base_MspInit(htim);
 8002a78:	f003 fe1e 	bl	80066b8 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8002a7c:	2302      	movs	r3, #2
 8002a7e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8002a82:	6820      	ldr	r0, [r4, #0]
 8002a84:	1d21      	adds	r1, r4, #4
 8002a86:	f7ff ff89 	bl	800299c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8002a8a:	2301      	movs	r3, #1
 8002a8c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8002a90:	2000      	movs	r0, #0
 8002a92:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002a94:	2001      	movs	r0, #1
}
 8002a96:	bd10      	pop	{r4, pc}

08002a98 <HAL_TIM_OC_Init>:
{
 8002a98:	b510      	push	{r4, lr}
  if(htim == NULL)
 8002a9a:	4604      	mov	r4, r0
 8002a9c:	b1a0      	cbz	r0, 8002ac8 <HAL_TIM_OC_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8002a9e:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002aa2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002aa6:	b91b      	cbnz	r3, 8002ab0 <HAL_TIM_OC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8002aa8:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_OC_MspInit(htim);
 8002aac:	f7ff fe9b 	bl	80027e6 <HAL_TIM_OC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8002ab0:	2302      	movs	r3, #2
 8002ab2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
 8002ab6:	6820      	ldr	r0, [r4, #0]
 8002ab8:	1d21      	adds	r1, r4, #4
 8002aba:	f7ff ff6f 	bl	800299c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8002abe:	2301      	movs	r3, #1
 8002ac0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8002ac4:	2000      	movs	r0, #0
 8002ac6:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002ac8:	2001      	movs	r0, #1
}
 8002aca:	bd10      	pop	{r4, pc}

08002acc <HAL_TIM_IC_Init>:
{
 8002acc:	b510      	push	{r4, lr}
  if(htim == NULL)
 8002ace:	4604      	mov	r4, r0
 8002ad0:	b1a0      	cbz	r0, 8002afc <HAL_TIM_IC_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8002ad2:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002ad6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002ada:	b91b      	cbnz	r3, 8002ae4 <HAL_TIM_IC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8002adc:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_IC_MspInit(htim);
 8002ae0:	f7ff fe82 	bl	80027e8 <HAL_TIM_IC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;   
 8002ae4:	2302      	movs	r3, #2
 8002ae6:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8002aea:	6820      	ldr	r0, [r4, #0]
 8002aec:	1d21      	adds	r1, r4, #4
 8002aee:	f7ff ff55 	bl	800299c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8002af2:	2301      	movs	r3, #1
 8002af4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8002af8:	2000      	movs	r0, #0
 8002afa:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002afc:	2001      	movs	r0, #1
}
 8002afe:	bd10      	pop	{r4, pc}

08002b00 <TIM_TI1_SetConfig>:
{
 8002b00:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002b02:	6a04      	ldr	r4, [r0, #32]
  if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8002b04:	4e1a      	ldr	r6, [pc, #104]	; (8002b70 <TIM_TI1_SetConfig+0x70>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002b06:	f024 0401 	bic.w	r4, r4, #1
 8002b0a:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002b0c:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8002b0e:	6a05      	ldr	r5, [r0, #32]
  if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8002b10:	42b0      	cmp	r0, r6
 8002b12:	f024 0403 	bic.w	r4, r4, #3
 8002b16:	d01a      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b18:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002b1c:	d017      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b1e:	f5a6 467c 	sub.w	r6, r6, #64512	; 0xfc00
 8002b22:	42b0      	cmp	r0, r6
 8002b24:	d013      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b26:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002b2a:	42b0      	cmp	r0, r6
 8002b2c:	d00f      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b2e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002b32:	42b0      	cmp	r0, r6
 8002b34:	d00b      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b36:	f506 4678 	add.w	r6, r6, #63488	; 0xf800
 8002b3a:	42b0      	cmp	r0, r6
 8002b3c:	d007      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b3e:	f506 5670 	add.w	r6, r6, #15360	; 0x3c00
 8002b42:	42b0      	cmp	r0, r6
 8002b44:	d003      	beq.n	8002b4e <TIM_TI1_SetConfig+0x4e>
 8002b46:	f5a6 3694 	sub.w	r6, r6, #75776	; 0x12800
 8002b4a:	42b0      	cmp	r0, r6
 8002b4c:	d10d      	bne.n	8002b6a <TIM_TI1_SetConfig+0x6a>
    tmpccmr1 |= TIM_ICSelection;
 8002b4e:	4322      	orrs	r2, r4
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8002b50:	011b      	lsls	r3, r3, #4
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8002b52:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8002b56:	b2db      	uxtb	r3, r3
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002b58:	f025 050a 	bic.w	r5, r5, #10
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8002b5c:	f001 010a 	and.w	r1, r1, #10
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8002b60:	431a      	orrs	r2, r3
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8002b62:	4329      	orrs	r1, r5
  TIMx->CCMR1 = tmpccmr1;
 8002b64:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8002b66:	6201      	str	r1, [r0, #32]
}
 8002b68:	bd70      	pop	{r4, r5, r6, pc}
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 8002b6a:	f044 0201 	orr.w	r2, r4, #1
 8002b6e:	e7ef      	b.n	8002b50 <TIM_TI1_SetConfig+0x50>
 8002b70:	40010000 	.word	0x40010000

08002b74 <HAL_TIM_IC_ConfigChannel>:
{
 8002b74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 8002b76:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002b7a:	2b01      	cmp	r3, #1
{
 8002b7c:	4604      	mov	r4, r0
 8002b7e:	460d      	mov	r5, r1
 8002b80:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 8002b84:	d019      	beq.n	8002bba <HAL_TIM_IC_ConfigChannel+0x46>
 8002b86:	2301      	movs	r3, #1
 8002b88:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  htim->State = HAL_TIM_STATE_BUSY;
 8002b8c:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
  if (Channel == TIM_CHANNEL_1)
 8002b90:	b9a2      	cbnz	r2, 8002bbc <HAL_TIM_IC_ConfigChannel+0x48>
    TIM_TI1_SetConfig(htim->Instance,
 8002b92:	68cb      	ldr	r3, [r1, #12]
 8002b94:	6820      	ldr	r0, [r4, #0]
 8002b96:	c906      	ldmia	r1, {r1, r2}
 8002b98:	f7ff ffb2 	bl	8002b00 <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8002b9c:	6823      	ldr	r3, [r4, #0]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8002b9e:	68a9      	ldr	r1, [r5, #8]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8002ba0:	699a      	ldr	r2, [r3, #24]
 8002ba2:	f022 020c 	bic.w	r2, r2, #12
 8002ba6:	619a      	str	r2, [r3, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8002ba8:	699a      	ldr	r2, [r3, #24]
 8002baa:	430a      	orrs	r2, r1
 8002bac:	619a      	str	r2, [r3, #24]
  htim->State = HAL_TIM_STATE_READY;
 8002bae:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8002bb0:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8002bb2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UNLOCK(htim);
 8002bb6:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
}
 8002bba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Channel == TIM_CHANNEL_2)
 8002bbc:	2a04      	cmp	r2, #4
 8002bbe:	688e      	ldr	r6, [r1, #8]
 8002bc0:	6823      	ldr	r3, [r4, #0]
 8002bc2:	68e8      	ldr	r0, [r5, #12]
 8002bc4:	c982      	ldmia	r1, {r1, r7}
 8002bc6:	d11f      	bne.n	8002c08 <HAL_TIM_IC_ConfigChannel+0x94>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002bc8:	6a1a      	ldr	r2, [r3, #32]
 8002bca:	f022 0210 	bic.w	r2, r2, #16
 8002bce:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002bd0:	699a      	ldr	r2, [r3, #24]
  tmpccer = TIMx->CCER;
 8002bd2:	6a1d      	ldr	r5, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 8002bd4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr1 |= (TIM_ICSelection << 8U);
 8002bd8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 8002bdc:	0300      	lsls	r0, r0, #12
 8002bde:	b280      	uxth	r0, r0
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8002be0:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8002be4:	0109      	lsls	r1, r1, #4
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 8002be6:	4302      	orrs	r2, r0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8002be8:	f001 01a0 	and.w	r1, r1, #160	; 0xa0
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002bec:	f025 00a0 	bic.w	r0, r5, #160	; 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8002bf0:	4301      	orrs	r1, r0
  TIMx->CCMR1 = tmpccmr1 ;
 8002bf2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8002bf4:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 8002bf6:	699a      	ldr	r2, [r3, #24]
 8002bf8:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8002bfc:	619a      	str	r2, [r3, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 8002bfe:	699a      	ldr	r2, [r3, #24]
 8002c00:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
 8002c04:	619e      	str	r6, [r3, #24]
 8002c06:	e7d2      	b.n	8002bae <HAL_TIM_IC_ConfigChannel+0x3a>
  else if (Channel == TIM_CHANNEL_3)
 8002c08:	2a08      	cmp	r2, #8
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002c0a:	6a1a      	ldr	r2, [r3, #32]
  else if (Channel == TIM_CHANNEL_3)
 8002c0c:	d11c      	bne.n	8002c48 <HAL_TIM_IC_ConfigChannel+0xd4>
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002c0e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002c12:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8002c14:	69da      	ldr	r2, [r3, #28]
  tmpccer = TIMx->CCER;
 8002c16:	6a1d      	ldr	r5, [r3, #32]
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 8002c18:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr2 |= TIM_ICSelection;
 8002c1c:	433a      	orrs	r2, r7
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8002c1e:	0100      	lsls	r0, r0, #4
 8002c20:	b2c0      	uxtb	r0, r0
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8002c22:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8002c26:	0209      	lsls	r1, r1, #8
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8002c28:	4302      	orrs	r2, r0
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8002c2a:	f401 6120 	and.w	r1, r1, #2560	; 0xa00
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8002c2e:	f425 6020 	bic.w	r0, r5, #2560	; 0xa00
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8002c32:	4301      	orrs	r1, r0
  TIMx->CCMR2 = tmpccmr2;
 8002c34:	61da      	str	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 8002c36:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8002c38:	69da      	ldr	r2, [r3, #28]
 8002c3a:	f022 020c 	bic.w	r2, r2, #12
 8002c3e:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 8002c40:	69da      	ldr	r2, [r3, #28]
 8002c42:	4316      	orrs	r6, r2
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8002c44:	61de      	str	r6, [r3, #28]
 8002c46:	e7b2      	b.n	8002bae <HAL_TIM_IC_ConfigChannel+0x3a>
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002c48:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8002c4c:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8002c4e:	69da      	ldr	r2, [r3, #28]
  tmpccer = TIMx->CCER;
 8002c50:	6a1d      	ldr	r5, [r3, #32]
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 8002c52:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8002c56:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8002c5a:	0300      	lsls	r0, r0, #12
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8002c5c:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8002c60:	b280      	uxth	r0, r0
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8002c62:	0309      	lsls	r1, r1, #12
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8002c64:	4310      	orrs	r0, r2
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8002c66:	f401 4120 	and.w	r1, r1, #40960	; 0xa000
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8002c6a:	f425 4220 	bic.w	r2, r5, #40960	; 0xa000
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8002c6e:	4311      	orrs	r1, r2
  TIMx->CCMR2 = tmpccmr2;
 8002c70:	61d8      	str	r0, [r3, #28]
  TIMx->CCER = tmpccer ;
 8002c72:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 8002c74:	69da      	ldr	r2, [r3, #28]
 8002c76:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8002c7a:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8002c7c:	69da      	ldr	r2, [r3, #28]
 8002c7e:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
 8002c82:	e7df      	b.n	8002c44 <HAL_TIM_IC_ConfigChannel+0xd0>

08002c84 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002c84:	6a03      	ldr	r3, [r0, #32]
 8002c86:	f023 0310 	bic.w	r3, r3, #16
 8002c8a:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8002c8c:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = TIMx->CR2;
 8002c8e:	6842      	ldr	r2, [r0, #4]
{
 8002c90:	b570      	push	{r4, r5, r6, lr}
  tmpccmrx = TIMx->CCMR1;
 8002c92:	6984      	ldr	r4, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002c94:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8002c96:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002c9a:	ea44 2505 	orr.w	r5, r4, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8002c9e:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 8002ca0:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8002ca4:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8002ca8:	4c0d      	ldr	r4, [pc, #52]	; (8002ce0 <TIM_OC2_SetConfig+0x5c>)
 8002caa:	42a0      	cmp	r0, r4
 8002cac:	d009      	beq.n	8002cc2 <TIM_OC2_SetConfig+0x3e>
 8002cae:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002cb2:	42a0      	cmp	r0, r4
 8002cb4:	d005      	beq.n	8002cc2 <TIM_OC2_SetConfig+0x3e>
  TIMx->CR2 = tmpcr2;
 8002cb6:	6042      	str	r2, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8002cb8:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8002cba:	6185      	str	r5, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8002cbc:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8002cbe:	6203      	str	r3, [r0, #32]
}
 8002cc0:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8002cc2:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002cc4:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC2NP;
 8002cc6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8002cca:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8002cce:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8002cd0:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002cd4:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC2NE;
 8002cd6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002cda:	ea42 0284 	orr.w	r2, r2, r4, lsl #2
 8002cde:	e7ea      	b.n	8002cb6 <TIM_OC2_SetConfig+0x32>
 8002ce0:	40010000 	.word	0x40010000

08002ce4 <HAL_TIM_OC_ConfigChannel>:
{
 8002ce4:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim); 
 8002ce6:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002cea:	2b01      	cmp	r3, #1
{
 8002cec:	4604      	mov	r4, r0
 8002cee:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim); 
 8002cf2:	d018      	beq.n	8002d26 <HAL_TIM_OC_ConfigChannel+0x42>
 8002cf4:	2301      	movs	r3, #1
 8002cf6:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  htim->State = HAL_TIM_STATE_BUSY;
 8002cfa:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
 8002cfe:	461d      	mov	r5, r3
  switch (Channel)
 8002d00:	2a0c      	cmp	r2, #12
 8002d02:	d80b      	bhi.n	8002d1c <HAL_TIM_OC_ConfigChannel+0x38>
 8002d04:	e8df f002 	tbb	[pc, r2]
 8002d08:	0a0a0a07 	.word	0x0a0a0a07
 8002d0c:	0a0a0a10 	.word	0x0a0a0a10
 8002d10:	0a0a0a14 	.word	0x0a0a0a14
 8002d14:	18          	.byte	0x18
 8002d15:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8002d16:	6820      	ldr	r0, [r4, #0]
 8002d18:	f7ff fc8c 	bl	8002634 <TIM_OC1_SetConfig>
  __HAL_UNLOCK(htim); 
 8002d1c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8002d1e:	f884 5039 	strb.w	r5, [r4, #57]	; 0x39
  __HAL_UNLOCK(htim); 
 8002d22:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
}
 8002d26:	bd38      	pop	{r3, r4, r5, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8002d28:	6820      	ldr	r0, [r4, #0]
 8002d2a:	f7ff ffab 	bl	8002c84 <TIM_OC2_SetConfig>
    break;
 8002d2e:	e7f5      	b.n	8002d1c <HAL_TIM_OC_ConfigChannel+0x38>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8002d30:	6820      	ldr	r0, [r4, #0]
 8002d32:	f7ff fcab 	bl	800268c <TIM_OC3_SetConfig>
    break;
 8002d36:	e7f1      	b.n	8002d1c <HAL_TIM_OC_ConfigChannel+0x38>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8002d38:	6820      	ldr	r0, [r4, #0]
 8002d3a:	f7ff fcd7 	bl	80026ec <TIM_OC4_SetConfig>
    break;
 8002d3e:	e7ed      	b.n	8002d1c <HAL_TIM_OC_ConfigChannel+0x38>

08002d40 <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  __HAL_LOCK(htim);
 8002d40:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002d44:	2b01      	cmp	r3, #1
{
 8002d46:	b510      	push	{r4, lr}
 8002d48:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 8002d4c:	d018      	beq.n	8002d80 <HAL_TIMEx_MasterConfigSynchronization+0x40>
  
  htim->State = HAL_TIM_STATE_BUSY;
 8002d4e:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8002d52:	6803      	ldr	r3, [r0, #0]
  /* Select the TRGO source */
  htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
 8002d54:	680c      	ldr	r4, [r1, #0]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8002d56:	685a      	ldr	r2, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8002d58:	6849      	ldr	r1, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8002d5a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8002d5e:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
 8002d60:	685a      	ldr	r2, [r3, #4]
 8002d62:	4322      	orrs	r2, r4
 8002d64:	605a      	str	r2, [r3, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8002d66:	689a      	ldr	r2, [r3, #8]
 8002d68:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002d6c:	609a      	str	r2, [r3, #8]
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8002d6e:	689a      	ldr	r2, [r3, #8]
 8002d70:	430a      	orrs	r2, r1
 8002d72:	609a      	str	r2, [r3, #8]
  
  htim->State = HAL_TIM_STATE_READY;
 8002d74:	2301      	movs	r3, #1
 8002d76:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  
  __HAL_UNLOCK(htim);
 8002d7a:	2300      	movs	r3, #0
 8002d7c:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  __HAL_LOCK(htim);
 8002d80:	4618      	mov	r0, r3
  
  return HAL_OK;
} 
 8002d82:	bd10      	pop	{r4, pc}

08002d84 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  
  /* Check input state */
  __HAL_LOCK(htim);
 8002d84:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002d88:	2b01      	cmp	r3, #1
 8002d8a:	d01f      	beq.n	8002dcc <HAL_TIMEx_ConfigBreakDeadTime+0x48>
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
  the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8002d8c:	68cb      	ldr	r3, [r1, #12]
 8002d8e:	688a      	ldr	r2, [r1, #8]
 8002d90:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002d94:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8002d96:	684a      	ldr	r2, [r1, #4]
 8002d98:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002d9c:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8002d9e:	680a      	ldr	r2, [r1, #0]
 8002da0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002da4:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8002da6:	690a      	ldr	r2, [r1, #16]
 8002da8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002dac:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8002dae:	694a      	ldr	r2, [r1, #20]
 8002db0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002db4:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8002db6:	698a      	ldr	r2, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8002db8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002dbc:	4313      	orrs	r3, r2
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8002dbe:	6802      	ldr	r2, [r0, #0]
 8002dc0:	6453      	str	r3, [r2, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 8002dc2:	2300      	movs	r3, #0
 8002dc4:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

  return HAL_OK;
 8002dc8:	4618      	mov	r0, r3
 8002dca:	4770      	bx	lr
  __HAL_LOCK(htim);
 8002dcc:	2002      	movs	r0, #2
}
 8002dce:	4770      	bx	lr

08002dd0 <UART_SetConfig>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002dd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8002dd4:	6806      	ldr	r6, [r0, #0]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002dd6:	68c2      	ldr	r2, [r0, #12]
  tmpreg = huart->Instance->CR2;
 8002dd8:	6933      	ldr	r3, [r6, #16]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002dda:	69c1      	ldr	r1, [r0, #28]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8002ddc:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002de0:	4313      	orrs	r3, r2
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8002de2:	6133      	str	r3, [r6, #16]
{
 8002de4:	4604      	mov	r4, r0
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002de6:	6883      	ldr	r3, [r0, #8]
 8002de8:	6900      	ldr	r0, [r0, #16]
  tmpreg = huart->Instance->CR1;
 8002dea:	68f2      	ldr	r2, [r6, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002dec:	4303      	orrs	r3, r0
 8002dee:	6960      	ldr	r0, [r4, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002df0:	f422 4216 	bic.w	r2, r2, #38400	; 0x9600
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002df4:	4303      	orrs	r3, r0
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002df6:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002dfa:	430b      	orrs	r3, r1
 8002dfc:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8002dfe:	60f3      	str	r3, [r6, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8002e00:	6973      	ldr	r3, [r6, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8002e02:	69a2      	ldr	r2, [r4, #24]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8002e04:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 8002e08:	4313      	orrs	r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002e0a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8002e0e:	6173      	str	r3, [r6, #20]
 8002e10:	4b7a      	ldr	r3, [pc, #488]	; (8002ffc <UART_SetConfig+0x22c>)
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002e12:	d17c      	bne.n	8002f0e <UART_SetConfig+0x13e>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002e14:	429e      	cmp	r6, r3
 8002e16:	d003      	beq.n	8002e20 <UART_SetConfig+0x50>
 8002e18:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002e1c:	429e      	cmp	r6, r3
 8002e1e:	d144      	bne.n	8002eaa <UART_SetConfig+0xda>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002e20:	f7fe fa6c 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002e24:	2519      	movs	r5, #25
 8002e26:	fb05 f300 	mul.w	r3, r5, r0
 8002e2a:	6860      	ldr	r0, [r4, #4]
 8002e2c:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002e30:	0040      	lsls	r0, r0, #1
 8002e32:	fbb3 f3f0 	udiv	r3, r3, r0
 8002e36:	fbb3 f3f9 	udiv	r3, r3, r9
 8002e3a:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002e3e:	f7fe fa5d 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002e42:	6863      	ldr	r3, [r4, #4]
 8002e44:	4368      	muls	r0, r5
 8002e46:	005b      	lsls	r3, r3, #1
 8002e48:	fbb0 f7f3 	udiv	r7, r0, r3
 8002e4c:	f7fe fa56 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002e50:	6863      	ldr	r3, [r4, #4]
 8002e52:	4368      	muls	r0, r5
 8002e54:	005b      	lsls	r3, r3, #1
 8002e56:	fbb0 f3f3 	udiv	r3, r0, r3
 8002e5a:	fbb3 f3f9 	udiv	r3, r3, r9
 8002e5e:	fb09 7313 	mls	r3, r9, r3, r7
 8002e62:	00db      	lsls	r3, r3, #3
 8002e64:	3332      	adds	r3, #50	; 0x32
 8002e66:	fbb3 f3f9 	udiv	r3, r3, r9
 8002e6a:	005b      	lsls	r3, r3, #1
 8002e6c:	f403 77f8 	and.w	r7, r3, #496	; 0x1f0
 8002e70:	f7fe fa44 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002e74:	6862      	ldr	r2, [r4, #4]
 8002e76:	4368      	muls	r0, r5
 8002e78:	0052      	lsls	r2, r2, #1
 8002e7a:	fbb0 faf2 	udiv	sl, r0, r2
 8002e7e:	f7fe fa3d 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002e82:	6863      	ldr	r3, [r4, #4]
 8002e84:	4368      	muls	r0, r5
 8002e86:	005b      	lsls	r3, r3, #1
 8002e88:	fbb0 f3f3 	udiv	r3, r0, r3
 8002e8c:	fbb3 f3f9 	udiv	r3, r3, r9
 8002e90:	fb09 a313 	mls	r3, r9, r3, sl
 8002e94:	00db      	lsls	r3, r3, #3
 8002e96:	3332      	adds	r3, #50	; 0x32
 8002e98:	fbb3 f3f9 	udiv	r3, r3, r9
 8002e9c:	f003 0307 	and.w	r3, r3, #7
 8002ea0:	4443      	add	r3, r8
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002ea2:	443b      	add	r3, r7
 8002ea4:	60b3      	str	r3, [r6, #8]
 8002ea6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002eaa:	f7fe fa17 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002eae:	2519      	movs	r5, #25
 8002eb0:	fb05 f300 	mul.w	r3, r5, r0
 8002eb4:	6860      	ldr	r0, [r4, #4]
 8002eb6:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002eba:	0040      	lsls	r0, r0, #1
 8002ebc:	fbb3 f3f0 	udiv	r3, r3, r0
 8002ec0:	fbb3 f3f9 	udiv	r3, r3, r9
 8002ec4:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002ec8:	f7fe fa08 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002ecc:	6863      	ldr	r3, [r4, #4]
 8002ece:	4368      	muls	r0, r5
 8002ed0:	005b      	lsls	r3, r3, #1
 8002ed2:	fbb0 f7f3 	udiv	r7, r0, r3
 8002ed6:	f7fe fa01 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002eda:	6863      	ldr	r3, [r4, #4]
 8002edc:	4368      	muls	r0, r5
 8002ede:	005b      	lsls	r3, r3, #1
 8002ee0:	fbb0 f3f3 	udiv	r3, r0, r3
 8002ee4:	fbb3 f3f9 	udiv	r3, r3, r9
 8002ee8:	fb09 7313 	mls	r3, r9, r3, r7
 8002eec:	00db      	lsls	r3, r3, #3
 8002eee:	3332      	adds	r3, #50	; 0x32
 8002ef0:	fbb3 f3f9 	udiv	r3, r3, r9
 8002ef4:	005b      	lsls	r3, r3, #1
 8002ef6:	f403 77f8 	and.w	r7, r3, #496	; 0x1f0
 8002efa:	f7fe f9ef 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002efe:	6862      	ldr	r2, [r4, #4]
 8002f00:	4368      	muls	r0, r5
 8002f02:	0052      	lsls	r2, r2, #1
 8002f04:	fbb0 faf2 	udiv	sl, r0, r2
 8002f08:	f7fe f9e8 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002f0c:	e7b9      	b.n	8002e82 <UART_SetConfig+0xb2>
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002f0e:	429e      	cmp	r6, r3
 8002f10:	d002      	beq.n	8002f18 <UART_SetConfig+0x148>
 8002f12:	4b3b      	ldr	r3, [pc, #236]	; (8003000 <UART_SetConfig+0x230>)
 8002f14:	429e      	cmp	r6, r3
 8002f16:	d140      	bne.n	8002f9a <UART_SetConfig+0x1ca>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002f18:	f7fe f9f0 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002f1c:	6867      	ldr	r7, [r4, #4]
 8002f1e:	2519      	movs	r5, #25
 8002f20:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002f24:	fb05 f300 	mul.w	r3, r5, r0
 8002f28:	00bf      	lsls	r7, r7, #2
 8002f2a:	fbb3 f3f7 	udiv	r3, r3, r7
 8002f2e:	fbb3 f3f9 	udiv	r3, r3, r9
 8002f32:	011f      	lsls	r7, r3, #4
 8002f34:	f7fe f9e2 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002f38:	6863      	ldr	r3, [r4, #4]
 8002f3a:	4368      	muls	r0, r5
 8002f3c:	009b      	lsls	r3, r3, #2
 8002f3e:	fbb0 f8f3 	udiv	r8, r0, r3
 8002f42:	f7fe f9db 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002f46:	6863      	ldr	r3, [r4, #4]
 8002f48:	4368      	muls	r0, r5
 8002f4a:	009b      	lsls	r3, r3, #2
 8002f4c:	fbb0 f3f3 	udiv	r3, r0, r3
 8002f50:	fbb3 f3f9 	udiv	r3, r3, r9
 8002f54:	fb09 8313 	mls	r3, r9, r3, r8
 8002f58:	011b      	lsls	r3, r3, #4
 8002f5a:	3332      	adds	r3, #50	; 0x32
 8002f5c:	fbb3 f3f9 	udiv	r3, r3, r9
 8002f60:	f003 08f0 	and.w	r8, r3, #240	; 0xf0
 8002f64:	f7fe f9ca 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
 8002f68:	6862      	ldr	r2, [r4, #4]
 8002f6a:	4368      	muls	r0, r5
 8002f6c:	0092      	lsls	r2, r2, #2
 8002f6e:	fbb0 faf2 	udiv	sl, r0, r2
 8002f72:	f7fe f9c3 	bl	80012fc <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002f76:	6863      	ldr	r3, [r4, #4]
 8002f78:	4368      	muls	r0, r5
 8002f7a:	009b      	lsls	r3, r3, #2
 8002f7c:	fbb0 f3f3 	udiv	r3, r0, r3
 8002f80:	fbb3 f3f9 	udiv	r3, r3, r9
 8002f84:	fb09 a313 	mls	r3, r9, r3, sl
 8002f88:	011b      	lsls	r3, r3, #4
 8002f8a:	3332      	adds	r3, #50	; 0x32
 8002f8c:	fbb3 f3f9 	udiv	r3, r3, r9
 8002f90:	f003 030f 	and.w	r3, r3, #15
 8002f94:	ea43 0308 	orr.w	r3, r3, r8
 8002f98:	e783      	b.n	8002ea2 <UART_SetConfig+0xd2>
 8002f9a:	f7fe f99f 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002f9e:	6867      	ldr	r7, [r4, #4]
 8002fa0:	2519      	movs	r5, #25
 8002fa2:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002fa6:	fb05 f300 	mul.w	r3, r5, r0
 8002faa:	00bf      	lsls	r7, r7, #2
 8002fac:	fbb3 f3f7 	udiv	r3, r3, r7
 8002fb0:	fbb3 f3f9 	udiv	r3, r3, r9
 8002fb4:	011f      	lsls	r7, r3, #4
 8002fb6:	f7fe f991 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002fba:	6863      	ldr	r3, [r4, #4]
 8002fbc:	4368      	muls	r0, r5
 8002fbe:	009b      	lsls	r3, r3, #2
 8002fc0:	fbb0 f8f3 	udiv	r8, r0, r3
 8002fc4:	f7fe f98a 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002fc8:	6863      	ldr	r3, [r4, #4]
 8002fca:	4368      	muls	r0, r5
 8002fcc:	009b      	lsls	r3, r3, #2
 8002fce:	fbb0 f3f3 	udiv	r3, r0, r3
 8002fd2:	fbb3 f3f9 	udiv	r3, r3, r9
 8002fd6:	fb09 8313 	mls	r3, r9, r3, r8
 8002fda:	011b      	lsls	r3, r3, #4
 8002fdc:	3332      	adds	r3, #50	; 0x32
 8002fde:	fbb3 f3f9 	udiv	r3, r3, r9
 8002fe2:	f003 08f0 	and.w	r8, r3, #240	; 0xf0
 8002fe6:	f7fe f979 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002fea:	6862      	ldr	r2, [r4, #4]
 8002fec:	4368      	muls	r0, r5
 8002fee:	0092      	lsls	r2, r2, #2
 8002ff0:	fbb0 faf2 	udiv	sl, r0, r2
 8002ff4:	f7fe f972 	bl	80012dc <HAL_RCC_GetPCLK1Freq>
 8002ff8:	e7bd      	b.n	8002f76 <UART_SetConfig+0x1a6>
 8002ffa:	bf00      	nop
 8002ffc:	40011000 	.word	0x40011000
 8003000:	40011400 	.word	0x40011400

08003004 <HAL_UART_Init>:
{
 8003004:	b510      	push	{r4, lr}
  if(huart == NULL)
 8003006:	4604      	mov	r4, r0
 8003008:	b340      	cbz	r0, 800305c <HAL_UART_Init+0x58>
  if(huart->gState == HAL_UART_STATE_RESET)
 800300a:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 800300e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003012:	b91b      	cbnz	r3, 800301c <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8003014:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8003018:	f003 fe12 	bl	8006c40 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 800301c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800301e:	2324      	movs	r3, #36	; 0x24
 8003020:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8003024:	68d3      	ldr	r3, [r2, #12]
 8003026:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800302a:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 800302c:	4620      	mov	r0, r4
 800302e:	f7ff fecf 	bl	8002dd0 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003032:	6823      	ldr	r3, [r4, #0]
 8003034:	691a      	ldr	r2, [r3, #16]
 8003036:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800303a:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800303c:	695a      	ldr	r2, [r3, #20]
 800303e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003042:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 8003044:	68da      	ldr	r2, [r3, #12]
 8003046:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800304a:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800304c:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 800304e:	2320      	movs	r3, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003050:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8003052:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8003056:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  return HAL_OK;
 800305a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800305c:	2001      	movs	r0, #1
}
 800305e:	bd10      	pop	{r4, pc}

08003060 <LL_ADC_CommonInit>:
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
  return (READ_BIT(ADCx->CR2, ADC_CR2_ADON) == (ADC_CR2_ADON));
 8003060:	4b0e      	ldr	r3, [pc, #56]	; (800309c <LL_ADC_CommonInit+0x3c>)
 8003062:	4a0f      	ldr	r2, [pc, #60]	; (80030a0 <LL_ADC_CommonInit+0x40>)
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: ADC common registers are initialized
  *          - ERROR: ADC common registers are not initialized
  */
ErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
{
 8003064:	b530      	push	{r4, r5, lr}
 8003066:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800306a:	f853 4cf8 	ldr.w	r4, [r3, #-248]
 800306e:	689b      	ldr	r3, [r3, #8]
 8003070:	6892      	ldr	r2, [r2, #8]
  /* Note: Hardware constraint (refer to description of functions             */
  /*       "LL_ADC_SetCommonXXX()" and "LL_ADC_SetMultiXXX()"):               */
  /*       On this STM32 serie, setting of these features is conditioned to   */
  /*       ADC state:                                                         */
  /*       All ADC instances of the ADC common group must be disabled.        */
  if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0U)
 8003072:	4323      	orrs	r3, r4
 8003074:	4313      	orrs	r3, r2
 8003076:	07db      	lsls	r3, r3, #31
 8003078:	d40e      	bmi.n	8003098 <LL_ADC_CommonInit+0x38>
 800307a:	4c0a      	ldr	r4, [pc, #40]	; (80030a4 <LL_ADC_CommonInit+0x44>)
    /*    - Set ADC multimode DMA transfer                                    */
    /*    - Set ADC multimode: delay between 2 sampling phases                */
#if defined(ADC_MULTIMODE_SUPPORT)
    if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
    {
      MODIFY_REG(ADCxy_COMMON->CCR,
 800307c:	6843      	ldr	r3, [r0, #4]
  if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
 800307e:	684d      	ldr	r5, [r1, #4]
 8003080:	680a      	ldr	r2, [r1, #0]
      MODIFY_REG(ADCxy_COMMON->CCR,
 8003082:	4023      	ands	r3, r4
    if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
 8003084:	b125      	cbz	r5, 8003090 <LL_ADC_CommonInit+0x30>
      MODIFY_REG(ADCxy_COMMON->CCR,
 8003086:	432b      	orrs	r3, r5
 8003088:	4313      	orrs	r3, r2
 800308a:	688a      	ldr	r2, [r1, #8]
 800308c:	4313      	orrs	r3, r2
 800308e:	68ca      	ldr	r2, [r1, #12]
                 | ADC_CommonInitStruct->MultiTwoSamplingDelay
                );
    }
    else
    {
      MODIFY_REG(ADCxy_COMMON->CCR,
 8003090:	4313      	orrs	r3, r2
 8003092:	6043      	str	r3, [r0, #4]
  ErrorStatus status = SUCCESS;
 8003094:	2001      	movs	r0, #1
 8003096:	bd30      	pop	{r4, r5, pc}
  }
  else
  {
    /* Initialization error: One or several ADC instances belonging to        */
    /* the same ADC common instance are not disabled.                         */
    status = ERROR;
 8003098:	2000      	movs	r0, #0
  }
  
  return status;
}
 800309a:	bd30      	pop	{r4, r5, pc}
 800309c:	40012000 	.word	0x40012000
 80030a0:	40012200 	.word	0x40012200
 80030a4:	fffc10e0 	.word	0xfffc10e0

080030a8 <LL_ADC_Init>:
 80030a8:	6883      	ldr	r3, [r0, #8]
  assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));
  assert_param(IS_LL_ADC_SCAN_SELECTION(ADC_InitStruct->SequencersScanMode));
  
  /* Note: Hardware constraint (refer to description of this function):       */
  /*       ADC instance must be disabled.                                     */
  if(LL_ADC_IsEnabled(ADCx) == 0U)
 80030aa:	07db      	lsls	r3, r3, #31
{
 80030ac:	b510      	push	{r4, lr}
  if(LL_ADC_IsEnabled(ADCx) == 0U)
 80030ae:	d411      	bmi.n	80030d4 <LL_ADC_Init+0x2c>
  {
    /* Configuration of ADC hierarchical scope:                               */
    /*  - ADC instance                                                        */
    /*    - Set ADC data resolution                                           */
    /*    - Set ADC conversion data alignment                                 */
    MODIFY_REG(ADCx->CR1,
 80030b0:	6842      	ldr	r2, [r0, #4]
 80030b2:	680b      	ldr	r3, [r1, #0]
 80030b4:	688c      	ldr	r4, [r1, #8]
 80030b6:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80030ba:	4323      	orrs	r3, r4
 80030bc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80030c0:	4313      	orrs	r3, r2
 80030c2:	6043      	str	r3, [r0, #4]
              ,
                 ADC_InitStruct->Resolution
               | ADC_InitStruct->SequencersScanMode
              );
    
    MODIFY_REG(ADCx->CR2,
 80030c4:	6883      	ldr	r3, [r0, #8]
 80030c6:	684a      	ldr	r2, [r1, #4]
 80030c8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80030cc:	4313      	orrs	r3, r2
 80030ce:	6083      	str	r3, [r0, #8]
  ErrorStatus status = SUCCESS;
 80030d0:	2001      	movs	r0, #1
 80030d2:	bd10      	pop	{r4, pc}

  }
  else
  {
    /* Initialization error: ADC instance is not disabled. */
    status = ERROR;
 80030d4:	2000      	movs	r0, #0
  }
  return status;
}
 80030d6:	bd10      	pop	{r4, pc}

080030d8 <LL_ADC_REG_Init>:
 80030d8:	6883      	ldr	r3, [r0, #8]
  assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));
  assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));
  
  /* Note: Hardware constraint (refer to description of this function):       */
  /*       ADC instance must be disabled.                                     */
  if(LL_ADC_IsEnabled(ADCx) == 0U)
 80030da:	07db      	lsls	r3, r3, #31
{
 80030dc:	b510      	push	{r4, lr}
  if(LL_ADC_IsEnabled(ADCx) == 0U)
 80030de:	d41b      	bmi.n	8003118 <LL_ADC_REG_Init+0x40>
    /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
    /*       ADC conversion.                                                  */
    /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().      */
    if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
    {
      MODIFY_REG(ADCx->CR1,
 80030e0:	6843      	ldr	r3, [r0, #4]
  if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
 80030e2:	684a      	ldr	r2, [r1, #4]
      MODIFY_REG(ADCx->CR1,
 80030e4:	f423 4368 	bic.w	r3, r3, #59392	; 0xe800
    if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
 80030e8:	b112      	cbz	r2, 80030f0 <LL_ADC_REG_Init+0x18>
      MODIFY_REG(ADCx->CR1,
 80030ea:	688c      	ldr	r4, [r1, #8]
 80030ec:	4313      	orrs	r3, r2
 80030ee:	4323      	orrs	r3, r4
                 | ADC_REG_InitStruct->SequencerDiscont
                );
    }
    else
    {
      MODIFY_REG(ADCx->CR1,
 80030f0:	6043      	str	r3, [r0, #4]
                   ADC_REG_InitStruct->SequencerLength
                 | LL_ADC_REG_SEQ_DISCONT_DISABLE
                );
    }
    
    MODIFY_REG(ADCx->CR2,
 80030f2:	6884      	ldr	r4, [r0, #8]
 80030f4:	4b09      	ldr	r3, [pc, #36]	; (800311c <LL_ADC_REG_Init+0x44>)
 80030f6:	4023      	ands	r3, r4
 80030f8:	68cc      	ldr	r4, [r1, #12]
 80030fa:	4323      	orrs	r3, r4
 80030fc:	690c      	ldr	r4, [r1, #16]
 80030fe:	6809      	ldr	r1, [r1, #0]
 8003100:	4323      	orrs	r3, r4
 8003102:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8003106:	430b      	orrs	r3, r1
 8003108:	6083      	str	r3, [r0, #8]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 800310a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800310c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8003110:	4313      	orrs	r3, r2
 8003112:	62c3      	str	r3, [r0, #44]	; 0x2c
  ErrorStatus status = SUCCESS;
 8003114:	2001      	movs	r0, #1
 8003116:	bd10      	pop	{r4, pc}
    LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);
  }
  else
  {
    /* Initialization error: ADC instance is not disabled. */
    status = ERROR;
 8003118:	2000      	movs	r0, #0
  }
  return status;
}
 800311a:	bd10      	pop	{r4, pc}
 800311c:	c0fffcfd 	.word	0xc0fffcfd

08003120 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8003120:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8003124:	680a      	ldr	r2, [r1, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003126:	fa92 f4a2 	rbit	r4, r2

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 800312a:	f04f 0e01 	mov.w	lr, #1
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 800312e:	fab4 f484 	clz	r4, r4
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8003132:	2503      	movs	r5, #3
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8003134:	270f      	movs	r7, #15
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8003136:	fa32 f304 	lsrs.w	r3, r2, r4
 800313a:	d10d      	bne.n	8003158 <LL_GPIO_Init+0x38>
      }
    }
    pinpos++;
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 800313c:	684b      	ldr	r3, [r1, #4]
 800313e:	3b01      	subs	r3, #1
 8003140:	2b01      	cmp	r3, #1
 8003142:	d806      	bhi.n	8003152 <LL_GPIO_Init+0x32>
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8003144:	6843      	ldr	r3, [r0, #4]
 8003146:	68c9      	ldr	r1, [r1, #12]
 8003148:	ea23 0302 	bic.w	r3, r3, r2
 800314c:	434a      	muls	r2, r1
 800314e:	431a      	orrs	r2, r3
 8003150:	6042      	str	r2, [r0, #4]
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 8003152:	2001      	movs	r0, #1
 8003154:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8003158:	fa0e f304 	lsl.w	r3, lr, r4
    if (currentpin)
 800315c:	4013      	ands	r3, r2
 800315e:	d069      	beq.n	8003234 <LL_GPIO_Init+0x114>
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 8003160:	f8d1 8004 	ldr.w	r8, [r1, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8003164:	f8d0 9000 	ldr.w	r9, [r0]
 8003168:	fa93 fca3 	rbit	ip, r3
 800316c:	fabc fc8c 	clz	ip, ip
 8003170:	fa93 f6a3 	rbit	r6, r3
 8003174:	fab6 f686 	clz	r6, r6
 8003178:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800317c:	fa05 fc0c 	lsl.w	ip, r5, ip
 8003180:	0076      	lsls	r6, r6, #1
 8003182:	ea29 0c0c 	bic.w	ip, r9, ip
 8003186:	fa08 f606 	lsl.w	r6, r8, r6
 800318a:	ea4c 0606 	orr.w	r6, ip, r6
 800318e:	6006      	str	r6, [r0, #0]
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8003190:	f108 36ff 	add.w	r6, r8, #4294967295	; 0xffffffff
 8003194:	2e01      	cmp	r6, #1
 8003196:	d816      	bhi.n	80031c6 <LL_GPIO_Init+0xa6>
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8003198:	6886      	ldr	r6, [r0, #8]
 800319a:	fa93 fca3 	rbit	ip, r3
 800319e:	fabc fc8c 	clz	ip, ip
 80031a2:	fa93 f9a3 	rbit	r9, r3
 80031a6:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80031aa:	fa05 fc0c 	lsl.w	ip, r5, ip
 80031ae:	ea26 0c0c 	bic.w	ip, r6, ip
 80031b2:	fab9 f989 	clz	r9, r9
 80031b6:	688e      	ldr	r6, [r1, #8]
 80031b8:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80031bc:	fa06 f609 	lsl.w	r6, r6, r9
 80031c0:	ea4c 0606 	orr.w	r6, ip, r6
 80031c4:	6086      	str	r6, [r0, #8]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80031c6:	68c6      	ldr	r6, [r0, #12]
 80031c8:	fa93 fca3 	rbit	ip, r3
 80031cc:	fabc fc8c 	clz	ip, ip
 80031d0:	fa93 f9a3 	rbit	r9, r3
 80031d4:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80031d8:	fa05 fc0c 	lsl.w	ip, r5, ip
 80031dc:	ea26 0c0c 	bic.w	ip, r6, ip
 80031e0:	fab9 f989 	clz	r9, r9
 80031e4:	690e      	ldr	r6, [r1, #16]
 80031e6:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80031ea:	fa06 f609 	lsl.w	r6, r6, r9
 80031ee:	ea4c 0606 	orr.w	r6, ip, r6
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 80031f2:	f1b8 0f02 	cmp.w	r8, #2
 80031f6:	60c6      	str	r6, [r0, #12]
 80031f8:	d11c      	bne.n	8003234 <LL_GPIO_Init+0x114>
 80031fa:	fa93 f6a3 	rbit	r6, r3
        if (POSITION_VAL(currentpin) < 0x00000008U)
 80031fe:	fab6 f686 	clz	r6, r6
 8003202:	2e07      	cmp	r6, #7
 8003204:	f8d1 c014 	ldr.w	ip, [r1, #20]
 8003208:	dc16      	bgt.n	8003238 <LL_GPIO_Init+0x118>
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 800320a:	f8d0 8020 	ldr.w	r8, [r0, #32]
 800320e:	fa93 f6a3 	rbit	r6, r3
 8003212:	fab6 f686 	clz	r6, r6
 8003216:	fa93 f3a3 	rbit	r3, r3
 800321a:	fab3 f383 	clz	r3, r3
 800321e:	00b6      	lsls	r6, r6, #2
 8003220:	fa07 f606 	lsl.w	r6, r7, r6
 8003224:	009b      	lsls	r3, r3, #2
 8003226:	ea28 0606 	bic.w	r6, r8, r6
 800322a:	fa0c fc03 	lsl.w	ip, ip, r3
 800322e:	ea46 060c 	orr.w	r6, r6, ip
 8003232:	6206      	str	r6, [r0, #32]
    pinpos++;
 8003234:	3401      	adds	r4, #1
 8003236:	e77e      	b.n	8003136 <LL_GPIO_Init+0x16>
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8003238:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
 800323c:	0a1b      	lsrs	r3, r3, #8
 800323e:	fa93 f6a3 	rbit	r6, r3
 8003242:	fab6 f686 	clz	r6, r6
 8003246:	fa93 f3a3 	rbit	r3, r3
 800324a:	fab3 f383 	clz	r3, r3
 800324e:	00b6      	lsls	r6, r6, #2
 8003250:	fa07 f606 	lsl.w	r6, r7, r6
 8003254:	009b      	lsls	r3, r3, #2
 8003256:	ea28 0606 	bic.w	r6, r8, r6
 800325a:	fa0c f303 	lsl.w	r3, ip, r3
 800325e:	4333      	orrs	r3, r6
 8003260:	6243      	str	r3, [r0, #36]	; 0x24
 8003262:	e7e7      	b.n	8003234 <LL_GPIO_Init+0x114>

08003264 <SDMMC_GetCmdResp2>:
  */
static uint32_t SDMMC_GetCmdResp2(SDIO_TypeDef *SDIOx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8003264:	4b11      	ldr	r3, [pc, #68]	; (80032ac <SDMMC_GetCmdResp2+0x48>)
 8003266:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800326a:	681b      	ldr	r3, [r3, #0]
 800326c:	fbb3 f2f2 	udiv	r2, r3, r2
 8003270:	f241 3388 	movw	r3, #5000	; 0x1388
 8003274:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 8003276:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800327a:	d314      	bcc.n	80032a6 <SDMMC_GetCmdResp2+0x42>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
 800327c:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800327e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8003282:	d0f8      	beq.n	8003276 <SDMMC_GetCmdResp2+0x12>
    
  if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8003284:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003286:	075b      	lsls	r3, r3, #29
 8003288:	d503      	bpl.n	8003292 <SDMMC_GetCmdResp2+0x2e>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 800328a:	2304      	movs	r3, #4
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 800328c:	6383      	str	r3, [r0, #56]	; 0x38
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 800328e:	4618      	mov	r0, r3
 8003290:	4770      	bx	lr
  else if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 8003292:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003294:	f013 0301 	ands.w	r3, r3, #1
 8003298:	d001      	beq.n	800329e <SDMMC_GetCmdResp2+0x3a>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 800329a:	2301      	movs	r3, #1
 800329c:	e7f6      	b.n	800328c <SDMMC_GetCmdResp2+0x28>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 800329e:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80032a2:	6382      	str	r2, [r0, #56]	; 0x38
 80032a4:	e7f3      	b.n	800328e <SDMMC_GetCmdResp2+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 80032a6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 80032aa:	e7f0      	b.n	800328e <SDMMC_GetCmdResp2+0x2a>
 80032ac:	20000010 	.word	0x20000010

080032b0 <SDMMC_GetCmdResp3>:
  */
static uint32_t SDMMC_GetCmdResp3(SDIO_TypeDef *SDIOx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80032b0:	4b0e      	ldr	r3, [pc, #56]	; (80032ec <SDMMC_GetCmdResp3+0x3c>)
 80032b2:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 80032b6:	681b      	ldr	r3, [r3, #0]
 80032b8:	fbb3 f2f2 	udiv	r2, r3, r2
 80032bc:	f241 3388 	movw	r3, #5000	; 0x1388
 80032c0:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 80032c2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 80032c6:	d30e      	bcc.n	80032e6 <SDMMC_GetCmdResp3+0x36>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
 80032c8:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80032ca:	f012 0f45 	tst.w	r2, #69	; 0x45
 80032ce:	d0f8      	beq.n	80032c2 <SDMMC_GetCmdResp3+0x12>
  
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80032d0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80032d2:	f013 0304 	ands.w	r3, r3, #4
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80032d6:	bf15      	itete	ne
 80032d8:	2304      	movne	r3, #4
  }
  else
 
  {  
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 80032da:	f240 52ff 	movweq	r2, #1535	; 0x5ff
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80032de:	6383      	strne	r3, [r0, #56]	; 0x38
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 80032e0:	6382      	streq	r2, [r0, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 80032e2:	4618      	mov	r0, r3
 80032e4:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 80032e6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80032ea:	4770      	bx	lr
 80032ec:	20000010 	.word	0x20000010

080032f0 <SDIO_Init>:
{
 80032f0:	b084      	sub	sp, #16
 80032f2:	b510      	push	{r4, lr}
 80032f4:	ac03      	add	r4, sp, #12
 80032f6:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  tmpreg |= (Init.ClockEdge           |\
 80032fa:	9904      	ldr	r1, [sp, #16]
 80032fc:	9b03      	ldr	r3, [sp, #12]
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80032fe:	6842      	ldr	r2, [r0, #4]
  tmpreg |= (Init.ClockEdge           |\
 8003300:	430b      	orrs	r3, r1
             Init.ClockBypass         |\
 8003302:	9905      	ldr	r1, [sp, #20]
 8003304:	430b      	orrs	r3, r1
             Init.ClockPowerSave      |\
 8003306:	9906      	ldr	r1, [sp, #24]
 8003308:	430b      	orrs	r3, r1
             Init.BusWide             |\
 800330a:	9907      	ldr	r1, [sp, #28]
 800330c:	430b      	orrs	r3, r1
             Init.HardwareFlowControl |\
 800330e:	9908      	ldr	r1, [sp, #32]
}
 8003310:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8003314:	f422 42fd 	bic.w	r2, r2, #32384	; 0x7e80
             Init.HardwareFlowControl |\
 8003318:	430b      	orrs	r3, r1
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 800331a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 800331e:	4313      	orrs	r3, r2
 8003320:	6043      	str	r3, [r0, #4]
}
 8003322:	b004      	add	sp, #16
 8003324:	2000      	movs	r0, #0
 8003326:	4770      	bx	lr

08003328 <SDIO_ReadFIFO>:
 8003328:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800332c:	4770      	bx	lr

0800332e <SDIO_WriteFIFO>:
  SDIOx->FIFO = *pWriteData;
 800332e:	680b      	ldr	r3, [r1, #0]
 8003330:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
 8003334:	2000      	movs	r0, #0
 8003336:	4770      	bx	lr

08003338 <SDIO_PowerState_ON>:
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8003338:	2303      	movs	r3, #3
 800333a:	6003      	str	r3, [r0, #0]
}
 800333c:	2000      	movs	r0, #0
 800333e:	4770      	bx	lr

08003340 <SDIO_GetPowerState>:
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8003340:	6800      	ldr	r0, [r0, #0]
}
 8003342:	f000 0003 	and.w	r0, r0, #3
 8003346:	4770      	bx	lr

08003348 <SDIO_SendCommand>:
  SDIOx->ARG = Command->Argument;
 8003348:	680b      	ldr	r3, [r1, #0]
{
 800334a:	b510      	push	{r4, lr}
  SDIOx->ARG = Command->Argument;
 800334c:	6083      	str	r3, [r0, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 800334e:	688c      	ldr	r4, [r1, #8]
 8003350:	684b      	ldr	r3, [r1, #4]
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8003352:	68c2      	ldr	r2, [r0, #12]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 8003354:	4323      	orrs	r3, r4
                       Command->Response         |\
 8003356:	68cc      	ldr	r4, [r1, #12]
                       Command->WaitForInterrupt |\
 8003358:	6909      	ldr	r1, [r1, #16]
                       Command->Response         |\
 800335a:	4323      	orrs	r3, r4
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800335c:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
                       Command->WaitForInterrupt |\
 8003360:	430b      	orrs	r3, r1
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8003362:	f022 020f 	bic.w	r2, r2, #15
 8003366:	4313      	orrs	r3, r2
 8003368:	60c3      	str	r3, [r0, #12]
}
 800336a:	2000      	movs	r0, #0
 800336c:	bd10      	pop	{r4, pc}

0800336e <SDIO_GetResponse>:
{
 800336e:	b082      	sub	sp, #8
  tmp = (uint32_t)&(SDIOx->RESP1) + Response;
 8003370:	3014      	adds	r0, #20
 8003372:	4401      	add	r1, r0
  __IO uint32_t tmp = 0U;
 8003374:	2300      	movs	r3, #0
 8003376:	9301      	str	r3, [sp, #4]
  tmp = (uint32_t)&(SDIOx->RESP1) + Response;
 8003378:	9101      	str	r1, [sp, #4]
  return (*(__IO uint32_t *) tmp);
 800337a:	9b01      	ldr	r3, [sp, #4]
 800337c:	6818      	ldr	r0, [r3, #0]
}  
 800337e:	b002      	add	sp, #8
 8003380:	4770      	bx	lr
	...

08003384 <SDMMC_GetCmdResp1>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8003384:	4b45      	ldr	r3, [pc, #276]	; (800349c <SDMMC_GetCmdResp1+0x118>)
{
 8003386:	b510      	push	{r4, lr}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8003388:	681b      	ldr	r3, [r3, #0]
 800338a:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 800338e:	fbb3 f3f4 	udiv	r3, r3, r4
 8003392:	435a      	muls	r2, r3
    if (count-- == 0U)
 8003394:	2a00      	cmp	r2, #0
 8003396:	d04a      	beq.n	800342e <SDMMC_GetCmdResp1+0xaa>
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
 8003398:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800339a:	f013 0f45 	tst.w	r3, #69	; 0x45
 800339e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 80033a2:	d0f7      	beq.n	8003394 <SDMMC_GetCmdResp1+0x10>
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80033a4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80033a6:	075c      	lsls	r4, r3, #29
 80033a8:	d503      	bpl.n	80033b2 <SDMMC_GetCmdResp1+0x2e>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80033aa:	2304      	movs	r3, #4
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80033ac:	6383      	str	r3, [r0, #56]	; 0x38
}
 80033ae:	4618      	mov	r0, r3
 80033b0:	bd10      	pop	{r4, pc}
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 80033b2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80033b4:	f013 0301 	ands.w	r3, r3, #1
 80033b8:	d001      	beq.n	80033be <SDMMC_GetCmdResp1+0x3a>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80033ba:	2301      	movs	r3, #1
 80033bc:	e7f6      	b.n	80033ac <SDMMC_GetCmdResp1+0x28>
  return (uint8_t)(SDIOx->RESPCMD);
 80033be:	6902      	ldr	r2, [r0, #16]
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 80033c0:	b2d2      	uxtb	r2, r2
 80033c2:	4291      	cmp	r1, r2
 80033c4:	d136      	bne.n	8003434 <SDMMC_GetCmdResp1+0xb0>
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 80033c6:	f240 52ff 	movw	r2, #1535	; 0x5ff
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 80033ca:	4619      	mov	r1, r3
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 80033cc:	6382      	str	r2, [r0, #56]	; 0x38
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 80033ce:	f7ff ffce 	bl	800336e <SDIO_GetResponse>
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 80033d2:	4b33      	ldr	r3, [pc, #204]	; (80034a0 <SDMMC_GetCmdResp1+0x11c>)
 80033d4:	4003      	ands	r3, r0
 80033d6:	2b00      	cmp	r3, #0
 80033d8:	d0e9      	beq.n	80033ae <SDMMC_GetCmdResp1+0x2a>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 80033da:	2800      	cmp	r0, #0
 80033dc:	db2c      	blt.n	8003438 <SDMMC_GetCmdResp1+0xb4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 80033de:	0042      	lsls	r2, r0, #1
 80033e0:	d42d      	bmi.n	800343e <SDMMC_GetCmdResp1+0xba>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 80033e2:	0084      	lsls	r4, r0, #2
 80033e4:	d42d      	bmi.n	8003442 <SDMMC_GetCmdResp1+0xbe>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 80033e6:	00c1      	lsls	r1, r0, #3
 80033e8:	d42d      	bmi.n	8003446 <SDMMC_GetCmdResp1+0xc2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 80033ea:	0102      	lsls	r2, r0, #4
 80033ec:	d42e      	bmi.n	800344c <SDMMC_GetCmdResp1+0xc8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 80033ee:	0144      	lsls	r4, r0, #5
 80033f0:	d42f      	bmi.n	8003452 <SDMMC_GetCmdResp1+0xce>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 80033f2:	01c1      	lsls	r1, r0, #7
 80033f4:	d430      	bmi.n	8003458 <SDMMC_GetCmdResp1+0xd4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 80033f6:	0202      	lsls	r2, r0, #8
 80033f8:	d431      	bmi.n	800345e <SDMMC_GetCmdResp1+0xda>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 80033fa:	0244      	lsls	r4, r0, #9
 80033fc:	d432      	bmi.n	8003464 <SDMMC_GetCmdResp1+0xe0>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 80033fe:	0281      	lsls	r1, r0, #10
 8003400:	d433      	bmi.n	800346a <SDMMC_GetCmdResp1+0xe6>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8003402:	02c2      	lsls	r2, r0, #11
 8003404:	d434      	bmi.n	8003470 <SDMMC_GetCmdResp1+0xec>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8003406:	0344      	lsls	r4, r0, #13
 8003408:	d435      	bmi.n	8003476 <SDMMC_GetCmdResp1+0xf2>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800340a:	0381      	lsls	r1, r0, #14
 800340c:	d436      	bmi.n	800347c <SDMMC_GetCmdResp1+0xf8>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800340e:	03c2      	lsls	r2, r0, #15
 8003410:	d437      	bmi.n	8003482 <SDMMC_GetCmdResp1+0xfe>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8003412:	0404      	lsls	r4, r0, #16
 8003414:	d438      	bmi.n	8003488 <SDMMC_GetCmdResp1+0x104>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8003416:	0441      	lsls	r1, r0, #17
 8003418:	d439      	bmi.n	800348e <SDMMC_GetCmdResp1+0x10a>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800341a:	0482      	lsls	r2, r0, #18
 800341c:	d43a      	bmi.n	8003494 <SDMMC_GetCmdResp1+0x110>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800341e:	f010 0f08 	tst.w	r0, #8
 8003422:	bf14      	ite	ne
 8003424:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8003428:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800342c:	e7bf      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 800342e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8003432:	e7bc      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8003434:	2301      	movs	r3, #1
 8003436:	e7ba      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8003438:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800343c:	e7b7      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800343e:	2340      	movs	r3, #64	; 0x40
 8003440:	e7b5      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8003442:	2380      	movs	r3, #128	; 0x80
 8003444:	e7b3      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8003446:	f44f 7380 	mov.w	r3, #256	; 0x100
 800344a:	e7b0      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800344c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003450:	e7ad      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8003452:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003456:	e7aa      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8003458:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800345c:	e7a7      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800345e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003462:	e7a4      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8003464:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8003468:	e7a1      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800346a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800346e:	e79e      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_CC_ERR;
 8003470:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8003474:	e79b      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8003476:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800347a:	e798      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800347c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003480:	e795      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8003482:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8003486:	e792      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8003488:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800348c:	e78f      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800348e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003492:	e78c      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
    return SDMMC_ERROR_ERASE_RESET;
 8003494:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8003498:	e789      	b.n	80033ae <SDMMC_GetCmdResp1+0x2a>
 800349a:	bf00      	nop
 800349c:	20000010 	.word	0x20000010
 80034a0:	fdffe008 	.word	0xfdffe008

080034a4 <SDIO_ConfigData>:
  SDIOx->DTIMER = Data->DataTimeOut;
 80034a4:	680b      	ldr	r3, [r1, #0]
{
 80034a6:	b510      	push	{r4, lr}
  SDIOx->DTIMER = Data->DataTimeOut;
 80034a8:	6243      	str	r3, [r0, #36]	; 0x24
  SDIOx->DLEN = Data->DataLength;
 80034aa:	684b      	ldr	r3, [r1, #4]
 80034ac:	6283      	str	r3, [r0, #40]	; 0x28
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80034ae:	68cc      	ldr	r4, [r1, #12]
 80034b0:	688b      	ldr	r3, [r1, #8]
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80034b2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80034b4:	4323      	orrs	r3, r4
                       Data->TransferDir   |\
 80034b6:	690c      	ldr	r4, [r1, #16]
                       Data->TransferMode  |\
 80034b8:	6949      	ldr	r1, [r1, #20]
                       Data->TransferDir   |\
 80034ba:	4323      	orrs	r3, r4
                       Data->TransferMode  |\
 80034bc:	430b      	orrs	r3, r1
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80034be:	f022 02f7 	bic.w	r2, r2, #247	; 0xf7
 80034c2:	4313      	orrs	r3, r2
 80034c4:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 80034c6:	2000      	movs	r0, #0
 80034c8:	bd10      	pop	{r4, pc}

080034ca <SDMMC_CmdBlockLength>:
{
 80034ca:	b530      	push	{r4, r5, lr}
 80034cc:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80034ce:	2340      	movs	r3, #64	; 0x40
 80034d0:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80034d2:	2300      	movs	r3, #0
{
 80034d4:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 80034d6:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 80034d8:	2410      	movs	r4, #16
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80034da:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80034dc:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80034de:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80034e2:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 80034e4:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80034e6:	f7ff ff2f 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SET_BLOCKLEN, SDIO_CMDTIMEOUT);
 80034ea:	f241 3288 	movw	r2, #5000	; 0x1388
 80034ee:	4621      	mov	r1, r4
 80034f0:	4628      	mov	r0, r5
 80034f2:	f7ff ff47 	bl	8003384 <SDMMC_GetCmdResp1>
}
 80034f6:	b007      	add	sp, #28
 80034f8:	bd30      	pop	{r4, r5, pc}

080034fa <SDMMC_CmdReadSingleBlock>:
{
 80034fa:	b530      	push	{r4, r5, lr}
 80034fc:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80034fe:	2340      	movs	r3, #64	; 0x40
 8003500:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003502:	2300      	movs	r3, #0
{
 8003504:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 8003506:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 8003508:	2411      	movs	r4, #17
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800350a:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800350c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800350e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003512:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 8003514:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003516:	f7ff ff17 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 800351a:	f241 3288 	movw	r2, #5000	; 0x1388
 800351e:	4621      	mov	r1, r4
 8003520:	4628      	mov	r0, r5
 8003522:	f7ff ff2f 	bl	8003384 <SDMMC_GetCmdResp1>
}
 8003526:	b007      	add	sp, #28
 8003528:	bd30      	pop	{r4, r5, pc}

0800352a <SDMMC_CmdReadMultiBlock>:
{
 800352a:	b530      	push	{r4, r5, lr}
 800352c:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800352e:	2340      	movs	r3, #64	; 0x40
 8003530:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003532:	2300      	movs	r3, #0
{
 8003534:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 8003536:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 8003538:	2412      	movs	r4, #18
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800353a:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800353c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800353e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003542:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 8003544:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003546:	f7ff feff 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_MULT_BLOCK, SDIO_CMDTIMEOUT);
 800354a:	f241 3288 	movw	r2, #5000	; 0x1388
 800354e:	4621      	mov	r1, r4
 8003550:	4628      	mov	r0, r5
 8003552:	f7ff ff17 	bl	8003384 <SDMMC_GetCmdResp1>
}
 8003556:	b007      	add	sp, #28
 8003558:	bd30      	pop	{r4, r5, pc}

0800355a <SDMMC_CmdWriteSingleBlock>:
{
 800355a:	b530      	push	{r4, r5, lr}
 800355c:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800355e:	2340      	movs	r3, #64	; 0x40
 8003560:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003562:	2300      	movs	r3, #0
{
 8003564:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 8003566:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 8003568:	2418      	movs	r4, #24
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800356a:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800356c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800356e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003572:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 8003574:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003576:	f7ff fee7 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 800357a:	f241 3288 	movw	r2, #5000	; 0x1388
 800357e:	4621      	mov	r1, r4
 8003580:	4628      	mov	r0, r5
 8003582:	f7ff feff 	bl	8003384 <SDMMC_GetCmdResp1>
}
 8003586:	b007      	add	sp, #28
 8003588:	bd30      	pop	{r4, r5, pc}

0800358a <SDMMC_CmdWriteMultiBlock>:
{
 800358a:	b530      	push	{r4, r5, lr}
 800358c:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800358e:	2340      	movs	r3, #64	; 0x40
 8003590:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003592:	2300      	movs	r3, #0
{
 8003594:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 8003596:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8003598:	2419      	movs	r4, #25
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800359a:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800359c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800359e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80035a2:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 80035a4:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80035a6:	f7ff fecf 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_MULT_BLOCK, SDIO_CMDTIMEOUT);
 80035aa:	f241 3288 	movw	r2, #5000	; 0x1388
 80035ae:	4621      	mov	r1, r4
 80035b0:	4628      	mov	r0, r5
 80035b2:	f7ff fee7 	bl	8003384 <SDMMC_GetCmdResp1>
}
 80035b6:	b007      	add	sp, #28
 80035b8:	bd30      	pop	{r4, r5, pc}
	...

080035bc <SDMMC_CmdStopTransfer>:
{
 80035bc:	b530      	push	{r4, r5, lr}
 80035be:	b087      	sub	sp, #28
  sdmmc_cmdinit.Argument         = 0U;
 80035c0:	2300      	movs	r3, #0
{
 80035c2:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = 0U;
 80035c4:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 80035c6:	240c      	movs	r4, #12
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80035c8:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80035ca:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80035cc:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80035ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80035d2:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80035d4:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 80035d6:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80035d8:	f7ff feb6 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_STOP_TRANSMISSION, 100000000U);
 80035dc:	4a03      	ldr	r2, [pc, #12]	; (80035ec <SDMMC_CmdStopTransfer+0x30>)
 80035de:	4621      	mov	r1, r4
 80035e0:	4628      	mov	r0, r5
 80035e2:	f7ff fecf 	bl	8003384 <SDMMC_GetCmdResp1>
}
 80035e6:	b007      	add	sp, #28
 80035e8:	bd30      	pop	{r4, r5, pc}
 80035ea:	bf00      	nop
 80035ec:	05f5e100 	.word	0x05f5e100

080035f0 <SDMMC_CmdSelDesel>:
{
 80035f0:	b530      	push	{r4, r5, lr}
 80035f2:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80035f4:	2340      	movs	r3, #64	; 0x40
 80035f6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80035f8:	2300      	movs	r3, #0
{
 80035fa:	4605      	mov	r5, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 80035fc:	2407      	movs	r4, #7
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80035fe:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003600:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003602:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 8003606:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003608:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 800360a:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800360c:	f7ff fe9c 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEL_DESEL_CARD, SDIO_CMDTIMEOUT);
 8003610:	f241 3288 	movw	r2, #5000	; 0x1388
 8003614:	4621      	mov	r1, r4
 8003616:	4628      	mov	r0, r5
 8003618:	f7ff feb4 	bl	8003384 <SDMMC_GetCmdResp1>
}
 800361c:	b007      	add	sp, #28
 800361e:	bd30      	pop	{r4, r5, pc}

08003620 <SDMMC_CmdGoIdleState>:
{
 8003620:	b510      	push	{r4, lr}
 8003622:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = 0U;
 8003624:	2300      	movs	r3, #0
 8003626:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 8003628:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_NO;
 800362a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800362c:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800362e:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003630:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003634:	9305      	str	r3, [sp, #20]
{
 8003636:	4604      	mov	r4, r0
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003638:	f7ff fe86 	bl	8003348 <SDIO_SendCommand>
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800363c:	4b0b      	ldr	r3, [pc, #44]	; (800366c <SDMMC_CmdGoIdleState+0x4c>)
 800363e:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8003642:	681b      	ldr	r3, [r3, #0]
 8003644:	fbb3 f2f2 	udiv	r2, r3, r2
 8003648:	f241 3388 	movw	r3, #5000	; 0x1388
 800364c:	4353      	muls	r3, r2
    if (count-- == 0U)
 800364e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8003652:	d308      	bcc.n	8003666 <SDMMC_CmdGoIdleState+0x46>
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDSENT));
 8003654:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003656:	0612      	lsls	r2, r2, #24
 8003658:	d5f9      	bpl.n	800364e <SDMMC_CmdGoIdleState+0x2e>
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 800365a:	f240 53ff 	movw	r3, #1535	; 0x5ff
 800365e:	63a3      	str	r3, [r4, #56]	; 0x38
  return SDMMC_ERROR_NONE;
 8003660:	2000      	movs	r0, #0
}
 8003662:	b006      	add	sp, #24
 8003664:	bd10      	pop	{r4, pc}
      return SDMMC_ERROR_TIMEOUT;
 8003666:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  return errorstate;
 800366a:	e7fa      	b.n	8003662 <SDMMC_CmdGoIdleState+0x42>
 800366c:	20000010 	.word	0x20000010

08003670 <SDMMC_CmdOperCond>:
{
 8003670:	b510      	push	{r4, lr}
 8003672:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 8003674:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 8003678:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800367a:	2308      	movs	r3, #8
 800367c:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800367e:	2340      	movs	r3, #64	; 0x40
 8003680:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003682:	2300      	movs	r3, #0
 8003684:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003686:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003688:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800368c:	9305      	str	r3, [sp, #20]
{
 800368e:	4604      	mov	r4, r0
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003690:	f7ff fe5a 	bl	8003348 <SDIO_SendCommand>
  */
static uint32_t SDMMC_GetCmdResp7(SDIO_TypeDef *SDIOx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8003694:	4b11      	ldr	r3, [pc, #68]	; (80036dc <SDMMC_CmdOperCond+0x6c>)
 8003696:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800369a:	681b      	ldr	r3, [r3, #0]
 800369c:	fbb3 f2f2 	udiv	r2, r3, r2
 80036a0:	f241 3388 	movw	r3, #5000	; 0x1388
 80036a4:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 80036a6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 80036aa:	d314      	bcc.n	80036d6 <SDMMC_CmdOperCond+0x66>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
 80036ac:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80036ae:	f012 0f45 	tst.w	r2, #69	; 0x45
 80036b2:	d0f8      	beq.n	80036a6 <SDMMC_CmdOperCond+0x36>

  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80036b4:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80036b6:	f012 0204 	ands.w	r2, r2, #4
 80036ba:	d004      	beq.n	80036c6 <SDMMC_CmdOperCond+0x56>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
 80036bc:	2340      	movs	r3, #64	; 0x40
 80036be:	63a3      	str	r3, [r4, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80036c0:	2004      	movs	r0, #4
}
 80036c2:	b006      	add	sp, #24
 80036c4:	bd10      	pop	{r4, pc}
  }
  
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDREND))
 80036c6:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80036c8:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 80036cc:	d0f9      	beq.n	80036c2 <SDMMC_CmdOperCond+0x52>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
 80036ce:	2340      	movs	r3, #64	; 0x40
 80036d0:	63a3      	str	r3, [r4, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 80036d2:	4610      	mov	r0, r2
 80036d4:	e7f5      	b.n	80036c2 <SDMMC_CmdOperCond+0x52>
      return SDMMC_ERROR_TIMEOUT;
 80036d6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80036da:	e7f2      	b.n	80036c2 <SDMMC_CmdOperCond+0x52>
 80036dc:	20000010 	.word	0x20000010

080036e0 <SDMMC_CmdAppCommand>:
{
 80036e0:	b530      	push	{r4, r5, lr}
 80036e2:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80036e4:	2340      	movs	r3, #64	; 0x40
 80036e6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80036e8:	2300      	movs	r3, #0
{
 80036ea:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 80036ec:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 80036ee:	2437      	movs	r4, #55	; 0x37
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80036f0:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80036f2:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80036f4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80036f8:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 80036fa:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80036fc:	f7ff fe24 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_CMD, SDIO_CMDTIMEOUT);
 8003700:	f241 3288 	movw	r2, #5000	; 0x1388
 8003704:	4621      	mov	r1, r4
 8003706:	4628      	mov	r0, r5
 8003708:	f7ff fe3c 	bl	8003384 <SDMMC_GetCmdResp1>
}
 800370c:	b007      	add	sp, #28
 800370e:	bd30      	pop	{r4, r5, pc}

08003710 <SDMMC_CmdAppOperCommand>:
{
 8003710:	b510      	push	{r4, lr}
 8003712:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 8003714:	2329      	movs	r3, #41	; 0x29
 8003716:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 8003718:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800371c:	2340      	movs	r3, #64	; 0x40
 800371e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 8003720:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003724:	2300      	movs	r3, #0
{
 8003726:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 8003728:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800372a:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800372c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800372e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003732:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003734:	f7ff fe08 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp3(SDIOx);
 8003738:	4620      	mov	r0, r4
 800373a:	f7ff fdb9 	bl	80032b0 <SDMMC_GetCmdResp3>
}
 800373e:	b006      	add	sp, #24
 8003740:	bd10      	pop	{r4, pc}

08003742 <SDMMC_CmdSendSCR>:
{
 8003742:	b530      	push	{r4, r5, lr}
 8003744:	b087      	sub	sp, #28
  sdmmc_cmdinit.Argument         = 0U;
 8003746:	2300      	movs	r3, #0
{
 8003748:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = 0U;
 800374a:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800374c:	2433      	movs	r4, #51	; 0x33
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800374e:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003750:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003752:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003754:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003758:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800375a:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800375c:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800375e:	f7ff fdf3 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_SEND_SCR, SDIO_CMDTIMEOUT);
 8003762:	f241 3288 	movw	r2, #5000	; 0x1388
 8003766:	4621      	mov	r1, r4
 8003768:	4628      	mov	r0, r5
 800376a:	f7ff fe0b 	bl	8003384 <SDMMC_GetCmdResp1>
}
 800376e:	b007      	add	sp, #28
 8003770:	bd30      	pop	{r4, r5, pc}

08003772 <SDMMC_CmdSendCID>:
{
 8003772:	b510      	push	{r4, lr}
 8003774:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = 0U;
 8003776:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 8003778:	2202      	movs	r2, #2
{
 800377a:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0U;
 800377c:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 800377e:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003780:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 8003782:	22c0      	movs	r2, #192	; 0xc0
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003784:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003788:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 800378a:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800378c:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800378e:	f7ff fddb 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 8003792:	4620      	mov	r0, r4
 8003794:	f7ff fd66 	bl	8003264 <SDMMC_GetCmdResp2>
}
 8003798:	b006      	add	sp, #24
 800379a:	bd10      	pop	{r4, pc}

0800379c <SDMMC_CmdSendCSD>:
{
 800379c:	b510      	push	{r4, lr}
 800379e:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 80037a0:	2309      	movs	r3, #9
 80037a2:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 80037a4:	23c0      	movs	r3, #192	; 0xc0
 80037a6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80037a8:	2300      	movs	r3, #0
{
 80037aa:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 80037ac:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80037ae:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037b0:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80037b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80037b6:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037b8:	f7ff fdc6 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 80037bc:	4620      	mov	r0, r4
 80037be:	f7ff fd51 	bl	8003264 <SDMMC_GetCmdResp2>
}
 80037c2:	b006      	add	sp, #24
 80037c4:	bd10      	pop	{r4, pc}
	...

080037c8 <SDMMC_CmdSetRelAdd>:
{
 80037c8:	b530      	push	{r4, r5, lr}
 80037ca:	b087      	sub	sp, #28
  sdmmc_cmdinit.Argument         = 0U;
 80037cc:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 80037ce:	2203      	movs	r2, #3
  sdmmc_cmdinit.Argument         = 0U;
 80037d0:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 80037d2:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80037d4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80037d6:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80037d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
{
 80037dc:	460d      	mov	r5, r1
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037de:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80037e0:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80037e2:	9305      	str	r3, [sp, #20]
{
 80037e4:	4604      	mov	r4, r0
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037e6:	f7ff fdaf 	bl	8003348 <SDIO_SendCommand>
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80037ea:	4b20      	ldr	r3, [pc, #128]	; (800386c <SDMMC_CmdSetRelAdd+0xa4>)
 80037ec:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 80037f0:	681b      	ldr	r3, [r3, #0]
 80037f2:	fbb3 f2f2 	udiv	r2, r3, r2
 80037f6:	f241 3388 	movw	r3, #5000	; 0x1388
 80037fa:	4353      	muls	r3, r2
    if (count-- == 0U)
 80037fc:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8003800:	d32b      	bcc.n	800385a <SDMMC_CmdSetRelAdd+0x92>
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
 8003802:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003804:	f012 0f45 	tst.w	r2, #69	; 0x45
 8003808:	d0f8      	beq.n	80037fc <SDMMC_CmdSetRelAdd+0x34>
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 800380a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800380c:	075a      	lsls	r2, r3, #29
 800380e:	d503      	bpl.n	8003818 <SDMMC_CmdSetRelAdd+0x50>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 8003810:	2004      	movs	r0, #4
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 8003812:	63a0      	str	r0, [r4, #56]	; 0x38
}
 8003814:	b007      	add	sp, #28
 8003816:	bd30      	pop	{r4, r5, pc}
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 8003818:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800381a:	f011 0101 	ands.w	r1, r1, #1
 800381e:	d001      	beq.n	8003824 <SDMMC_CmdSetRelAdd+0x5c>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 8003820:	2001      	movs	r0, #1
 8003822:	e7f6      	b.n	8003812 <SDMMC_CmdSetRelAdd+0x4a>
  return (uint8_t)(SDIOx->RESPCMD);
 8003824:	6923      	ldr	r3, [r4, #16]
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 8003826:	b2db      	uxtb	r3, r3
 8003828:	2b03      	cmp	r3, #3
 800382a:	d119      	bne.n	8003860 <SDMMC_CmdSetRelAdd+0x98>
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
 800382c:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8003830:	63a3      	str	r3, [r4, #56]	; 0x38
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 8003832:	4620      	mov	r0, r4
 8003834:	f7ff fd9b 	bl	800336e <SDIO_GetResponse>
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 8003838:	f410 4360 	ands.w	r3, r0, #57344	; 0xe000
 800383c:	d103      	bne.n	8003846 <SDMMC_CmdSetRelAdd+0x7e>
    *pRCA = (uint16_t) (response_r1 >> 16);
 800383e:	0c00      	lsrs	r0, r0, #16
 8003840:	8028      	strh	r0, [r5, #0]
    return SDMMC_ERROR_NONE;
 8003842:	4618      	mov	r0, r3
 8003844:	e7e6      	b.n	8003814 <SDMMC_CmdSetRelAdd+0x4c>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 8003846:	0443      	lsls	r3, r0, #17
 8003848:	d40c      	bmi.n	8003864 <SDMMC_CmdSetRelAdd+0x9c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800384a:	f410 4f00 	tst.w	r0, #32768	; 0x8000
 800384e:	bf14      	ite	ne
 8003850:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 8003854:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 8003858:	e7dc      	b.n	8003814 <SDMMC_CmdSetRelAdd+0x4c>
      return SDMMC_ERROR_TIMEOUT;
 800385a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800385e:	e7d9      	b.n	8003814 <SDMMC_CmdSetRelAdd+0x4c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8003860:	2001      	movs	r0, #1
 8003862:	e7d7      	b.n	8003814 <SDMMC_CmdSetRelAdd+0x4c>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8003864:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8003868:	e7d4      	b.n	8003814 <SDMMC_CmdSetRelAdd+0x4c>
 800386a:	bf00      	nop
 800386c:	20000010 	.word	0x20000010

08003870 <SDMMC_CmdSendStatus>:
{
 8003870:	b530      	push	{r4, r5, lr}
 8003872:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003874:	2340      	movs	r3, #64	; 0x40
 8003876:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003878:	2300      	movs	r3, #0
{
 800387a:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 800387c:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800387e:	240d      	movs	r4, #13
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003880:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003882:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003884:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003888:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800388a:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800388c:	f7ff fd5c 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEND_STATUS, SDIO_CMDTIMEOUT);
 8003890:	f241 3288 	movw	r2, #5000	; 0x1388
 8003894:	4621      	mov	r1, r4
 8003896:	4628      	mov	r0, r5
 8003898:	f7ff fd74 	bl	8003384 <SDMMC_GetCmdResp1>
}
 800389c:	b007      	add	sp, #28
 800389e:	bd30      	pop	{r4, r5, pc}

080038a0 <SDMMC_CmdSwitch>:
{
 80038a0:	b530      	push	{r4, r5, lr}
 80038a2:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80038a4:	2340      	movs	r3, #64	; 0x40
 80038a6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80038a8:	2300      	movs	r3, #0
{
 80038aa:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = Argument;
 80038ac:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 80038ae:	2406      	movs	r4, #6
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80038b0:	9304      	str	r3, [sp, #16]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80038b2:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80038b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80038b8:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 80038ba:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80038bc:	f7ff fd44 	bl	8003348 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_HS_SWITCH, SDIO_CMDTIMEOUT);
 80038c0:	f241 3288 	movw	r2, #5000	; 0x1388
 80038c4:	4621      	mov	r1, r4
 80038c6:	4628      	mov	r0, r5
 80038c8:	f7ff fd5c 	bl	8003384 <SDMMC_GetCmdResp1>
}
 80038cc:	b007      	add	sp, #28
 80038ce:	bd30      	pop	{r4, r5, pc}

080038d0 <SDMMC_CmdBusWidth>:
 80038d0:	f7ff bfe6 	b.w	80038a0 <SDMMC_CmdSwitch>

080038d4 <LL_TIM_Init>:
  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));

  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);

  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80038d4:	4a2f      	ldr	r2, [pc, #188]	; (8003994 <LL_TIM_Init+0xc0>)
  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 80038d6:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80038d8:	4290      	cmp	r0, r2
 80038da:	d012      	beq.n	8003902 <LL_TIM_Init+0x2e>
 80038dc:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80038e0:	d00f      	beq.n	8003902 <LL_TIM_Init+0x2e>
 80038e2:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 80038e6:	4290      	cmp	r0, r2
 80038e8:	d00b      	beq.n	8003902 <LL_TIM_Init+0x2e>
 80038ea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80038ee:	4290      	cmp	r0, r2
 80038f0:	d007      	beq.n	8003902 <LL_TIM_Init+0x2e>
 80038f2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80038f6:	4290      	cmp	r0, r2
 80038f8:	d003      	beq.n	8003902 <LL_TIM_Init+0x2e>
 80038fa:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 80038fe:	4290      	cmp	r0, r2
 8003900:	d119      	bne.n	8003936 <LL_TIM_Init+0x62>
  {
    /* Select the Counter Mode */
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 8003902:	684a      	ldr	r2, [r1, #4]
 8003904:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003908:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800390a:	4a22      	ldr	r2, [pc, #136]	; (8003994 <LL_TIM_Init+0xc0>)
 800390c:	4290      	cmp	r0, r2
 800390e:	d029      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003910:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003914:	d026      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003916:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800391a:	4290      	cmp	r0, r2
 800391c:	d022      	beq.n	8003964 <LL_TIM_Init+0x90>
 800391e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003922:	4290      	cmp	r0, r2
 8003924:	d01e      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003926:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800392a:	4290      	cmp	r0, r2
 800392c:	d01a      	beq.n	8003964 <LL_TIM_Init+0x90>
 800392e:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8003932:	4290      	cmp	r0, r2
 8003934:	d016      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003936:	4a18      	ldr	r2, [pc, #96]	; (8003998 <LL_TIM_Init+0xc4>)
 8003938:	4290      	cmp	r0, r2
 800393a:	d013      	beq.n	8003964 <LL_TIM_Init+0x90>
 800393c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003940:	4290      	cmp	r0, r2
 8003942:	d00f      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003944:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003948:	4290      	cmp	r0, r2
 800394a:	d00b      	beq.n	8003964 <LL_TIM_Init+0x90>
 800394c:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003950:	4290      	cmp	r0, r2
 8003952:	d007      	beq.n	8003964 <LL_TIM_Init+0x90>
 8003954:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003958:	4290      	cmp	r0, r2
 800395a:	d003      	beq.n	8003964 <LL_TIM_Init+0x90>
 800395c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003960:	4290      	cmp	r0, r2
 8003962:	d103      	bne.n	800396c <LL_TIM_Init+0x98>
  {
    /* Set the clock division */
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 8003964:	68ca      	ldr	r2, [r1, #12]
 8003966:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800396a:	4313      	orrs	r3, r2
  }

  /* Write to TIMx CR1 */
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 800396c:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 800396e:	688b      	ldr	r3, [r1, #8]
  * @param  AutoReload between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
{
  WRITE_REG(TIMx->ARR, AutoReload);
 8003970:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 8003972:	880b      	ldrh	r3, [r1, #0]
  WRITE_REG(TIMx->PSC, Prescaler);
 8003974:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8003976:	4b07      	ldr	r3, [pc, #28]	; (8003994 <LL_TIM_Init+0xc0>)
 8003978:	4298      	cmp	r0, r3
 800397a:	d003      	beq.n	8003984 <LL_TIM_Init+0xb0>
 800397c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003980:	4298      	cmp	r0, r3
 8003982:	d101      	bne.n	8003988 <LL_TIM_Init+0xb4>
  {
    /* Set the Repetition Counter value */
    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 8003984:	7c0b      	ldrb	r3, [r1, #16]
  * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
{
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8003986:	6303      	str	r3, [r0, #48]	; 0x30
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8003988:	6943      	ldr	r3, [r0, #20]
 800398a:	f043 0301 	orr.w	r3, r3, #1
 800398e:	6143      	str	r3, [r0, #20]
  /* Generate an update event to reload the Prescaler
     and the repetition counter value (if applicable) immediately */
  LL_TIM_GenerateEvent_UPDATE(TIMx);

  return SUCCESS;
}
 8003990:	2001      	movs	r0, #1
 8003992:	4770      	bx	lr
 8003994:	40010000 	.word	0x40010000
 8003998:	40014000 	.word	0x40014000

0800399c <LL_TIM_OC_Init>:
  */
ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
{
  ErrorStatus result = ERROR;

  switch (Channel)
 800399c:	2910      	cmp	r1, #16
{
 800399e:	b530      	push	{r4, r5, lr}
  switch (Channel)
 80039a0:	d066      	beq.n	8003a70 <LL_TIM_OC_Init+0xd4>
 80039a2:	d803      	bhi.n	80039ac <LL_TIM_OC_Init+0x10>
 80039a4:	2901      	cmp	r1, #1
 80039a6:	d02f      	beq.n	8003a08 <LL_TIM_OC_Init+0x6c>
  ErrorStatus result = ERROR;
 80039a8:	2000      	movs	r0, #0
    default:
      break;
  }

  return result;
}
 80039aa:	bd30      	pop	{r4, r5, pc}
  switch (Channel)
 80039ac:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 80039b0:	f000 8094 	beq.w	8003adc <LL_TIM_OC_Init+0x140>
 80039b4:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80039b8:	d1f6      	bne.n	80039a8 <LL_TIM_OC_Init+0xc>
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));

  /* Disable the Channel 4: Reset the CC4E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
 80039ba:	6a03      	ldr	r3, [r0, #32]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
 80039bc:	6815      	ldr	r5, [r2, #0]
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
 80039be:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80039c2:	6203      	str	r3, [r0, #32]
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 80039c4:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
 80039c6:	6844      	ldr	r4, [r0, #4]
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 80039c8:	69c1      	ldr	r1, [r0, #28]
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
 80039ca:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 80039ce:	ea41 2105 	orr.w	r1, r1, r5, lsl #8

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
 80039d2:	6915      	ldr	r5, [r2, #16]
 80039d4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80039d8:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
 80039dc:	6855      	ldr	r5, [r2, #4]
 80039de:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80039e2:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80039e6:	4d58      	ldr	r5, [pc, #352]	; (8003b48 <LL_TIM_OC_Init+0x1ac>)
 80039e8:	42a8      	cmp	r0, r5
 80039ea:	d003      	beq.n	80039f4 <LL_TIM_OC_Init+0x58>
 80039ec:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80039f0:	42a8      	cmp	r0, r5
 80039f2:	d104      	bne.n	80039fe <LL_TIM_OC_Init+0x62>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
 80039f4:	6995      	ldr	r5, [r2, #24]
 80039f6:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
 80039fa:	ea44 1485 	orr.w	r4, r4, r5, lsl #6

  /* Write to TIMx CCMR2 */
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
 80039fe:	68d2      	ldr	r2, [r2, #12]
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 8003a00:	6044      	str	r4, [r0, #4]
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 8003a02:	61c1      	str	r1, [r0, #28]
  WRITE_REG(TIMx->CCR4, CompareValue);
 8003a04:	6402      	str	r2, [r0, #64]	; 0x40
 8003a06:	e030      	b.n	8003a6a <LL_TIM_OC_Init+0xce>
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
 8003a08:	6a03      	ldr	r3, [r0, #32]
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
 8003a0a:	6815      	ldr	r5, [r2, #0]
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
 8003a0c:	f023 0301 	bic.w	r3, r3, #1
 8003a10:	6203      	str	r3, [r0, #32]
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 8003a12:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 8003a14:	6841      	ldr	r1, [r0, #4]
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 8003a16:	6984      	ldr	r4, [r0, #24]
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
 8003a18:	f024 0473 	bic.w	r4, r4, #115	; 0x73
 8003a1c:	432c      	orrs	r4, r5
  MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
 8003a1e:	6915      	ldr	r5, [r2, #16]
 8003a20:	f023 0302 	bic.w	r3, r3, #2
 8003a24:	432b      	orrs	r3, r5
  MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
 8003a26:	6855      	ldr	r5, [r2, #4]
 8003a28:	f023 0301 	bic.w	r3, r3, #1
 8003a2c:	432b      	orrs	r3, r5
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003a2e:	4d46      	ldr	r5, [pc, #280]	; (8003b48 <LL_TIM_OC_Init+0x1ac>)
 8003a30:	42a8      	cmp	r0, r5
 8003a32:	d003      	beq.n	8003a3c <LL_TIM_OC_Init+0xa0>
 8003a34:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003a38:	42a8      	cmp	r0, r5
 8003a3a:	d112      	bne.n	8003a62 <LL_TIM_OC_Init+0xc6>
    MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
 8003a3c:	6955      	ldr	r5, [r2, #20]
 8003a3e:	f023 0308 	bic.w	r3, r3, #8
 8003a42:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
 8003a46:	6895      	ldr	r5, [r2, #8]
 8003a48:	f023 0304 	bic.w	r3, r3, #4
 8003a4c:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
 8003a50:	6995      	ldr	r5, [r2, #24]
 8003a52:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8003a56:	4329      	orrs	r1, r5
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
 8003a58:	69d5      	ldr	r5, [r2, #28]
 8003a5a:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 8003a5e:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
  LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
 8003a62:	68d2      	ldr	r2, [r2, #12]
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 8003a64:	6041      	str	r1, [r0, #4]
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 8003a66:	6184      	str	r4, [r0, #24]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8003a68:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8003a6a:	6203      	str	r3, [r0, #32]
      result = OC4Config(TIMx, TIM_OC_InitStruct);
 8003a6c:	2001      	movs	r0, #1
      break;
 8003a6e:	bd30      	pop	{r4, r5, pc}
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
 8003a70:	6a03      	ldr	r3, [r0, #32]
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
 8003a72:	6815      	ldr	r5, [r2, #0]
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
 8003a74:	f023 0310 	bic.w	r3, r3, #16
 8003a78:	6203      	str	r3, [r0, #32]
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 8003a7a:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 8003a7c:	6841      	ldr	r1, [r0, #4]
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 8003a7e:	6984      	ldr	r4, [r0, #24]
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
 8003a80:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
 8003a84:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
 8003a88:	6915      	ldr	r5, [r2, #16]
 8003a8a:	f023 0320 	bic.w	r3, r3, #32
 8003a8e:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
 8003a92:	6855      	ldr	r5, [r2, #4]
 8003a94:	f023 0310 	bic.w	r3, r3, #16
 8003a98:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003a9c:	4d2a      	ldr	r5, [pc, #168]	; (8003b48 <LL_TIM_OC_Init+0x1ac>)
 8003a9e:	42a8      	cmp	r0, r5
 8003aa0:	d003      	beq.n	8003aaa <LL_TIM_OC_Init+0x10e>
 8003aa2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003aa6:	42a8      	cmp	r0, r5
 8003aa8:	d113      	bne.n	8003ad2 <LL_TIM_OC_Init+0x136>
    MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
 8003aaa:	6955      	ldr	r5, [r2, #20]
 8003aac:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003ab0:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
    MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
 8003ab4:	6895      	ldr	r5, [r2, #8]
 8003ab6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003aba:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
 8003abe:	6995      	ldr	r5, [r2, #24]
 8003ac0:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8003ac4:	ea41 0185 	orr.w	r1, r1, r5, lsl #2
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
 8003ac8:	69d5      	ldr	r5, [r2, #28]
 8003aca:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 8003ace:	ea41 01c5 	orr.w	r1, r1, r5, lsl #3
  LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
 8003ad2:	68d2      	ldr	r2, [r2, #12]
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 8003ad4:	6041      	str	r1, [r0, #4]
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 8003ad6:	6184      	str	r4, [r0, #24]
  WRITE_REG(TIMx->CCR2, CompareValue);
 8003ad8:	6382      	str	r2, [r0, #56]	; 0x38
 8003ada:	e7c6      	b.n	8003a6a <LL_TIM_OC_Init+0xce>
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
 8003adc:	6a03      	ldr	r3, [r0, #32]
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
 8003ade:	6815      	ldr	r5, [r2, #0]
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
 8003ae0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003ae4:	6203      	str	r3, [r0, #32]
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 8003ae6:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 8003ae8:	6841      	ldr	r1, [r0, #4]
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 8003aea:	69c4      	ldr	r4, [r0, #28]
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
 8003aec:	f024 0473 	bic.w	r4, r4, #115	; 0x73
 8003af0:	432c      	orrs	r4, r5
  MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
 8003af2:	6915      	ldr	r5, [r2, #16]
 8003af4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003af8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
 8003afc:	6855      	ldr	r5, [r2, #4]
 8003afe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003b02:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003b06:	4d10      	ldr	r5, [pc, #64]	; (8003b48 <LL_TIM_OC_Init+0x1ac>)
 8003b08:	42a8      	cmp	r0, r5
 8003b0a:	d003      	beq.n	8003b14 <LL_TIM_OC_Init+0x178>
 8003b0c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003b10:	42a8      	cmp	r0, r5
 8003b12:	d113      	bne.n	8003b3c <LL_TIM_OC_Init+0x1a0>
    MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
 8003b14:	6955      	ldr	r5, [r2, #20]
 8003b16:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003b1a:	ea43 2385 	orr.w	r3, r3, r5, lsl #10
    MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
 8003b1e:	6895      	ldr	r5, [r2, #8]
 8003b20:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003b24:	ea43 2385 	orr.w	r3, r3, r5, lsl #10
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
 8003b28:	6995      	ldr	r5, [r2, #24]
 8003b2a:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8003b2e:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
 8003b32:	69d5      	ldr	r5, [r2, #28]
 8003b34:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8003b38:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
  LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
 8003b3c:	68d2      	ldr	r2, [r2, #12]
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 8003b3e:	6041      	str	r1, [r0, #4]
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 8003b40:	61c4      	str	r4, [r0, #28]
  WRITE_REG(TIMx->CCR3, CompareValue);
 8003b42:	63c2      	str	r2, [r0, #60]	; 0x3c
 8003b44:	e791      	b.n	8003a6a <LL_TIM_OC_Init+0xce>
 8003b46:	bf00      	nop
 8003b48:	40010000 	.word	0x40010000

08003b4c <LL_TIM_BDTR_Init>:
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
 8003b4c:	688a      	ldr	r2, [r1, #8]
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
 8003b4e:	7b0b      	ldrb	r3, [r1, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
 8003b50:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
 8003b52:	684a      	ldr	r2, [r1, #4]
 8003b54:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003b58:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
 8003b5a:	680a      	ldr	r2, [r1, #0]
 8003b5c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003b60:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
 8003b62:	89ca      	ldrh	r2, [r1, #14]
 8003b64:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003b68:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
 8003b6a:	690a      	ldr	r2, [r1, #16]
 8003b6c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003b70:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
 8003b72:	694a      	ldr	r2, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
 8003b74:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8003b78:	4313      	orrs	r3, r2
  LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
 8003b7a:	6443      	str	r3, [r0, #68]	; 0x44
}
 8003b7c:	2001      	movs	r0, #1
 8003b7e:	4770      	bx	lr

08003b80 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 8003b80:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 8003b82:	4b0f      	ldr	r3, [pc, #60]	; (8003bc0 <FATFS_LinkDriverEx+0x40>)
 8003b84:	7a5d      	ldrb	r5, [r3, #9]
 8003b86:	f005 04ff 	and.w	r4, r5, #255	; 0xff
 8003b8a:	b9b5      	cbnz	r5, 8003bba <FATFS_LinkDriverEx+0x3a>
  {
    disk.is_initialized[disk.nbr] = 0;
 8003b8c:	7a5d      	ldrb	r5, [r3, #9]
 8003b8e:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;
 8003b90:	7a5d      	ldrb	r5, [r3, #9]
 8003b92:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8003b96:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;
 8003b98:	7a58      	ldrb	r0, [r3, #9]
 8003b9a:	4418      	add	r0, r3
 8003b9c:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 8003b9e:	7a5a      	ldrb	r2, [r3, #9]
 8003ba0:	b2d2      	uxtb	r2, r2
 8003ba2:	1c50      	adds	r0, r2, #1
 8003ba4:	b2c0      	uxtb	r0, r0
 8003ba6:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 8003ba8:	233a      	movs	r3, #58	; 0x3a
    path[0] = DiskNum + '0';
 8003baa:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 8003bac:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 8003bae:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 8003bb0:	700a      	strb	r2, [r1, #0]
    path[2] = '/';
 8003bb2:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 8003bb4:	70cc      	strb	r4, [r1, #3]
 8003bb6:	4620      	mov	r0, r4
 8003bb8:	bd30      	pop	{r4, r5, pc}
  uint8_t ret = 1;
 8003bba:	2001      	movs	r0, #1
    ret = 0;
  }

  return ret;
}
 8003bbc:	bd30      	pop	{r4, r5, pc}
 8003bbe:	bf00      	nop
 8003bc0:	200001d0 	.word	0x200001d0

08003bc4 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 8003bc4:	2200      	movs	r2, #0
 8003bc6:	f7ff bfdb 	b.w	8003b80 <FATFS_LinkDriverEx>

08003bca <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8003bca:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8003bcc:	f000 ffa2 	bl	8004b14 <vTaskStartScheduler>
  
  return osOK;
}
 8003bd0:	2000      	movs	r0, #0
 8003bd2:	bd08      	pop	{r3, pc}

08003bd4 <osKernelRunning>:
*         (1) RTOS is started
*         (-1) if this feature is disabled in FreeRTOSConfig.h 
* @note  MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS.
*/
int32_t osKernelRunning(void)
{
 8003bd4:	b508      	push	{r3, lr}
#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
  if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
 8003bd6:	f001 fa3d 	bl	8005054 <xTaskGetSchedulerState>
  else
    return 1;
#else
	return (-1);
#endif	
}
 8003bda:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
 8003bde:	bf18      	it	ne
 8003be0:	2001      	movne	r0, #1
 8003be2:	bd08      	pop	{r3, pc}

08003be4 <osKernelSysTick>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003be4:	f3ef 8305 	mrs	r3, IPSR
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
  if (inHandlerMode()) {
 8003be8:	b10b      	cbz	r3, 8003bee <osKernelSysTick+0xa>
    return xTaskGetTickCountFromISR();
 8003bea:	f000 bfdd 	b.w	8004ba8 <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
 8003bee:	f000 bfd5 	b.w	8004b9c <xTaskGetTickCount>

08003bf2 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8003bf2:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003bf4:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 8003bf8:	8a02      	ldrh	r2, [r0, #16]
{
 8003bfa:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003bfc:	e890 0022 	ldmia.w	r0, {r1, r5}
{
 8003c00:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 8003c02:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8003c04:	bf14      	ite	ne
 8003c06:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8003c08:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003c0a:	a803      	add	r0, sp, #12
 8003c0c:	9001      	str	r0, [sp, #4]
 8003c0e:	9400      	str	r4, [sp, #0]
 8003c10:	4628      	mov	r0, r5
 8003c12:	f000 feaf 	bl	8004974 <xTaskCreate>
 8003c16:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8003c18:	bf0c      	ite	eq
 8003c1a:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 8003c1c:	2000      	movne	r0, #0
}
 8003c1e:	b005      	add	sp, #20
 8003c20:	bd30      	pop	{r4, r5, pc}

08003c22 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8003c22:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8003c24:	2800      	cmp	r0, #0
 8003c26:	bf08      	it	eq
 8003c28:	2001      	moveq	r0, #1
 8003c2a:	f001 f8cf 	bl	8004dcc <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8003c2e:	2000      	movs	r0, #0
 8003c30:	bd08      	pop	{r3, pc}

08003c32 <osMessageCreate>:
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 8003c32:	2200      	movs	r2, #0
 8003c34:	c803      	ldmia	r0, {r0, r1}
 8003c36:	f000 bbed 	b.w	8004414 <xQueueGenericCreate>
	...

08003c3c <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8003c3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 8003c3e:	2400      	movs	r4, #0
{
 8003c40:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8003c42:	9403      	str	r4, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
    ticks = 1;
 8003c44:	42a2      	cmp	r2, r4
 8003c46:	bf08      	it	eq
 8003c48:	2201      	moveq	r2, #1
 8003c4a:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 8003c4e:	b1ab      	cbz	r3, 8003c7c <osMessagePut+0x40>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 8003c50:	4623      	mov	r3, r4
 8003c52:	aa03      	add	r2, sp, #12
 8003c54:	a901      	add	r1, sp, #4
 8003c56:	f000 fcb5 	bl	80045c4 <xQueueGenericSendFromISR>
 8003c5a:	2801      	cmp	r0, #1
 8003c5c:	d002      	beq.n	8003c64 <osMessagePut+0x28>
      return osErrorOS;
 8003c5e:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 8003c60:	b004      	add	sp, #16
 8003c62:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 8003c64:	9b03      	ldr	r3, [sp, #12]
 8003c66:	b13b      	cbz	r3, 8003c78 <osMessagePut+0x3c>
 8003c68:	4b07      	ldr	r3, [pc, #28]	; (8003c88 <osMessagePut+0x4c>)
 8003c6a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003c6e:	601a      	str	r2, [r3, #0]
 8003c70:	f3bf 8f4f 	dsb	sy
 8003c74:	f3bf 8f6f 	isb	sy
  return osOK;
 8003c78:	2000      	movs	r0, #0
 8003c7a:	e7f1      	b.n	8003c60 <osMessagePut+0x24>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 8003c7c:	a901      	add	r1, sp, #4
 8003c7e:	f000 fbeb 	bl	8004458 <xQueueGenericSend>
 8003c82:	2801      	cmp	r0, #1
 8003c84:	d1eb      	bne.n	8003c5e <osMessagePut+0x22>
 8003c86:	e7f7      	b.n	8003c78 <osMessagePut+0x3c>
 8003c88:	e000ed04 	.word	0xe000ed04

08003c8c <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 8003c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003c8e:	b085      	sub	sp, #20
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 8003c90:	2600      	movs	r6, #0
{
 8003c92:	4604      	mov	r4, r0
 8003c94:	4617      	mov	r7, r2
 8003c96:	4608      	mov	r0, r1
  event.def.message_id = queue_id;
 8003c98:	9103      	str	r1, [sp, #12]
  event.value.v = 0;
 8003c9a:	9602      	str	r6, [sp, #8]
 8003c9c:	ad01      	add	r5, sp, #4
  
  if (queue_id == NULL) {
 8003c9e:	b911      	cbnz	r1, 8003ca6 <osMessageGet+0x1a>
    event.status = osErrorParameter;
 8003ca0:	2380      	movs	r3, #128	; 0x80
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8003ca2:	9301      	str	r3, [sp, #4]
 8003ca4:	e017      	b.n	8003cd6 <osMessageGet+0x4a>
  taskWoken = pdFALSE;
 8003ca6:	9600      	str	r6, [sp, #0]
 8003ca8:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 8003cac:	b1d3      	cbz	r3, 8003ce4 <osMessageGet+0x58>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 8003cae:	466a      	mov	r2, sp
 8003cb0:	a902      	add	r1, sp, #8
 8003cb2:	f000 fdad 	bl	8004810 <xQueueReceiveFromISR>
 8003cb6:	2801      	cmp	r0, #1
      event.status = osEventMessage;
 8003cb8:	bf04      	itt	eq
 8003cba:	2310      	moveq	r3, #16
 8003cbc:	9301      	streq	r3, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8003cbe:	9b00      	ldr	r3, [sp, #0]
      event.status = osOK;
 8003cc0:	bf18      	it	ne
 8003cc2:	9601      	strne	r6, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8003cc4:	b13b      	cbz	r3, 8003cd6 <osMessageGet+0x4a>
 8003cc6:	4b0d      	ldr	r3, [pc, #52]	; (8003cfc <osMessageGet+0x70>)
 8003cc8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003ccc:	601a      	str	r2, [r3, #0]
 8003cce:	f3bf 8f4f 	dsb	sy
 8003cd2:	f3bf 8f6f 	isb	sy
    }
  }
  
  return event;
 8003cd6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8003cda:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8003cde:	4620      	mov	r0, r4
 8003ce0:	b005      	add	sp, #20
 8003ce2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 8003ce4:	a902      	add	r1, sp, #8
 8003ce6:	f000 fccf 	bl	8004688 <xQueueGenericReceive>
 8003cea:	2801      	cmp	r0, #1
 8003cec:	d101      	bne.n	8003cf2 <osMessageGet+0x66>
      event.status = osEventMessage;
 8003cee:	2310      	movs	r3, #16
 8003cf0:	e7d7      	b.n	8003ca2 <osMessageGet+0x16>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8003cf2:	2f00      	cmp	r7, #0
 8003cf4:	bf0c      	ite	eq
 8003cf6:	2300      	moveq	r3, #0
 8003cf8:	2340      	movne	r3, #64	; 0x40
 8003cfa:	e7d2      	b.n	8003ca2 <osMessageGet+0x16>
 8003cfc:	e000ed04 	.word	0xe000ed04

08003d00 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8003d00:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8003d02:	f001 f9a7 	bl	8005054 <xTaskGetSchedulerState>
 8003d06:	2801      	cmp	r0, #1
 8003d08:	d003      	beq.n	8003d12 <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 8003d0a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 8003d0e:	f000 b909 	b.w	8003f24 <xPortSysTickHandler>
 8003d12:	bd08      	pop	{r3, pc}

08003d14 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003d14:	f100 0308 	add.w	r3, r0, #8
 8003d18:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003d1a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003d1e:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003d20:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003d22:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003d24:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003d26:	6003      	str	r3, [r0, #0]
 8003d28:	4770      	bx	lr

08003d2a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003d2a:	2300      	movs	r3, #0
 8003d2c:	6103      	str	r3, [r0, #16]
 8003d2e:	4770      	bx	lr

08003d30 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8003d30:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003d32:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003d34:	689a      	ldr	r2, [r3, #8]
 8003d36:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003d38:	689a      	ldr	r2, [r3, #8]
 8003d3a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003d3c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003d3e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003d40:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003d42:	3301      	adds	r3, #1
 8003d44:	6003      	str	r3, [r0, #0]
 8003d46:	4770      	bx	lr

08003d48 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003d48:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003d4a:	1c53      	adds	r3, r2, #1
{
 8003d4c:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 8003d4e:	d10a      	bne.n	8003d66 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8003d50:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003d52:	685a      	ldr	r2, [r3, #4]
 8003d54:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003d56:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003d58:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003d5a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003d5c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003d5e:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003d60:	3301      	adds	r3, #1
 8003d62:	6003      	str	r3, [r0, #0]
 8003d64:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003d66:	f100 0308 	add.w	r3, r0, #8
 8003d6a:	685c      	ldr	r4, [r3, #4]
 8003d6c:	6825      	ldr	r5, [r4, #0]
 8003d6e:	42aa      	cmp	r2, r5
 8003d70:	d3ef      	bcc.n	8003d52 <vListInsert+0xa>
 8003d72:	4623      	mov	r3, r4
 8003d74:	e7f9      	b.n	8003d6a <vListInsert+0x22>

08003d76 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003d76:	6841      	ldr	r1, [r0, #4]
 8003d78:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8003d7a:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003d7c:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003d7e:	6882      	ldr	r2, [r0, #8]
 8003d80:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003d82:	6859      	ldr	r1, [r3, #4]
 8003d84:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003d86:	bf08      	it	eq
 8003d88:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003d8a:	2200      	movs	r2, #0
 8003d8c:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003d8e:	6818      	ldr	r0, [r3, #0]
 8003d90:	3801      	subs	r0, #1
 8003d92:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8003d94:	4770      	bx	lr
	...

08003d98 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8003d98:	4b0a      	ldr	r3, [pc, #40]	; (8003dc4 <prvTaskExitError+0x2c>)
 8003d9a:	681b      	ldr	r3, [r3, #0]
 8003d9c:	3301      	adds	r3, #1
 8003d9e:	d008      	beq.n	8003db2 <prvTaskExitError+0x1a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8003da0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003da4:	f383 8811 	msr	BASEPRI, r3
 8003da8:	f3bf 8f6f 	isb	sy
 8003dac:	f3bf 8f4f 	dsb	sy
 8003db0:	e7fe      	b.n	8003db0 <prvTaskExitError+0x18>
 8003db2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003db6:	f383 8811 	msr	BASEPRI, r3
 8003dba:	f3bf 8f6f 	isb	sy
 8003dbe:	f3bf 8f4f 	dsb	sy
 8003dc2:	e7fe      	b.n	8003dc2 <prvTaskExitError+0x2a>
 8003dc4:	20000008 	.word	0x20000008

08003dc8 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8003dc8:	4806      	ldr	r0, [pc, #24]	; (8003de4 <prvPortStartFirstTask+0x1c>)
 8003dca:	6800      	ldr	r0, [r0, #0]
 8003dcc:	6800      	ldr	r0, [r0, #0]
 8003dce:	f380 8808 	msr	MSP, r0
 8003dd2:	b662      	cpsie	i
 8003dd4:	b661      	cpsie	f
 8003dd6:	f3bf 8f4f 	dsb	sy
 8003dda:	f3bf 8f6f 	isb	sy
 8003dde:	df00      	svc	0
 8003de0:	bf00      	nop
 8003de2:	0000      	.short	0x0000
 8003de4:	e000ed08 	.word	0xe000ed08

08003de8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8003de8:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8003df8 <vPortEnableVFP+0x10>
 8003dec:	6801      	ldr	r1, [r0, #0]
 8003dee:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8003df2:	6001      	str	r1, [r0, #0]
 8003df4:	4770      	bx	lr
 8003df6:	0000      	.short	0x0000
 8003df8:	e000ed88 	.word	0xe000ed88

08003dfc <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8003dfc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003e00:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8003e04:	4b07      	ldr	r3, [pc, #28]	; (8003e24 <pxPortInitialiseStack+0x28>)
 8003e06:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8003e0a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8003e0e:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8003e12:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8003e16:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8003e1a:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8003e1e:	3844      	subs	r0, #68	; 0x44
 8003e20:	4770      	bx	lr
 8003e22:	bf00      	nop
 8003e24:	08003d99 	.word	0x08003d99
	...

08003e30 <SVC_Handler>:
	__asm volatile (
 8003e30:	4b07      	ldr	r3, [pc, #28]	; (8003e50 <pxCurrentTCBConst2>)
 8003e32:	6819      	ldr	r1, [r3, #0]
 8003e34:	6808      	ldr	r0, [r1, #0]
 8003e36:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003e3a:	f380 8809 	msr	PSP, r0
 8003e3e:	f3bf 8f6f 	isb	sy
 8003e42:	f04f 0000 	mov.w	r0, #0
 8003e46:	f380 8811 	msr	BASEPRI, r0
 8003e4a:	4770      	bx	lr
 8003e4c:	f3af 8000 	nop.w

08003e50 <pxCurrentTCBConst2>:
 8003e50:	20003dfc 	.word	0x20003dfc

08003e54 <vPortEnterCritical>:
 8003e54:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003e58:	f383 8811 	msr	BASEPRI, r3
 8003e5c:	f3bf 8f6f 	isb	sy
 8003e60:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8003e64:	4a0a      	ldr	r2, [pc, #40]	; (8003e90 <vPortEnterCritical+0x3c>)
 8003e66:	6813      	ldr	r3, [r2, #0]
 8003e68:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 8003e6a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 8003e6c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8003e6e:	d10d      	bne.n	8003e8c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8003e70:	4b08      	ldr	r3, [pc, #32]	; (8003e94 <vPortEnterCritical+0x40>)
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	f013 0fff 	tst.w	r3, #255	; 0xff
 8003e78:	d008      	beq.n	8003e8c <vPortEnterCritical+0x38>
 8003e7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003e7e:	f383 8811 	msr	BASEPRI, r3
 8003e82:	f3bf 8f6f 	isb	sy
 8003e86:	f3bf 8f4f 	dsb	sy
 8003e8a:	e7fe      	b.n	8003e8a <vPortEnterCritical+0x36>
 8003e8c:	4770      	bx	lr
 8003e8e:	bf00      	nop
 8003e90:	20000008 	.word	0x20000008
 8003e94:	e000ed04 	.word	0xe000ed04

08003e98 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8003e98:	4a08      	ldr	r2, [pc, #32]	; (8003ebc <vPortExitCritical+0x24>)
 8003e9a:	6813      	ldr	r3, [r2, #0]
 8003e9c:	b943      	cbnz	r3, 8003eb0 <vPortExitCritical+0x18>
 8003e9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003ea2:	f383 8811 	msr	BASEPRI, r3
 8003ea6:	f3bf 8f6f 	isb	sy
 8003eaa:	f3bf 8f4f 	dsb	sy
 8003eae:	e7fe      	b.n	8003eae <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8003eb0:	3b01      	subs	r3, #1
 8003eb2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8003eb4:	b90b      	cbnz	r3, 8003eba <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8003eb6:	f383 8811 	msr	BASEPRI, r3
 8003eba:	4770      	bx	lr
 8003ebc:	20000008 	.word	0x20000008

08003ec0 <PendSV_Handler>:
	__asm volatile
 8003ec0:	f3ef 8009 	mrs	r0, PSP
 8003ec4:	f3bf 8f6f 	isb	sy
 8003ec8:	4b15      	ldr	r3, [pc, #84]	; (8003f20 <pxCurrentTCBConst>)
 8003eca:	681a      	ldr	r2, [r3, #0]
 8003ecc:	f01e 0f10 	tst.w	lr, #16
 8003ed0:	bf08      	it	eq
 8003ed2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8003ed6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003eda:	6010      	str	r0, [r2, #0]
 8003edc:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8003ee0:	f04f 0050 	mov.w	r0, #80	; 0x50
 8003ee4:	f380 8811 	msr	BASEPRI, r0
 8003ee8:	f3bf 8f4f 	dsb	sy
 8003eec:	f3bf 8f6f 	isb	sy
 8003ef0:	f000 ffca 	bl	8004e88 <vTaskSwitchContext>
 8003ef4:	f04f 0000 	mov.w	r0, #0
 8003ef8:	f380 8811 	msr	BASEPRI, r0
 8003efc:	bc08      	pop	{r3}
 8003efe:	6819      	ldr	r1, [r3, #0]
 8003f00:	6808      	ldr	r0, [r1, #0]
 8003f02:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f06:	f01e 0f10 	tst.w	lr, #16
 8003f0a:	bf08      	it	eq
 8003f0c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8003f10:	f380 8809 	msr	PSP, r0
 8003f14:	f3bf 8f6f 	isb	sy
 8003f18:	4770      	bx	lr
 8003f1a:	bf00      	nop
 8003f1c:	f3af 8000 	nop.w

08003f20 <pxCurrentTCBConst>:
 8003f20:	20003dfc 	.word	0x20003dfc

08003f24 <xPortSysTickHandler>:
{
 8003f24:	b508      	push	{r3, lr}
	__asm volatile
 8003f26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003f2a:	f383 8811 	msr	BASEPRI, r3
 8003f2e:	f3bf 8f6f 	isb	sy
 8003f32:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8003f36:	f000 fe3f 	bl	8004bb8 <xTaskIncrementTick>
 8003f3a:	b118      	cbz	r0, 8003f44 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8003f3c:	4b03      	ldr	r3, [pc, #12]	; (8003f4c <xPortSysTickHandler+0x28>)
 8003f3e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003f42:	601a      	str	r2, [r3, #0]
	__asm volatile
 8003f44:	2300      	movs	r3, #0
 8003f46:	f383 8811 	msr	BASEPRI, r3
 8003f4a:	bd08      	pop	{r3, pc}
 8003f4c:	e000ed04 	.word	0xe000ed04

08003f50 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8003f50:	4b06      	ldr	r3, [pc, #24]	; (8003f6c <vPortSetupTimerInterrupt+0x1c>)
 8003f52:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003f56:	681b      	ldr	r3, [r3, #0]
 8003f58:	fbb3 f3f2 	udiv	r3, r3, r2
 8003f5c:	4a04      	ldr	r2, [pc, #16]	; (8003f70 <vPortSetupTimerInterrupt+0x20>)
 8003f5e:	3b01      	subs	r3, #1
 8003f60:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8003f62:	4b04      	ldr	r3, [pc, #16]	; (8003f74 <vPortSetupTimerInterrupt+0x24>)
 8003f64:	2207      	movs	r2, #7
 8003f66:	601a      	str	r2, [r3, #0]
 8003f68:	4770      	bx	lr
 8003f6a:	bf00      	nop
 8003f6c:	20000010 	.word	0x20000010
 8003f70:	e000e014 	.word	0xe000e014
 8003f74:	e000e010 	.word	0xe000e010

08003f78 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8003f78:	4b31      	ldr	r3, [pc, #196]	; (8004040 <xPortStartScheduler+0xc8>)
 8003f7a:	4a32      	ldr	r2, [pc, #200]	; (8004044 <xPortStartScheduler+0xcc>)
{
 8003f7c:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8003f7e:	6819      	ldr	r1, [r3, #0]
 8003f80:	4291      	cmp	r1, r2
 8003f82:	d108      	bne.n	8003f96 <xPortStartScheduler+0x1e>
	__asm volatile
 8003f84:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003f88:	f383 8811 	msr	BASEPRI, r3
 8003f8c:	f3bf 8f6f 	isb	sy
 8003f90:	f3bf 8f4f 	dsb	sy
 8003f94:	e7fe      	b.n	8003f94 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8003f96:	681a      	ldr	r2, [r3, #0]
 8003f98:	4b2b      	ldr	r3, [pc, #172]	; (8004048 <xPortStartScheduler+0xd0>)
 8003f9a:	429a      	cmp	r2, r3
 8003f9c:	d108      	bne.n	8003fb0 <xPortStartScheduler+0x38>
 8003f9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003fa2:	f383 8811 	msr	BASEPRI, r3
 8003fa6:	f3bf 8f6f 	isb	sy
 8003faa:	f3bf 8f4f 	dsb	sy
 8003fae:	e7fe      	b.n	8003fae <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8003fb0:	4b26      	ldr	r3, [pc, #152]	; (800404c <xPortStartScheduler+0xd4>)
 8003fb2:	781a      	ldrb	r2, [r3, #0]
 8003fb4:	b2d2      	uxtb	r2, r2
 8003fb6:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8003fb8:	22ff      	movs	r2, #255	; 0xff
 8003fba:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8003fbc:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8003fbe:	4a24      	ldr	r2, [pc, #144]	; (8004050 <xPortStartScheduler+0xd8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8003fc0:	b2db      	uxtb	r3, r3
 8003fc2:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8003fc6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003fca:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8003fce:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8003fd0:	4b20      	ldr	r3, [pc, #128]	; (8004054 <xPortStartScheduler+0xdc>)
 8003fd2:	2207      	movs	r2, #7
 8003fd4:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8003fd6:	2100      	movs	r1, #0
 8003fd8:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8003fdc:	0600      	lsls	r0, r0, #24
 8003fde:	f102 34ff 	add.w	r4, r2, #4294967295	; 0xffffffff
 8003fe2:	d423      	bmi.n	800402c <xPortStartScheduler+0xb4>
 8003fe4:	b101      	cbz	r1, 8003fe8 <xPortStartScheduler+0x70>
 8003fe6:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8003fe8:	681a      	ldr	r2, [r3, #0]
 8003fea:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8003fec:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8003ff0:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8003ff2:	9b01      	ldr	r3, [sp, #4]
 8003ff4:	4a15      	ldr	r2, [pc, #84]	; (800404c <xPortStartScheduler+0xd4>)
 8003ff6:	b2db      	uxtb	r3, r3
 8003ff8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8003ffa:	4b17      	ldr	r3, [pc, #92]	; (8004058 <xPortStartScheduler+0xe0>)
 8003ffc:	681a      	ldr	r2, [r3, #0]
 8003ffe:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8004002:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8004004:	681a      	ldr	r2, [r3, #0]
 8004006:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800400a:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800400c:	f7ff ffa0 	bl	8003f50 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8004010:	4b12      	ldr	r3, [pc, #72]	; (800405c <xPortStartScheduler+0xe4>)
 8004012:	2200      	movs	r2, #0
 8004014:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 8004016:	f7ff fee7 	bl	8003de8 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800401a:	4a11      	ldr	r2, [pc, #68]	; (8004060 <xPortStartScheduler+0xe8>)
 800401c:	6813      	ldr	r3, [r2, #0]
 800401e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8004022:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8004024:	f7ff fed0 	bl	8003dc8 <prvPortStartFirstTask>
	prvTaskExitError();
 8004028:	f7ff feb6 	bl	8003d98 <prvTaskExitError>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800402c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004030:	0052      	lsls	r2, r2, #1
 8004032:	b2d2      	uxtb	r2, r2
 8004034:	f88d 2003 	strb.w	r2, [sp, #3]
 8004038:	2101      	movs	r1, #1
 800403a:	4622      	mov	r2, r4
 800403c:	e7cc      	b.n	8003fd8 <xPortStartScheduler+0x60>
 800403e:	bf00      	nop
 8004040:	e000ed00 	.word	0xe000ed00
 8004044:	410fc271 	.word	0x410fc271
 8004048:	410fc270 	.word	0x410fc270
 800404c:	e000e400 	.word	0xe000e400
 8004050:	200001dc 	.word	0x200001dc
 8004054:	200001e0 	.word	0x200001e0
 8004058:	e000ed20 	.word	0xe000ed20
 800405c:	20000008 	.word	0x20000008
 8004060:	e000ef34 	.word	0xe000ef34

08004064 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004064:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004068:	2b0f      	cmp	r3, #15
 800406a:	d90e      	bls.n	800408a <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800406c:	4a10      	ldr	r2, [pc, #64]	; (80040b0 <vPortValidateInterruptPriority+0x4c>)
 800406e:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004070:	4a10      	ldr	r2, [pc, #64]	; (80040b4 <vPortValidateInterruptPriority+0x50>)
 8004072:	7812      	ldrb	r2, [r2, #0]
 8004074:	429a      	cmp	r2, r3
 8004076:	d908      	bls.n	800408a <vPortValidateInterruptPriority+0x26>
 8004078:	f04f 0350 	mov.w	r3, #80	; 0x50
 800407c:	f383 8811 	msr	BASEPRI, r3
 8004080:	f3bf 8f6f 	isb	sy
 8004084:	f3bf 8f4f 	dsb	sy
 8004088:	e7fe      	b.n	8004088 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800408a:	4b0b      	ldr	r3, [pc, #44]	; (80040b8 <vPortValidateInterruptPriority+0x54>)
 800408c:	4a0b      	ldr	r2, [pc, #44]	; (80040bc <vPortValidateInterruptPriority+0x58>)
 800408e:	681b      	ldr	r3, [r3, #0]
 8004090:	6812      	ldr	r2, [r2, #0]
 8004092:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004096:	4293      	cmp	r3, r2
 8004098:	d908      	bls.n	80040ac <vPortValidateInterruptPriority+0x48>
 800409a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800409e:	f383 8811 	msr	BASEPRI, r3
 80040a2:	f3bf 8f6f 	isb	sy
 80040a6:	f3bf 8f4f 	dsb	sy
 80040aa:	e7fe      	b.n	80040aa <vPortValidateInterruptPriority+0x46>
 80040ac:	4770      	bx	lr
 80040ae:	bf00      	nop
 80040b0:	e000e3f0 	.word	0xe000e3f0
 80040b4:	200001dc 	.word	0x200001dc
 80040b8:	e000ed0c 	.word	0xe000ed0c
 80040bc:	200001e0 	.word	0x200001e0

080040c0 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 80040c0:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80040c2:	4b0f      	ldr	r3, [pc, #60]	; (8004100 <prvInsertBlockIntoFreeList+0x40>)
 80040c4:	681a      	ldr	r2, [r3, #0]
 80040c6:	4282      	cmp	r2, r0
 80040c8:	d318      	bcc.n	80040fc <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80040ca:	685c      	ldr	r4, [r3, #4]
 80040cc:	1919      	adds	r1, r3, r4
 80040ce:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80040d0:	bf01      	itttt	eq
 80040d2:	6841      	ldreq	r1, [r0, #4]
 80040d4:	4618      	moveq	r0, r3
 80040d6:	1909      	addeq	r1, r1, r4
 80040d8:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80040da:	6844      	ldr	r4, [r0, #4]
 80040dc:	1901      	adds	r1, r0, r4
 80040de:	428a      	cmp	r2, r1
 80040e0:	d107      	bne.n	80040f2 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80040e2:	4908      	ldr	r1, [pc, #32]	; (8004104 <prvInsertBlockIntoFreeList+0x44>)
 80040e4:	6809      	ldr	r1, [r1, #0]
 80040e6:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80040e8:	bf1f      	itttt	ne
 80040ea:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80040ec:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80040ee:	1909      	addne	r1, r1, r4
 80040f0:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80040f2:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80040f4:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80040f6:	bf18      	it	ne
 80040f8:	6018      	strne	r0, [r3, #0]
 80040fa:	bd10      	pop	{r4, pc}
 80040fc:	4613      	mov	r3, r2
 80040fe:	e7e1      	b.n	80040c4 <prvInsertBlockIntoFreeList+0x4>
 8004100:	20003df4 	.word	0x20003df4
 8004104:	200001e4 	.word	0x200001e4

08004108 <pvPortMalloc>:
{
 8004108:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800410c:	4604      	mov	r4, r0
	vTaskSuspendAll();
 800410e:	f000 fd3d 	bl	8004b8c <vTaskSuspendAll>
		if( pxEnd == NULL )
 8004112:	493e      	ldr	r1, [pc, #248]	; (800420c <pvPortMalloc+0x104>)
 8004114:	4d3e      	ldr	r5, [pc, #248]	; (8004210 <pvPortMalloc+0x108>)
 8004116:	680b      	ldr	r3, [r1, #0]
 8004118:	bb0b      	cbnz	r3, 800415e <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 800411a:	4a3e      	ldr	r2, [pc, #248]	; (8004214 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800411c:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800411e:	bf1f      	itttt	ne
 8004120:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8004122:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8004126:	f502 5370 	addne.w	r3, r2, #15360	; 0x3c00
 800412a:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800412c:	bf14      	ite	ne
 800412e:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8004130:	f44f 5370 	moveq.w	r3, #15360	; 0x3c00
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8004134:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8004136:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8004138:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800413c:	4e36      	ldr	r6, [pc, #216]	; (8004218 <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 800413e:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8004140:	2000      	movs	r0, #0
 8004142:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004144:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8004146:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8004148:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800414a:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800414c:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800414e:	4b33      	ldr	r3, [pc, #204]	; (800421c <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8004150:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004152:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004154:	4b32      	ldr	r3, [pc, #200]	; (8004220 <pvPortMalloc+0x118>)
 8004156:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004158:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800415c:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800415e:	682f      	ldr	r7, [r5, #0]
 8004160:	4227      	tst	r7, r4
 8004162:	d116      	bne.n	8004192 <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8004164:	2c00      	cmp	r4, #0
 8004166:	d041      	beq.n	80041ec <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8004168:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800416c:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800416e:	bf1c      	itt	ne
 8004170:	f023 0307 	bicne.w	r3, r3, #7
 8004174:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004176:	b163      	cbz	r3, 8004192 <pvPortMalloc+0x8a>
 8004178:	4a29      	ldr	r2, [pc, #164]	; (8004220 <pvPortMalloc+0x118>)
 800417a:	6816      	ldr	r6, [r2, #0]
 800417c:	42b3      	cmp	r3, r6
 800417e:	4690      	mov	r8, r2
 8004180:	d807      	bhi.n	8004192 <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8004182:	4a25      	ldr	r2, [pc, #148]	; (8004218 <pvPortMalloc+0x110>)
 8004184:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004186:	6868      	ldr	r0, [r5, #4]
 8004188:	4283      	cmp	r3, r0
 800418a:	d804      	bhi.n	8004196 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 800418c:	6809      	ldr	r1, [r1, #0]
 800418e:	428d      	cmp	r5, r1
 8004190:	d107      	bne.n	80041a2 <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8004192:	2400      	movs	r4, #0
 8004194:	e02a      	b.n	80041ec <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004196:	682c      	ldr	r4, [r5, #0]
 8004198:	2c00      	cmp	r4, #0
 800419a:	d0f7      	beq.n	800418c <pvPortMalloc+0x84>
 800419c:	462a      	mov	r2, r5
 800419e:	4625      	mov	r5, r4
 80041a0:	e7f1      	b.n	8004186 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80041a2:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80041a4:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80041a6:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80041a8:	1ac2      	subs	r2, r0, r3
 80041aa:	2a10      	cmp	r2, #16
 80041ac:	d90f      	bls.n	80041ce <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80041ae:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80041b0:	0741      	lsls	r1, r0, #29
 80041b2:	d008      	beq.n	80041c6 <pvPortMalloc+0xbe>
 80041b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041b8:	f383 8811 	msr	BASEPRI, r3
 80041bc:	f3bf 8f6f 	isb	sy
 80041c0:	f3bf 8f4f 	dsb	sy
 80041c4:	e7fe      	b.n	80041c4 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80041c6:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80041c8:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80041ca:	f7ff ff79 	bl	80040c0 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80041ce:	4913      	ldr	r1, [pc, #76]	; (800421c <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80041d0:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80041d2:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80041d4:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80041d6:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80041d8:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 80041da:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80041de:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80041e2:	bf38      	it	cc
 80041e4:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80041e6:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80041e8:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80041ea:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80041ec:	f000 fd76 	bl	8004cdc <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80041f0:	0763      	lsls	r3, r4, #29
 80041f2:	d008      	beq.n	8004206 <pvPortMalloc+0xfe>
 80041f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041f8:	f383 8811 	msr	BASEPRI, r3
 80041fc:	f3bf 8f6f 	isb	sy
 8004200:	f3bf 8f4f 	dsb	sy
 8004204:	e7fe      	b.n	8004204 <pvPortMalloc+0xfc>
}
 8004206:	4620      	mov	r0, r4
 8004208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800420c:	200001e4 	.word	0x200001e4
 8004210:	20003de8 	.word	0x20003de8
 8004214:	200001e8 	.word	0x200001e8
 8004218:	20003df4 	.word	0x20003df4
 800421c:	20003df0 	.word	0x20003df0
 8004220:	20003dec 	.word	0x20003dec

08004224 <vPortFree>:
{
 8004224:	b510      	push	{r4, lr}
	if( pv != NULL )
 8004226:	4604      	mov	r4, r0
 8004228:	b370      	cbz	r0, 8004288 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800422a:	4a18      	ldr	r2, [pc, #96]	; (800428c <vPortFree+0x68>)
 800422c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004230:	6812      	ldr	r2, [r2, #0]
 8004232:	4213      	tst	r3, r2
 8004234:	d108      	bne.n	8004248 <vPortFree+0x24>
 8004236:	f04f 0350 	mov.w	r3, #80	; 0x50
 800423a:	f383 8811 	msr	BASEPRI, r3
 800423e:	f3bf 8f6f 	isb	sy
 8004242:	f3bf 8f4f 	dsb	sy
 8004246:	e7fe      	b.n	8004246 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004248:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800424c:	b141      	cbz	r1, 8004260 <vPortFree+0x3c>
 800424e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004252:	f383 8811 	msr	BASEPRI, r3
 8004256:	f3bf 8f6f 	isb	sy
 800425a:	f3bf 8f4f 	dsb	sy
 800425e:	e7fe      	b.n	800425e <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004260:	ea23 0302 	bic.w	r3, r3, r2
 8004264:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8004268:	f000 fc90 	bl	8004b8c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800426c:	4a08      	ldr	r2, [pc, #32]	; (8004290 <vPortFree+0x6c>)
 800426e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004272:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004274:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004278:	440b      	add	r3, r1
 800427a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800427c:	f7ff ff20 	bl	80040c0 <prvInsertBlockIntoFreeList>
}
 8004280:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8004284:	f000 bd2a 	b.w	8004cdc <xTaskResumeAll>
 8004288:	bd10      	pop	{r4, pc}
 800428a:	bf00      	nop
 800428c:	20003de8 	.word	0x20003de8
 8004290:	20003dec 	.word	0x20003dec

08004294 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8004294:	b570      	push	{r4, r5, r6, lr}
 8004296:	4615      	mov	r5, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8004298:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800429a:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
 800429c:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800429e:	b942      	cbnz	r2, 80042b2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80042a0:	6805      	ldr	r5, [r0, #0]
 80042a2:	b99d      	cbnz	r5, 80042cc <prvCopyDataToQueue+0x38>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80042a4:	6840      	ldr	r0, [r0, #4]
 80042a6:	f000 ff2b 	bl	8005100 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80042aa:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 80042ac:	3601      	adds	r6, #1
 80042ae:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 80042b0:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 80042b2:	b96d      	cbnz	r5, 80042d0 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 80042b4:	6880      	ldr	r0, [r0, #8]
 80042b6:	f002 fdf7 	bl	8006ea8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80042ba:	68a3      	ldr	r3, [r4, #8]
 80042bc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80042be:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042c0:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80042c2:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042c4:	4293      	cmp	r3, r2
 80042c6:	d301      	bcc.n	80042cc <prvCopyDataToQueue+0x38>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80042c8:	6823      	ldr	r3, [r4, #0]
 80042ca:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 80042cc:	2000      	movs	r0, #0
 80042ce:	e7ed      	b.n	80042ac <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80042d0:	68c0      	ldr	r0, [r0, #12]
 80042d2:	f002 fde9 	bl	8006ea8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80042d6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80042d8:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042da:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80042dc:	425b      	negs	r3, r3
 80042de:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042e0:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80042e2:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80042e4:	bf3e      	ittt	cc
 80042e6:	6862      	ldrcc	r2, [r4, #4]
 80042e8:	189b      	addcc	r3, r3, r2
 80042ea:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 80042ec:	2d02      	cmp	r5, #2
 80042ee:	d1ed      	bne.n	80042cc <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80042f0:	b10e      	cbz	r6, 80042f6 <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 80042f2:	3e01      	subs	r6, #1
 80042f4:	e7ea      	b.n	80042cc <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 80042f6:	4630      	mov	r0, r6
 80042f8:	e7d8      	b.n	80042ac <prvCopyDataToQueue+0x18>

080042fa <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80042fa:	4603      	mov	r3, r0
 80042fc:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80042fe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8004300:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8004302:	b162      	cbz	r2, 800431e <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004304:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8004306:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004308:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800430a:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800430c:	60d9      	str	r1, [r3, #12]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800430e:	bf24      	itt	cs
 8004310:	6819      	ldrcs	r1, [r3, #0]
 8004312:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8004314:	68d9      	ldr	r1, [r3, #12]
	}
}
 8004316:	f85d 4b04 	ldr.w	r4, [sp], #4
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800431a:	f002 bdc5 	b.w	8006ea8 <memcpy>
}
 800431e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004322:	4770      	bx	lr

08004324 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8004324:	b570      	push	{r4, r5, r6, lr}
 8004326:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8004328:	f7ff fd94 	bl	8003e54 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800432c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004330:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8004334:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004336:	2d00      	cmp	r5, #0
 8004338:	dc14      	bgt.n	8004364 <prvUnlockQueue+0x40>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800433a:	23ff      	movs	r3, #255	; 0xff
 800433c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004340:	f7ff fdaa 	bl	8003e98 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004344:	f7ff fd86 	bl	8003e54 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004348:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800434c:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 8004350:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004352:	2d00      	cmp	r5, #0
 8004354:	dc12      	bgt.n	800437c <prvUnlockQueue+0x58>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004356:	23ff      	movs	r3, #255	; 0xff
 8004358:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 800435c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8004360:	f7ff bd9a 	b.w	8003e98 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004364:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004366:	2b00      	cmp	r3, #0
 8004368:	d0e7      	beq.n	800433a <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800436a:	4630      	mov	r0, r6
 800436c:	f000 fde0 	bl	8004f30 <xTaskRemoveFromEventList>
 8004370:	b108      	cbz	r0, 8004376 <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8004372:	f000 fe69 	bl	8005048 <vTaskMissedYield>
 8004376:	3d01      	subs	r5, #1
 8004378:	b26d      	sxtb	r5, r5
 800437a:	e7dc      	b.n	8004336 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800437c:	6923      	ldr	r3, [r4, #16]
 800437e:	2b00      	cmp	r3, #0
 8004380:	d0e9      	beq.n	8004356 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004382:	4630      	mov	r0, r6
 8004384:	f000 fdd4 	bl	8004f30 <xTaskRemoveFromEventList>
 8004388:	b108      	cbz	r0, 800438e <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 800438a:	f000 fe5d 	bl	8005048 <vTaskMissedYield>
 800438e:	3d01      	subs	r5, #1
 8004390:	b26d      	sxtb	r5, r5
 8004392:	e7de      	b.n	8004352 <prvUnlockQueue+0x2e>

08004394 <xQueueGenericReset>:
{
 8004394:	b538      	push	{r3, r4, r5, lr}
 8004396:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8004398:	4604      	mov	r4, r0
 800439a:	b940      	cbnz	r0, 80043ae <xQueueGenericReset+0x1a>
 800439c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043a0:	f383 8811 	msr	BASEPRI, r3
 80043a4:	f3bf 8f6f 	isb	sy
 80043a8:	f3bf 8f4f 	dsb	sy
 80043ac:	e7fe      	b.n	80043ac <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
 80043ae:	f7ff fd51 	bl	8003e54 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80043b2:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80043b4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80043b6:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80043b8:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80043ba:	4343      	muls	r3, r0
 80043bc:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80043be:	1a1b      	subs	r3, r3, r0
 80043c0:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80043c2:	6061      	str	r1, [r4, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80043c4:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80043c6:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 80043c8:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80043ca:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 80043cc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80043d0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 80043d4:	b995      	cbnz	r5, 80043fc <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80043d6:	6923      	ldr	r3, [r4, #16]
 80043d8:	b163      	cbz	r3, 80043f4 <xQueueGenericReset+0x60>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80043da:	f104 0010 	add.w	r0, r4, #16
 80043de:	f000 fda7 	bl	8004f30 <xTaskRemoveFromEventList>
 80043e2:	b138      	cbz	r0, 80043f4 <xQueueGenericReset+0x60>
					queueYIELD_IF_USING_PREEMPTION();
 80043e4:	4b0a      	ldr	r3, [pc, #40]	; (8004410 <xQueueGenericReset+0x7c>)
 80043e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80043ea:	601a      	str	r2, [r3, #0]
 80043ec:	f3bf 8f4f 	dsb	sy
 80043f0:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 80043f4:	f7ff fd50 	bl	8003e98 <vPortExitCritical>
}
 80043f8:	2001      	movs	r0, #1
 80043fa:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80043fc:	f104 0010 	add.w	r0, r4, #16
 8004400:	f7ff fc88 	bl	8003d14 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8004404:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004408:	f7ff fc84 	bl	8003d14 <vListInitialise>
 800440c:	e7f2      	b.n	80043f4 <xQueueGenericReset+0x60>
 800440e:	bf00      	nop
 8004410:	e000ed04 	.word	0xe000ed04

08004414 <xQueueGenericCreate>:
	{
 8004414:	b570      	push	{r4, r5, r6, lr}
 8004416:	460d      	mov	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8004418:	4606      	mov	r6, r0
 800441a:	b940      	cbnz	r0, 800442e <xQueueGenericCreate+0x1a>
 800441c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004420:	f383 8811 	msr	BASEPRI, r3
 8004424:	f3bf 8f6f 	isb	sy
 8004428:	f3bf 8f4f 	dsb	sy
 800442c:	e7fe      	b.n	800442c <xQueueGenericCreate+0x18>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800442e:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8004430:	3048      	adds	r0, #72	; 0x48
 8004432:	f7ff fe69 	bl	8004108 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8004436:	4604      	mov	r4, r0
 8004438:	b138      	cbz	r0, 800444a <xQueueGenericCreate+0x36>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800443a:	b945      	cbnz	r5, 800444e <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800443c:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800443e:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8004440:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004442:	2101      	movs	r1, #1
 8004444:	4620      	mov	r0, r4
 8004446:	f7ff ffa5 	bl	8004394 <xQueueGenericReset>
	}
 800444a:	4620      	mov	r0, r4
 800444c:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800444e:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8004452:	6003      	str	r3, [r0, #0]
 8004454:	e7f3      	b.n	800443e <xQueueGenericCreate+0x2a>
	...

08004458 <xQueueGenericSend>:
{
 8004458:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800445c:	4689      	mov	r9, r1
 800445e:	9201      	str	r2, [sp, #4]
 8004460:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8004462:	4604      	mov	r4, r0
 8004464:	b940      	cbnz	r0, 8004478 <xQueueGenericSend+0x20>
 8004466:	f04f 0350 	mov.w	r3, #80	; 0x50
 800446a:	f383 8811 	msr	BASEPRI, r3
 800446e:	f3bf 8f6f 	isb	sy
 8004472:	f3bf 8f4f 	dsb	sy
 8004476:	e7fe      	b.n	8004476 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004478:	2900      	cmp	r1, #0
 800447a:	f040 8088 	bne.w	800458e <xQueueGenericSend+0x136>
 800447e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004480:	2b00      	cmp	r3, #0
 8004482:	f000 8084 	beq.w	800458e <xQueueGenericSend+0x136>
 8004486:	f04f 0350 	mov.w	r3, #80	; 0x50
 800448a:	f383 8811 	msr	BASEPRI, r3
 800448e:	f3bf 8f6f 	isb	sy
 8004492:	f3bf 8f4f 	dsb	sy
 8004496:	e7fe      	b.n	8004496 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004498:	9e01      	ldr	r6, [sp, #4]
 800449a:	2e00      	cmp	r6, #0
 800449c:	f000 8082 	beq.w	80045a4 <xQueueGenericSend+0x14c>
 80044a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044a4:	f383 8811 	msr	BASEPRI, r3
 80044a8:	f3bf 8f6f 	isb	sy
 80044ac:	f3bf 8f4f 	dsb	sy
 80044b0:	e7fe      	b.n	80044b0 <xQueueGenericSend+0x58>
				if( xTicksToWait == ( TickType_t ) 0 )
 80044b2:	9d01      	ldr	r5, [sp, #4]
 80044b4:	b91d      	cbnz	r5, 80044be <xQueueGenericSend+0x66>
					taskEXIT_CRITICAL();
 80044b6:	f7ff fcef 	bl	8003e98 <vPortExitCritical>
			return errQUEUE_FULL;
 80044ba:	2000      	movs	r0, #0
 80044bc:	e058      	b.n	8004570 <xQueueGenericSend+0x118>
				else if( xEntryTimeSet == pdFALSE )
 80044be:	b916      	cbnz	r6, 80044c6 <xQueueGenericSend+0x6e>
					vTaskSetTimeOutState( &xTimeOut );
 80044c0:	a802      	add	r0, sp, #8
 80044c2:	f000 fd77 	bl	8004fb4 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 80044c6:	f7ff fce7 	bl	8003e98 <vPortExitCritical>
		vTaskSuspendAll();
 80044ca:	f000 fb5f 	bl	8004b8c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80044ce:	f7ff fcc1 	bl	8003e54 <vPortEnterCritical>
 80044d2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80044d6:	2bff      	cmp	r3, #255	; 0xff
 80044d8:	bf08      	it	eq
 80044da:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 80044de:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80044e2:	2bff      	cmp	r3, #255	; 0xff
 80044e4:	bf08      	it	eq
 80044e6:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 80044ea:	f7ff fcd5 	bl	8003e98 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80044ee:	a901      	add	r1, sp, #4
 80044f0:	a802      	add	r0, sp, #8
 80044f2:	f000 fd6f 	bl	8004fd4 <xTaskCheckForTimeOut>
 80044f6:	2800      	cmp	r0, #0
 80044f8:	d143      	bne.n	8004582 <xQueueGenericSend+0x12a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80044fa:	f7ff fcab 	bl	8003e54 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80044fe:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8004500:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8004502:	f7ff fcc9 	bl	8003e98 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8004506:	42ae      	cmp	r6, r5
 8004508:	d135      	bne.n	8004576 <xQueueGenericSend+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800450a:	9901      	ldr	r1, [sp, #4]
 800450c:	f104 0010 	add.w	r0, r4, #16
 8004510:	f000 fcf4 	bl	8004efc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004514:	4620      	mov	r0, r4
 8004516:	f7ff ff05 	bl	8004324 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800451a:	f000 fbdf 	bl	8004cdc <xTaskResumeAll>
 800451e:	b938      	cbnz	r0, 8004530 <xQueueGenericSend+0xd8>
					portYIELD_WITHIN_API();
 8004520:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004524:	f8ca 3000 	str.w	r3, [sl]
 8004528:	f3bf 8f4f 	dsb	sy
 800452c:	f3bf 8f6f 	isb	sy
 8004530:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8004532:	f7ff fc8f 	bl	8003e54 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8004536:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004538:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800453a:	429a      	cmp	r2, r3
 800453c:	d301      	bcc.n	8004542 <xQueueGenericSend+0xea>
 800453e:	2f02      	cmp	r7, #2
 8004540:	d1b7      	bne.n	80044b2 <xQueueGenericSend+0x5a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004542:	463a      	mov	r2, r7
 8004544:	4649      	mov	r1, r9
 8004546:	4620      	mov	r0, r4
 8004548:	f7ff fea4 	bl	8004294 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800454c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800454e:	b11b      	cbz	r3, 8004558 <xQueueGenericSend+0x100>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004550:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004554:	f000 fcec 	bl	8004f30 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 8004558:	b138      	cbz	r0, 800456a <xQueueGenericSend+0x112>
						queueYIELD_IF_USING_PREEMPTION();
 800455a:	4b19      	ldr	r3, [pc, #100]	; (80045c0 <xQueueGenericSend+0x168>)
 800455c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004560:	601a      	str	r2, [r3, #0]
 8004562:	f3bf 8f4f 	dsb	sy
 8004566:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 800456a:	f7ff fc95 	bl	8003e98 <vPortExitCritical>
				return pdPASS;
 800456e:	2001      	movs	r0, #1
}
 8004570:	b004      	add	sp, #16
 8004572:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 8004576:	4620      	mov	r0, r4
 8004578:	f7ff fed4 	bl	8004324 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800457c:	f000 fbae 	bl	8004cdc <xTaskResumeAll>
 8004580:	e7d6      	b.n	8004530 <xQueueGenericSend+0xd8>
			prvUnlockQueue( pxQueue );
 8004582:	4620      	mov	r0, r4
 8004584:	f7ff fece 	bl	8004324 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004588:	f000 fba8 	bl	8004cdc <xTaskResumeAll>
 800458c:	e795      	b.n	80044ba <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800458e:	2f02      	cmp	r7, #2
 8004590:	d102      	bne.n	8004598 <xQueueGenericSend+0x140>
 8004592:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004594:	2b01      	cmp	r3, #1
 8004596:	d10a      	bne.n	80045ae <xQueueGenericSend+0x156>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004598:	f000 fd5c 	bl	8005054 <xTaskGetSchedulerState>
 800459c:	2800      	cmp	r0, #0
 800459e:	f43f af7b 	beq.w	8004498 <xQueueGenericSend+0x40>
 80045a2:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 80045a4:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 80045a8:	f8df a014 	ldr.w	sl, [pc, #20]	; 80045c0 <xQueueGenericSend+0x168>
 80045ac:	e7c1      	b.n	8004532 <xQueueGenericSend+0xda>
 80045ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045b2:	f383 8811 	msr	BASEPRI, r3
 80045b6:	f3bf 8f6f 	isb	sy
 80045ba:	f3bf 8f4f 	dsb	sy
 80045be:	e7fe      	b.n	80045be <xQueueGenericSend+0x166>
 80045c0:	e000ed04 	.word	0xe000ed04

080045c4 <xQueueGenericSendFromISR>:
{
 80045c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80045c8:	4688      	mov	r8, r1
 80045ca:	4691      	mov	r9, r2
 80045cc:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 80045ce:	4604      	mov	r4, r0
 80045d0:	b940      	cbnz	r0, 80045e4 <xQueueGenericSendFromISR+0x20>
 80045d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045d6:	f383 8811 	msr	BASEPRI, r3
 80045da:	f3bf 8f6f 	isb	sy
 80045de:	f3bf 8f4f 	dsb	sy
 80045e2:	e7fe      	b.n	80045e2 <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80045e4:	bb09      	cbnz	r1, 800462a <xQueueGenericSendFromISR+0x66>
 80045e6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80045e8:	b1fb      	cbz	r3, 800462a <xQueueGenericSendFromISR+0x66>
 80045ea:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045ee:	f383 8811 	msr	BASEPRI, r3
 80045f2:	f3bf 8f6f 	isb	sy
 80045f6:	f3bf 8f4f 	dsb	sy
 80045fa:	e7fe      	b.n	80045fa <xQueueGenericSendFromISR+0x36>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80045fc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004600:	f000 fc96 	bl	8004f30 <xTaskRemoveFromEventList>
 8004604:	2800      	cmp	r0, #0
 8004606:	d034      	beq.n	8004672 <xQueueGenericSendFromISR+0xae>
							if( pxHigherPriorityTaskWoken != NULL )
 8004608:	f1b9 0f00 	cmp.w	r9, #0
 800460c:	d031      	beq.n	8004672 <xQueueGenericSendFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800460e:	2001      	movs	r0, #1
 8004610:	f8c9 0000 	str.w	r0, [r9]
	__asm volatile
 8004614:	f386 8811 	msr	BASEPRI, r6
}
 8004618:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800461c:	3501      	adds	r5, #1
 800461e:	b26d      	sxtb	r5, r5
 8004620:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8004624:	e025      	b.n	8004672 <xQueueGenericSendFromISR+0xae>
			xReturn = errQUEUE_FULL;
 8004626:	2000      	movs	r0, #0
 8004628:	e7f4      	b.n	8004614 <xQueueGenericSendFromISR+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800462a:	2f02      	cmp	r7, #2
 800462c:	d102      	bne.n	8004634 <xQueueGenericSendFromISR+0x70>
 800462e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004630:	2b01      	cmp	r3, #1
 8004632:	d120      	bne.n	8004676 <xQueueGenericSendFromISR+0xb2>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004634:	f7ff fd16 	bl	8004064 <vPortValidateInterruptPriority>
	__asm volatile
 8004638:	f3ef 8611 	mrs	r6, BASEPRI
 800463c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004640:	f383 8811 	msr	BASEPRI, r3
 8004644:	f3bf 8f6f 	isb	sy
 8004648:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800464c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800464e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004650:	429a      	cmp	r2, r3
 8004652:	d301      	bcc.n	8004658 <xQueueGenericSendFromISR+0x94>
 8004654:	2f02      	cmp	r7, #2
 8004656:	d1e6      	bne.n	8004626 <xQueueGenericSendFromISR+0x62>
			const int8_t cTxLock = pxQueue->cTxLock;
 8004658:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800465c:	463a      	mov	r2, r7
			const int8_t cTxLock = pxQueue->cTxLock;
 800465e:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004660:	4641      	mov	r1, r8
 8004662:	4620      	mov	r0, r4
 8004664:	f7ff fe16 	bl	8004294 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8004668:	1c6b      	adds	r3, r5, #1
 800466a:	d1d7      	bne.n	800461c <xQueueGenericSendFromISR+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800466c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800466e:	2b00      	cmp	r3, #0
 8004670:	d1c4      	bne.n	80045fc <xQueueGenericSendFromISR+0x38>
			xReturn = pdPASS;
 8004672:	2001      	movs	r0, #1
 8004674:	e7ce      	b.n	8004614 <xQueueGenericSendFromISR+0x50>
	__asm volatile
 8004676:	f04f 0350 	mov.w	r3, #80	; 0x50
 800467a:	f383 8811 	msr	BASEPRI, r3
 800467e:	f3bf 8f6f 	isb	sy
 8004682:	f3bf 8f4f 	dsb	sy
 8004686:	e7fe      	b.n	8004686 <xQueueGenericSendFromISR+0xc2>

08004688 <xQueueGenericReceive>:
{
 8004688:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800468c:	4688      	mov	r8, r1
 800468e:	9201      	str	r2, [sp, #4]
 8004690:	4699      	mov	r9, r3
	configASSERT( pxQueue );
 8004692:	4604      	mov	r4, r0
 8004694:	b940      	cbnz	r0, 80046a8 <xQueueGenericReceive+0x20>
 8004696:	f04f 0350 	mov.w	r3, #80	; 0x50
 800469a:	f383 8811 	msr	BASEPRI, r3
 800469e:	f3bf 8f6f 	isb	sy
 80046a2:	f3bf 8f4f 	dsb	sy
 80046a6:	e7fe      	b.n	80046a6 <xQueueGenericReceive+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80046a8:	2900      	cmp	r1, #0
 80046aa:	f040 80a5 	bne.w	80047f8 <xQueueGenericReceive+0x170>
 80046ae:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80046b0:	2b00      	cmp	r3, #0
 80046b2:	f000 80a1 	beq.w	80047f8 <xQueueGenericReceive+0x170>
 80046b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046ba:	f383 8811 	msr	BASEPRI, r3
 80046be:	f3bf 8f6f 	isb	sy
 80046c2:	f3bf 8f4f 	dsb	sy
 80046c6:	e7fe      	b.n	80046c6 <xQueueGenericReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80046c8:	9e01      	ldr	r6, [sp, #4]
 80046ca:	2e00      	cmp	r6, #0
 80046cc:	f000 809a 	beq.w	8004804 <xQueueGenericReceive+0x17c>
 80046d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046d4:	f383 8811 	msr	BASEPRI, r3
 80046d8:	f3bf 8f6f 	isb	sy
 80046dc:	f3bf 8f4f 	dsb	sy
 80046e0:	e7fe      	b.n	80046e0 <xQueueGenericReceive+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80046e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 80046e4:	60e6      	str	r6, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80046e6:	2b00      	cmp	r3, #0
 80046e8:	d06d      	beq.n	80047c6 <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80046ea:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80046ee:	e05f      	b.n	80047b0 <xQueueGenericReceive+0x128>
				if( xTicksToWait == ( TickType_t ) 0 )
 80046f0:	9d01      	ldr	r5, [sp, #4]
 80046f2:	b91d      	cbnz	r5, 80046fc <xQueueGenericReceive+0x74>
					taskEXIT_CRITICAL();
 80046f4:	f7ff fbd0 	bl	8003e98 <vPortExitCritical>
				return errQUEUE_EMPTY;
 80046f8:	4628      	mov	r0, r5
 80046fa:	e067      	b.n	80047cc <xQueueGenericReceive+0x144>
				else if( xEntryTimeSet == pdFALSE )
 80046fc:	b916      	cbnz	r6, 8004704 <xQueueGenericReceive+0x7c>
					vTaskSetTimeOutState( &xTimeOut );
 80046fe:	a802      	add	r0, sp, #8
 8004700:	f000 fc58 	bl	8004fb4 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8004704:	f7ff fbc8 	bl	8003e98 <vPortExitCritical>
		vTaskSuspendAll();
 8004708:	f000 fa40 	bl	8004b8c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800470c:	f7ff fba2 	bl	8003e54 <vPortEnterCritical>
 8004710:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004714:	2bff      	cmp	r3, #255	; 0xff
 8004716:	bf08      	it	eq
 8004718:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 800471c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004720:	2bff      	cmp	r3, #255	; 0xff
 8004722:	bf08      	it	eq
 8004724:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 8004728:	f7ff fbb6 	bl	8003e98 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800472c:	a901      	add	r1, sp, #4
 800472e:	a802      	add	r0, sp, #8
 8004730:	f000 fc50 	bl	8004fd4 <xTaskCheckForTimeOut>
 8004734:	2800      	cmp	r0, #0
 8004736:	d152      	bne.n	80047de <xQueueGenericReceive+0x156>
	taskENTER_CRITICAL();
 8004738:	f7ff fb8c 	bl	8003e54 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800473c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 800473e:	f7ff fbab 	bl	8003e98 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004742:	2d00      	cmp	r5, #0
 8004744:	d145      	bne.n	80047d2 <xQueueGenericReceive+0x14a>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004746:	6823      	ldr	r3, [r4, #0]
 8004748:	b933      	cbnz	r3, 8004758 <xQueueGenericReceive+0xd0>
						taskENTER_CRITICAL();
 800474a:	f7ff fb83 	bl	8003e54 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800474e:	6860      	ldr	r0, [r4, #4]
 8004750:	f000 fc90 	bl	8005074 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8004754:	f7ff fba0 	bl	8003e98 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004758:	9901      	ldr	r1, [sp, #4]
 800475a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800475e:	f000 fbcd 	bl	8004efc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004762:	4620      	mov	r0, r4
 8004764:	f7ff fdde 	bl	8004324 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004768:	f000 fab8 	bl	8004cdc <xTaskResumeAll>
 800476c:	b938      	cbnz	r0, 800477e <xQueueGenericReceive+0xf6>
					portYIELD_WITHIN_API();
 800476e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004772:	f8ca 3000 	str.w	r3, [sl]
 8004776:	f3bf 8f4f 	dsb	sy
 800477a:	f3bf 8f6f 	isb	sy
 800477e:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8004780:	f7ff fb68 	bl	8003e54 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004784:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004786:	2d00      	cmp	r5, #0
 8004788:	d0b2      	beq.n	80046f0 <xQueueGenericReceive+0x68>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800478a:	4641      	mov	r1, r8
 800478c:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800478e:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004790:	f7ff fdb3 	bl	80042fa <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8004794:	f1b9 0f00 	cmp.w	r9, #0
 8004798:	d1a3      	bne.n	80046e2 <xQueueGenericReceive+0x5a>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800479a:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800479c:	3d01      	subs	r5, #1
 800479e:	63a5      	str	r5, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80047a0:	b913      	cbnz	r3, 80047a8 <xQueueGenericReceive+0x120>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 80047a2:	f000 fcfd 	bl	80051a0 <pvTaskIncrementMutexHeldCount>
 80047a6:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80047a8:	6923      	ldr	r3, [r4, #16]
 80047aa:	b163      	cbz	r3, 80047c6 <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80047ac:	f104 0010 	add.w	r0, r4, #16
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80047b0:	f000 fbbe 	bl	8004f30 <xTaskRemoveFromEventList>
 80047b4:	b138      	cbz	r0, 80047c6 <xQueueGenericReceive+0x13e>
							queueYIELD_IF_USING_PREEMPTION();
 80047b6:	4b15      	ldr	r3, [pc, #84]	; (800480c <xQueueGenericReceive+0x184>)
 80047b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047bc:	601a      	str	r2, [r3, #0]
 80047be:	f3bf 8f4f 	dsb	sy
 80047c2:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80047c6:	f7ff fb67 	bl	8003e98 <vPortExitCritical>
				return pdPASS;
 80047ca:	2001      	movs	r0, #1
}
 80047cc:	b004      	add	sp, #16
 80047ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 80047d2:	4620      	mov	r0, r4
 80047d4:	f7ff fda6 	bl	8004324 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80047d8:	f000 fa80 	bl	8004cdc <xTaskResumeAll>
 80047dc:	e7cf      	b.n	800477e <xQueueGenericReceive+0xf6>
			prvUnlockQueue( pxQueue );
 80047de:	4620      	mov	r0, r4
 80047e0:	f7ff fda0 	bl	8004324 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80047e4:	f000 fa7a 	bl	8004cdc <xTaskResumeAll>
	taskENTER_CRITICAL();
 80047e8:	f7ff fb34 	bl	8003e54 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80047ec:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 80047ee:	f7ff fb53 	bl	8003e98 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80047f2:	2d00      	cmp	r5, #0
 80047f4:	d1c3      	bne.n	800477e <xQueueGenericReceive+0xf6>
 80047f6:	e77f      	b.n	80046f8 <xQueueGenericReceive+0x70>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80047f8:	f000 fc2c 	bl	8005054 <xTaskGetSchedulerState>
 80047fc:	2800      	cmp	r0, #0
 80047fe:	f43f af63 	beq.w	80046c8 <xQueueGenericReceive+0x40>
 8004802:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8004804:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 8004806:	f8df a004 	ldr.w	sl, [pc, #4]	; 800480c <xQueueGenericReceive+0x184>
 800480a:	e7b9      	b.n	8004780 <xQueueGenericReceive+0xf8>
 800480c:	e000ed04 	.word	0xe000ed04

08004810 <xQueueReceiveFromISR>:
{
 8004810:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004814:	4689      	mov	r9, r1
 8004816:	4690      	mov	r8, r2
	configASSERT( pxQueue );
 8004818:	4605      	mov	r5, r0
 800481a:	b940      	cbnz	r0, 800482e <xQueueReceiveFromISR+0x1e>
 800481c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004820:	f383 8811 	msr	BASEPRI, r3
 8004824:	f3bf 8f6f 	isb	sy
 8004828:	f3bf 8f4f 	dsb	sy
 800482c:	e7fe      	b.n	800482c <xQueueReceiveFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800482e:	bb71      	cbnz	r1, 800488e <xQueueReceiveFromISR+0x7e>
 8004830:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004832:	b363      	cbz	r3, 800488e <xQueueReceiveFromISR+0x7e>
 8004834:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004838:	f383 8811 	msr	BASEPRI, r3
 800483c:	f3bf 8f6f 	isb	sy
 8004840:	f3bf 8f4f 	dsb	sy
 8004844:	e7fe      	b.n	8004844 <xQueueReceiveFromISR+0x34>
			const int8_t cRxLock = pxQueue->cRxLock;
 8004846:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800484a:	4649      	mov	r1, r9
			const int8_t cRxLock = pxQueue->cRxLock;
 800484c:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800484e:	4628      	mov	r0, r5
 8004850:	f7ff fd53 	bl	80042fa <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8004854:	3c01      	subs	r4, #1
			if( cRxLock == queueUNLOCKED )
 8004856:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8004858:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800485a:	d113      	bne.n	8004884 <xQueueReceiveFromISR+0x74>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800485c:	692b      	ldr	r3, [r5, #16]
 800485e:	b90b      	cbnz	r3, 8004864 <xQueueReceiveFromISR+0x54>
			xReturn = pdPASS;
 8004860:	2001      	movs	r0, #1
 8004862:	e00b      	b.n	800487c <xQueueReceiveFromISR+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004864:	f105 0010 	add.w	r0, r5, #16
 8004868:	f000 fb62 	bl	8004f30 <xTaskRemoveFromEventList>
 800486c:	2800      	cmp	r0, #0
 800486e:	d0f7      	beq.n	8004860 <xQueueReceiveFromISR+0x50>
						if( pxHigherPriorityTaskWoken != NULL )
 8004870:	f1b8 0f00 	cmp.w	r8, #0
 8004874:	d0f4      	beq.n	8004860 <xQueueReceiveFromISR+0x50>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8004876:	2001      	movs	r0, #1
 8004878:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
 800487c:	f387 8811 	msr	BASEPRI, r7
}
 8004880:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8004884:	3601      	adds	r6, #1
 8004886:	b276      	sxtb	r6, r6
 8004888:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
 800488c:	e7e8      	b.n	8004860 <xQueueReceiveFromISR+0x50>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800488e:	f7ff fbe9 	bl	8004064 <vPortValidateInterruptPriority>
	__asm volatile
 8004892:	f3ef 8711 	mrs	r7, BASEPRI
 8004896:	f04f 0350 	mov.w	r3, #80	; 0x50
 800489a:	f383 8811 	msr	BASEPRI, r3
 800489e:	f3bf 8f6f 	isb	sy
 80048a2:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80048a6:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80048a8:	2c00      	cmp	r4, #0
 80048aa:	d1cc      	bne.n	8004846 <xQueueReceiveFromISR+0x36>
			xReturn = pdFAIL;
 80048ac:	4620      	mov	r0, r4
 80048ae:	e7e5      	b.n	800487c <xQueueReceiveFromISR+0x6c>

080048b0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80048b0:	4a06      	ldr	r2, [pc, #24]	; (80048cc <prvResetNextTaskUnblockTime+0x1c>)
 80048b2:	6813      	ldr	r3, [r2, #0]
 80048b4:	6819      	ldr	r1, [r3, #0]
 80048b6:	4b06      	ldr	r3, [pc, #24]	; (80048d0 <prvResetNextTaskUnblockTime+0x20>)
 80048b8:	b919      	cbnz	r1, 80048c2 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80048ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80048be:	601a      	str	r2, [r3, #0]
 80048c0:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80048c2:	6812      	ldr	r2, [r2, #0]
 80048c4:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80048c6:	68d2      	ldr	r2, [r2, #12]
 80048c8:	6852      	ldr	r2, [r2, #4]
 80048ca:	e7f8      	b.n	80048be <prvResetNextTaskUnblockTime+0xe>
 80048cc:	20003e00 	.word	0x20003e00
 80048d0:	20003ed8 	.word	0x20003ed8

080048d4 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80048d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80048d6:	4b1b      	ldr	r3, [pc, #108]	; (8004944 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048d8:	4e1b      	ldr	r6, [pc, #108]	; (8004948 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 80048da:	681d      	ldr	r5, [r3, #0]
{
 80048dc:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048de:	6830      	ldr	r0, [r6, #0]
 80048e0:	3004      	adds	r0, #4
{
 80048e2:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048e4:	f7ff fa47 	bl	8003d76 <uxListRemove>
 80048e8:	4633      	mov	r3, r6
 80048ea:	b940      	cbnz	r0, 80048fe <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80048ec:	6831      	ldr	r1, [r6, #0]
 80048ee:	4e17      	ldr	r6, [pc, #92]	; (800494c <prvAddCurrentTaskToDelayedList+0x78>)
 80048f0:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80048f2:	6832      	ldr	r2, [r6, #0]
 80048f4:	2001      	movs	r0, #1
 80048f6:	4088      	lsls	r0, r1
 80048f8:	ea22 0200 	bic.w	r2, r2, r0
 80048fc:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80048fe:	1c62      	adds	r2, r4, #1
 8004900:	d107      	bne.n	8004912 <prvAddCurrentTaskToDelayedList+0x3e>
 8004902:	b137      	cbz	r7, 8004912 <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004904:	6819      	ldr	r1, [r3, #0]
 8004906:	4812      	ldr	r0, [pc, #72]	; (8004950 <prvAddCurrentTaskToDelayedList+0x7c>)
 8004908:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800490a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800490e:	f7ff ba0f 	b.w	8003d30 <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8004912:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004914:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 8004916:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004918:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 800491a:	d907      	bls.n	800492c <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800491c:	4a0d      	ldr	r2, [pc, #52]	; (8004954 <prvAddCurrentTaskToDelayedList+0x80>)
 800491e:	6810      	ldr	r0, [r2, #0]
 8004920:	6819      	ldr	r1, [r3, #0]
}
 8004922:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004926:	3104      	adds	r1, #4
 8004928:	f7ff ba0e 	b.w	8003d48 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800492c:	4a0a      	ldr	r2, [pc, #40]	; (8004958 <prvAddCurrentTaskToDelayedList+0x84>)
 800492e:	6810      	ldr	r0, [r2, #0]
 8004930:	6819      	ldr	r1, [r3, #0]
 8004932:	3104      	adds	r1, #4
 8004934:	f7ff fa08 	bl	8003d48 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8004938:	4b08      	ldr	r3, [pc, #32]	; (800495c <prvAddCurrentTaskToDelayedList+0x88>)
 800493a:	681a      	ldr	r2, [r3, #0]
 800493c:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 800493e:	bf38      	it	cc
 8004940:	601c      	strcc	r4, [r3, #0]
 8004942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004944:	20003f20 	.word	0x20003f20
 8004948:	20003dfc 	.word	0x20003dfc
 800494c:	20003ea8 	.word	0x20003ea8
 8004950:	20003ef8 	.word	0x20003ef8
 8004954:	20003e04 	.word	0x20003e04
 8004958:	20003e00 	.word	0x20003e00
 800495c:	20003ed8 	.word	0x20003ed8

08004960 <prvTaskIsTaskSuspended.part.0>:
	__asm volatile
 8004960:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004964:	f383 8811 	msr	BASEPRI, r3
 8004968:	f3bf 8f6f 	isb	sy
 800496c:	f3bf 8f4f 	dsb	sy
 8004970:	e7fe      	b.n	8004970 <prvTaskIsTaskSuspended.part.0+0x10>
	...

08004974 <xTaskCreate>:
	{
 8004974:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004978:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 800497c:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800497e:	4650      	mov	r0, sl
	{
 8004980:	460f      	mov	r7, r1
 8004982:	4699      	mov	r9, r3
 8004984:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004986:	f7ff fbbf 	bl	8004108 <pvPortMalloc>
			if( pxStack != NULL )
 800498a:	4605      	mov	r5, r0
 800498c:	2800      	cmp	r0, #0
 800498e:	f000 8096 	beq.w	8004abe <xTaskCreate+0x14a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8004992:	2054      	movs	r0, #84	; 0x54
 8004994:	f7ff fbb8 	bl	8004108 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8004998:	4604      	mov	r4, r0
 800499a:	2800      	cmp	r0, #0
 800499c:	f000 808c 	beq.w	8004ab8 <xTaskCreate+0x144>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80049a0:	f1aa 0a04 	sub.w	sl, sl, #4
					pxNewTCB->pxStack = pxStack;
 80049a4:	6305      	str	r5, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80049a6:	4455      	add	r5, sl
 80049a8:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80049aa:	f025 0a07 	bic.w	sl, r5, #7
 80049ae:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80049b2:	370f      	adds	r7, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049b4:	7859      	ldrb	r1, [r3, #1]
 80049b6:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 80049ba:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80049be:	b109      	cbz	r1, 80049c4 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80049c0:	42bb      	cmp	r3, r7
 80049c2:	d1f7      	bne.n	80049b4 <xTaskCreate+0x40>
 80049c4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80049c6:	2d06      	cmp	r5, #6
 80049c8:	bf28      	it	cs
 80049ca:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80049cc:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049d0:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 80049d2:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80049d4:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049d6:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80049d8:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 80049dc:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049e0:	f7ff f9a3 	bl	8003d2a <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049e4:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80049e8:	f104 0018 	add.w	r0, r4, #24
 80049ec:	f7ff f99d 	bl	8003d2a <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 80049f0:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80049f4:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049f6:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80049f8:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80049fa:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80049fe:	464a      	mov	r2, r9
 8004a00:	4641      	mov	r1, r8
 8004a02:	4650      	mov	r0, sl
 8004a04:	f7ff f9fa 	bl	8003dfc <pxPortInitialiseStack>
 8004a08:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8004a0a:	b106      	cbz	r6, 8004a0e <xTaskCreate+0x9a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004a0c:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 8004a0e:	f7ff fa21 	bl	8003e54 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004a12:	4b32      	ldr	r3, [pc, #200]	; (8004adc <xTaskCreate+0x168>)
		if( pxCurrentTCB == NULL )
 8004a14:	4e32      	ldr	r6, [pc, #200]	; (8004ae0 <xTaskCreate+0x16c>)
		uxCurrentNumberOfTasks++;
 8004a16:	681a      	ldr	r2, [r3, #0]
 8004a18:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8004b0c <xTaskCreate+0x198>
 8004a1c:	3201      	adds	r2, #1
 8004a1e:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8004a20:	6835      	ldr	r5, [r6, #0]
 8004a22:	2d00      	cmp	r5, #0
 8004a24:	d14e      	bne.n	8004ac4 <xTaskCreate+0x150>
			pxCurrentTCB = pxNewTCB;
 8004a26:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004a28:	681b      	ldr	r3, [r3, #0]
 8004a2a:	2b01      	cmp	r3, #1
 8004a2c:	d11d      	bne.n	8004a6a <xTaskCreate+0xf6>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8004a2e:	eb08 0005 	add.w	r0, r8, r5
 8004a32:	3514      	adds	r5, #20
 8004a34:	f7ff f96e 	bl	8003d14 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004a38:	2d8c      	cmp	r5, #140	; 0x8c
 8004a3a:	d1f8      	bne.n	8004a2e <xTaskCreate+0xba>
	vListInitialise( &xDelayedTaskList1 );
 8004a3c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8004b10 <xTaskCreate+0x19c>
	vListInitialise( &xDelayedTaskList2 );
 8004a40:	4d28      	ldr	r5, [pc, #160]	; (8004ae4 <xTaskCreate+0x170>)
	vListInitialise( &xDelayedTaskList1 );
 8004a42:	4648      	mov	r0, r9
 8004a44:	f7ff f966 	bl	8003d14 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8004a48:	4628      	mov	r0, r5
 8004a4a:	f7ff f963 	bl	8003d14 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004a4e:	4826      	ldr	r0, [pc, #152]	; (8004ae8 <xTaskCreate+0x174>)
 8004a50:	f7ff f960 	bl	8003d14 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8004a54:	4825      	ldr	r0, [pc, #148]	; (8004aec <xTaskCreate+0x178>)
 8004a56:	f7ff f95d 	bl	8003d14 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8004a5a:	4825      	ldr	r0, [pc, #148]	; (8004af0 <xTaskCreate+0x17c>)
 8004a5c:	f7ff f95a 	bl	8003d14 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8004a60:	4b24      	ldr	r3, [pc, #144]	; (8004af4 <xTaskCreate+0x180>)
 8004a62:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8004a66:	4b24      	ldr	r3, [pc, #144]	; (8004af8 <xTaskCreate+0x184>)
 8004a68:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 8004a6a:	4a24      	ldr	r2, [pc, #144]	; (8004afc <xTaskCreate+0x188>)
		prvAddTaskToReadyList( pxNewTCB );
 8004a6c:	4924      	ldr	r1, [pc, #144]	; (8004b00 <xTaskCreate+0x18c>)
		uxTaskNumber++;
 8004a6e:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8004a70:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8004a72:	3301      	adds	r3, #1
 8004a74:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8004a76:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004a78:	2501      	movs	r5, #1
 8004a7a:	fa05 f302 	lsl.w	r3, r5, r2
 8004a7e:	4303      	orrs	r3, r0
 8004a80:	2014      	movs	r0, #20
 8004a82:	600b      	str	r3, [r1, #0]
 8004a84:	fb00 8002 	mla	r0, r0, r2, r8
 8004a88:	4639      	mov	r1, r7
 8004a8a:	f7ff f951 	bl	8003d30 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8004a8e:	f7ff fa03 	bl	8003e98 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8004a92:	4b1c      	ldr	r3, [pc, #112]	; (8004b04 <xTaskCreate+0x190>)
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	b163      	cbz	r3, 8004ab2 <xTaskCreate+0x13e>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8004a98:	6833      	ldr	r3, [r6, #0]
 8004a9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004a9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004a9e:	429a      	cmp	r2, r3
 8004aa0:	d207      	bcs.n	8004ab2 <xTaskCreate+0x13e>
			taskYIELD_IF_USING_PREEMPTION();
 8004aa2:	4b19      	ldr	r3, [pc, #100]	; (8004b08 <xTaskCreate+0x194>)
 8004aa4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004aa8:	601a      	str	r2, [r3, #0]
 8004aaa:	f3bf 8f4f 	dsb	sy
 8004aae:	f3bf 8f6f 	isb	sy
	}
 8004ab2:	4628      	mov	r0, r5
 8004ab4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					vPortFree( pxStack );
 8004ab8:	4628      	mov	r0, r5
 8004aba:	f7ff fbb3 	bl	8004224 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004abe:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8004ac2:	e7f6      	b.n	8004ab2 <xTaskCreate+0x13e>
			if( xSchedulerRunning == pdFALSE )
 8004ac4:	4b0f      	ldr	r3, [pc, #60]	; (8004b04 <xTaskCreate+0x190>)
 8004ac6:	681b      	ldr	r3, [r3, #0]
 8004ac8:	2b00      	cmp	r3, #0
 8004aca:	d1ce      	bne.n	8004a6a <xTaskCreate+0xf6>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8004acc:	6833      	ldr	r3, [r6, #0]
 8004ace:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004ad0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004ad2:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8004ad4:	bf98      	it	ls
 8004ad6:	6034      	strls	r4, [r6, #0]
 8004ad8:	e7c7      	b.n	8004a6a <xTaskCreate+0xf6>
 8004ada:	bf00      	nop
 8004adc:	20003e94 	.word	0x20003e94
 8004ae0:	20003dfc 	.word	0x20003dfc
 8004ae4:	20003ec0 	.word	0x20003ec0
 8004ae8:	20003ee0 	.word	0x20003ee0
 8004aec:	20003f0c 	.word	0x20003f0c
 8004af0:	20003ef8 	.word	0x20003ef8
 8004af4:	20003e00 	.word	0x20003e00
 8004af8:	20003e04 	.word	0x20003e04
 8004afc:	20003ea4 	.word	0x20003ea4
 8004b00:	20003ea8 	.word	0x20003ea8
 8004b04:	20003ef4 	.word	0x20003ef4
 8004b08:	e000ed04 	.word	0xe000ed04
 8004b0c:	20003e08 	.word	0x20003e08
 8004b10:	20003eac 	.word	0x20003eac

08004b14 <vTaskStartScheduler>:
{
 8004b14:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8004b16:	4b17      	ldr	r3, [pc, #92]	; (8004b74 <vTaskStartScheduler+0x60>)
 8004b18:	9301      	str	r3, [sp, #4]
 8004b1a:	2400      	movs	r4, #0
 8004b1c:	9400      	str	r4, [sp, #0]
 8004b1e:	4623      	mov	r3, r4
 8004b20:	2280      	movs	r2, #128	; 0x80
 8004b22:	4915      	ldr	r1, [pc, #84]	; (8004b78 <vTaskStartScheduler+0x64>)
 8004b24:	4815      	ldr	r0, [pc, #84]	; (8004b7c <vTaskStartScheduler+0x68>)
 8004b26:	f7ff ff25 	bl	8004974 <xTaskCreate>
	if( xReturn == pdPASS )
 8004b2a:	2801      	cmp	r0, #1
 8004b2c:	d114      	bne.n	8004b58 <vTaskStartScheduler+0x44>
 8004b2e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b32:	f383 8811 	msr	BASEPRI, r3
 8004b36:	f3bf 8f6f 	isb	sy
 8004b3a:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8004b3e:	4b10      	ldr	r3, [pc, #64]	; (8004b80 <vTaskStartScheduler+0x6c>)
 8004b40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004b44:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8004b46:	4b0f      	ldr	r3, [pc, #60]	; (8004b84 <vTaskStartScheduler+0x70>)
 8004b48:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8004b4a:	4b0f      	ldr	r3, [pc, #60]	; (8004b88 <vTaskStartScheduler+0x74>)
 8004b4c:	601c      	str	r4, [r3, #0]
}
 8004b4e:	b002      	add	sp, #8
 8004b50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 8004b54:	f7ff ba10 	b.w	8003f78 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8004b58:	3001      	adds	r0, #1
 8004b5a:	d108      	bne.n	8004b6e <vTaskStartScheduler+0x5a>
 8004b5c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b60:	f383 8811 	msr	BASEPRI, r3
 8004b64:	f3bf 8f6f 	isb	sy
 8004b68:	f3bf 8f4f 	dsb	sy
 8004b6c:	e7fe      	b.n	8004b6c <vTaskStartScheduler+0x58>
}
 8004b6e:	b002      	add	sp, #8
 8004b70:	bd10      	pop	{r4, pc}
 8004b72:	bf00      	nop
 8004b74:	20003ed4 	.word	0x20003ed4
 8004b78:	08006f34 	.word	0x08006f34
 8004b7c:	08004e15 	.word	0x08004e15
 8004b80:	20003ed8 	.word	0x20003ed8
 8004b84:	20003ef4 	.word	0x20003ef4
 8004b88:	20003f20 	.word	0x20003f20

08004b8c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8004b8c:	4a02      	ldr	r2, [pc, #8]	; (8004b98 <vTaskSuspendAll+0xc>)
 8004b8e:	6813      	ldr	r3, [r2, #0]
 8004b90:	3301      	adds	r3, #1
 8004b92:	6013      	str	r3, [r2, #0]
 8004b94:	4770      	bx	lr
 8004b96:	bf00      	nop
 8004b98:	20003ea0 	.word	0x20003ea0

08004b9c <xTaskGetTickCount>:
		xTicks = xTickCount;
 8004b9c:	4b01      	ldr	r3, [pc, #4]	; (8004ba4 <xTaskGetTickCount+0x8>)
 8004b9e:	6818      	ldr	r0, [r3, #0]
}
 8004ba0:	4770      	bx	lr
 8004ba2:	bf00      	nop
 8004ba4:	20003f20 	.word	0x20003f20

08004ba8 <xTaskGetTickCountFromISR>:
{
 8004ba8:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004baa:	f7ff fa5b 	bl	8004064 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8004bae:	4b01      	ldr	r3, [pc, #4]	; (8004bb4 <xTaskGetTickCountFromISR+0xc>)
 8004bb0:	6818      	ldr	r0, [r3, #0]
}
 8004bb2:	bd08      	pop	{r3, pc}
 8004bb4:	20003f20 	.word	0x20003f20

08004bb8 <xTaskIncrementTick>:
{
 8004bb8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004bbc:	4b3c      	ldr	r3, [pc, #240]	; (8004cb0 <xTaskIncrementTick+0xf8>)
 8004bbe:	681b      	ldr	r3, [r3, #0]
 8004bc0:	2b00      	cmp	r3, #0
 8004bc2:	d153      	bne.n	8004c6c <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + 1;
 8004bc4:	4b3b      	ldr	r3, [pc, #236]	; (8004cb4 <xTaskIncrementTick+0xfc>)
 8004bc6:	681c      	ldr	r4, [r3, #0]
 8004bc8:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8004bca:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 8004bcc:	b9bc      	cbnz	r4, 8004bfe <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8004bce:	4b3a      	ldr	r3, [pc, #232]	; (8004cb8 <xTaskIncrementTick+0x100>)
 8004bd0:	681a      	ldr	r2, [r3, #0]
 8004bd2:	6812      	ldr	r2, [r2, #0]
 8004bd4:	b142      	cbz	r2, 8004be8 <xTaskIncrementTick+0x30>
 8004bd6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bda:	f383 8811 	msr	BASEPRI, r3
 8004bde:	f3bf 8f6f 	isb	sy
 8004be2:	f3bf 8f4f 	dsb	sy
 8004be6:	e7fe      	b.n	8004be6 <xTaskIncrementTick+0x2e>
 8004be8:	4a34      	ldr	r2, [pc, #208]	; (8004cbc <xTaskIncrementTick+0x104>)
 8004bea:	6819      	ldr	r1, [r3, #0]
 8004bec:	6810      	ldr	r0, [r2, #0]
 8004bee:	6018      	str	r0, [r3, #0]
 8004bf0:	6011      	str	r1, [r2, #0]
 8004bf2:	4a33      	ldr	r2, [pc, #204]	; (8004cc0 <xTaskIncrementTick+0x108>)
 8004bf4:	6813      	ldr	r3, [r2, #0]
 8004bf6:	3301      	adds	r3, #1
 8004bf8:	6013      	str	r3, [r2, #0]
 8004bfa:	f7ff fe59 	bl	80048b0 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004bfe:	4d31      	ldr	r5, [pc, #196]	; (8004cc4 <xTaskIncrementTick+0x10c>)
 8004c00:	4f31      	ldr	r7, [pc, #196]	; (8004cc8 <xTaskIncrementTick+0x110>)
 8004c02:	682b      	ldr	r3, [r5, #0]
 8004c04:	429c      	cmp	r4, r3
 8004c06:	f04f 0b00 	mov.w	fp, #0
 8004c0a:	d33e      	bcc.n	8004c8a <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004c0c:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8004cb8 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 8004c10:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8004cd8 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004c14:	f8d8 2000 	ldr.w	r2, [r8]
 8004c18:	6812      	ldr	r2, [r2, #0]
 8004c1a:	bb72      	cbnz	r2, 8004c7a <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004c1c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004c20:	602a      	str	r2, [r5, #0]
					break;
 8004c22:	e032      	b.n	8004c8a <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004c24:	f106 0a04 	add.w	sl, r6, #4
 8004c28:	4650      	mov	r0, sl
 8004c2a:	f7ff f8a4 	bl	8003d76 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004c2e:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8004c30:	b119      	cbz	r1, 8004c3a <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004c32:	f106 0018 	add.w	r0, r6, #24
 8004c36:	f7ff f89e 	bl	8003d76 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004c3a:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8004c3c:	f8d9 3000 	ldr.w	r3, [r9]
 8004c40:	2201      	movs	r2, #1
 8004c42:	fa02 f100 	lsl.w	r1, r2, r0
 8004c46:	4319      	orrs	r1, r3
 8004c48:	4b20      	ldr	r3, [pc, #128]	; (8004ccc <xTaskIncrementTick+0x114>)
 8004c4a:	f8c9 1000 	str.w	r1, [r9]
 8004c4e:	f04f 0e14 	mov.w	lr, #20
 8004c52:	4651      	mov	r1, sl
 8004c54:	fb0e 3000 	mla	r0, lr, r0, r3
 8004c58:	f7ff f86a 	bl	8003d30 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004c5c:	6838      	ldr	r0, [r7, #0]
 8004c5e:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8004c60:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8004c62:	4291      	cmp	r1, r2
 8004c64:	bf28      	it	cs
 8004c66:	f04f 0b01 	movcs.w	fp, #1
 8004c6a:	e7d3      	b.n	8004c14 <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8004c6c:	4a18      	ldr	r2, [pc, #96]	; (8004cd0 <xTaskIncrementTick+0x118>)
 8004c6e:	6813      	ldr	r3, [r2, #0]
 8004c70:	3301      	adds	r3, #1
 8004c72:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8004c74:	f04f 0b00 	mov.w	fp, #0
 8004c78:	e011      	b.n	8004c9e <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004c7a:	f8d8 2000 	ldr.w	r2, [r8]
 8004c7e:	68d2      	ldr	r2, [r2, #12]
 8004c80:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8004c82:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8004c84:	428c      	cmp	r4, r1
 8004c86:	d2cd      	bcs.n	8004c24 <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8004c88:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004c8a:	683a      	ldr	r2, [r7, #0]
 8004c8c:	4b0f      	ldr	r3, [pc, #60]	; (8004ccc <xTaskIncrementTick+0x114>)
 8004c8e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8004c90:	2214      	movs	r2, #20
 8004c92:	434a      	muls	r2, r1
 8004c94:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 8004c96:	2a02      	cmp	r2, #2
 8004c98:	bf28      	it	cs
 8004c9a:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 8004c9e:	4a0d      	ldr	r2, [pc, #52]	; (8004cd4 <xTaskIncrementTick+0x11c>)
 8004ca0:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 8004ca2:	2a00      	cmp	r2, #0
 8004ca4:	bf18      	it	ne
 8004ca6:	f04f 0b01 	movne.w	fp, #1
}
 8004caa:	4658      	mov	r0, fp
 8004cac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004cb0:	20003ea0 	.word	0x20003ea0
 8004cb4:	20003f20 	.word	0x20003f20
 8004cb8:	20003e00 	.word	0x20003e00
 8004cbc:	20003e04 	.word	0x20003e04
 8004cc0:	20003edc 	.word	0x20003edc
 8004cc4:	20003ed8 	.word	0x20003ed8
 8004cc8:	20003dfc 	.word	0x20003dfc
 8004ccc:	20003e08 	.word	0x20003e08
 8004cd0:	20003e9c 	.word	0x20003e9c
 8004cd4:	20003f24 	.word	0x20003f24
 8004cd8:	20003ea8 	.word	0x20003ea8

08004cdc <xTaskResumeAll>:
{
 8004cdc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8004ce0:	4c31      	ldr	r4, [pc, #196]	; (8004da8 <xTaskResumeAll+0xcc>)
 8004ce2:	6823      	ldr	r3, [r4, #0]
 8004ce4:	b943      	cbnz	r3, 8004cf8 <xTaskResumeAll+0x1c>
 8004ce6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004cea:	f383 8811 	msr	BASEPRI, r3
 8004cee:	f3bf 8f6f 	isb	sy
 8004cf2:	f3bf 8f4f 	dsb	sy
 8004cf6:	e7fe      	b.n	8004cf6 <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8004cf8:	f7ff f8ac 	bl	8003e54 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8004cfc:	6823      	ldr	r3, [r4, #0]
 8004cfe:	3b01      	subs	r3, #1
 8004d00:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004d02:	6824      	ldr	r4, [r4, #0]
 8004d04:	b12c      	cbz	r4, 8004d12 <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8004d06:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8004d08:	f7ff f8c6 	bl	8003e98 <vPortExitCritical>
}
 8004d0c:	4620      	mov	r0, r4
 8004d0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8004d12:	4b26      	ldr	r3, [pc, #152]	; (8004dac <xTaskResumeAll+0xd0>)
 8004d14:	681b      	ldr	r3, [r3, #0]
 8004d16:	2b00      	cmp	r3, #0
 8004d18:	d0f5      	beq.n	8004d06 <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004d1a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 8004dc4 <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 8004d1e:	4f24      	ldr	r7, [pc, #144]	; (8004db0 <xTaskResumeAll+0xd4>)
 8004d20:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8004dc8 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004d24:	f8d9 3000 	ldr.w	r3, [r9]
 8004d28:	b9e3      	cbnz	r3, 8004d64 <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 8004d2a:	b10c      	cbz	r4, 8004d30 <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 8004d2c:	f7ff fdc0 	bl	80048b0 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8004d30:	4d20      	ldr	r5, [pc, #128]	; (8004db4 <xTaskResumeAll+0xd8>)
 8004d32:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8004d34:	b144      	cbz	r4, 8004d48 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 8004d36:	4e20      	ldr	r6, [pc, #128]	; (8004db8 <xTaskResumeAll+0xdc>)
 8004d38:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 8004d3a:	f7ff ff3d 	bl	8004bb8 <xTaskIncrementTick>
 8004d3e:	b100      	cbz	r0, 8004d42 <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 8004d40:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8004d42:	3c01      	subs	r4, #1
 8004d44:	d1f9      	bne.n	8004d3a <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 8004d46:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8004d48:	4b1b      	ldr	r3, [pc, #108]	; (8004db8 <xTaskResumeAll+0xdc>)
 8004d4a:	681b      	ldr	r3, [r3, #0]
 8004d4c:	2b00      	cmp	r3, #0
 8004d4e:	d0da      	beq.n	8004d06 <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 8004d50:	4b1a      	ldr	r3, [pc, #104]	; (8004dbc <xTaskResumeAll+0xe0>)
 8004d52:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004d56:	601a      	str	r2, [r3, #0]
 8004d58:	f3bf 8f4f 	dsb	sy
 8004d5c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8004d60:	2401      	movs	r4, #1
 8004d62:	e7d1      	b.n	8004d08 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8004d64:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8004d68:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004d6a:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004d6c:	f104 0018 	add.w	r0, r4, #24
 8004d70:	f7ff f801 	bl	8003d76 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004d74:	4630      	mov	r0, r6
 8004d76:	f7fe fffe 	bl	8003d76 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004d7a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004d7c:	6839      	ldr	r1, [r7, #0]
 8004d7e:	2501      	movs	r5, #1
 8004d80:	fa05 f302 	lsl.w	r3, r5, r2
 8004d84:	2014      	movs	r0, #20
 8004d86:	430b      	orrs	r3, r1
 8004d88:	fb00 8002 	mla	r0, r0, r2, r8
 8004d8c:	4631      	mov	r1, r6
 8004d8e:	603b      	str	r3, [r7, #0]
 8004d90:	f7fe ffce 	bl	8003d30 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004d94:	4b0a      	ldr	r3, [pc, #40]	; (8004dc0 <xTaskResumeAll+0xe4>)
 8004d96:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004d98:	681b      	ldr	r3, [r3, #0]
 8004d9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004d9c:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8004d9e:	bf24      	itt	cs
 8004da0:	4b05      	ldrcs	r3, [pc, #20]	; (8004db8 <xTaskResumeAll+0xdc>)
 8004da2:	601d      	strcs	r5, [r3, #0]
 8004da4:	e7be      	b.n	8004d24 <xTaskResumeAll+0x48>
 8004da6:	bf00      	nop
 8004da8:	20003ea0 	.word	0x20003ea0
 8004dac:	20003e94 	.word	0x20003e94
 8004db0:	20003ea8 	.word	0x20003ea8
 8004db4:	20003e9c 	.word	0x20003e9c
 8004db8:	20003f24 	.word	0x20003f24
 8004dbc:	e000ed04 	.word	0xe000ed04
 8004dc0:	20003dfc 	.word	0x20003dfc
 8004dc4:	20003ee0 	.word	0x20003ee0
 8004dc8:	20003e08 	.word	0x20003e08

08004dcc <vTaskDelay>:
	{
 8004dcc:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8004dce:	b940      	cbnz	r0, 8004de2 <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8004dd0:	4b0e      	ldr	r3, [pc, #56]	; (8004e0c <vTaskDelay+0x40>)
 8004dd2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004dd6:	601a      	str	r2, [r3, #0]
 8004dd8:	f3bf 8f4f 	dsb	sy
 8004ddc:	f3bf 8f6f 	isb	sy
 8004de0:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8004de2:	4b0b      	ldr	r3, [pc, #44]	; (8004e10 <vTaskDelay+0x44>)
 8004de4:	6819      	ldr	r1, [r3, #0]
 8004de6:	b141      	cbz	r1, 8004dfa <vTaskDelay+0x2e>
 8004de8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004dec:	f383 8811 	msr	BASEPRI, r3
 8004df0:	f3bf 8f6f 	isb	sy
 8004df4:	f3bf 8f4f 	dsb	sy
 8004df8:	e7fe      	b.n	8004df8 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8004dfa:	f7ff fec7 	bl	8004b8c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8004dfe:	f7ff fd69 	bl	80048d4 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8004e02:	f7ff ff6b 	bl	8004cdc <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8004e06:	2800      	cmp	r0, #0
 8004e08:	d0e2      	beq.n	8004dd0 <vTaskDelay+0x4>
 8004e0a:	bd08      	pop	{r3, pc}
 8004e0c:	e000ed04 	.word	0xe000ed04
 8004e10:	20003ea0 	.word	0x20003ea0

08004e14 <prvIdleTask>:
{
 8004e14:	b508      	push	{r3, lr}
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004e16:	4e17      	ldr	r6, [pc, #92]	; (8004e74 <prvIdleTask+0x60>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004e18:	4c17      	ldr	r4, [pc, #92]	; (8004e78 <prvIdleTask+0x64>)
 8004e1a:	6823      	ldr	r3, [r4, #0]
 8004e1c:	b963      	cbnz	r3, 8004e38 <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8004e1e:	4b17      	ldr	r3, [pc, #92]	; (8004e7c <prvIdleTask+0x68>)
 8004e20:	681b      	ldr	r3, [r3, #0]
 8004e22:	2b01      	cmp	r3, #1
 8004e24:	d9f8      	bls.n	8004e18 <prvIdleTask+0x4>
				taskYIELD();
 8004e26:	4b16      	ldr	r3, [pc, #88]	; (8004e80 <prvIdleTask+0x6c>)
 8004e28:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004e2c:	601a      	str	r2, [r3, #0]
 8004e2e:	f3bf 8f4f 	dsb	sy
 8004e32:	f3bf 8f6f 	isb	sy
 8004e36:	e7ef      	b.n	8004e18 <prvIdleTask+0x4>
			vTaskSuspendAll();
 8004e38:	f7ff fea8 	bl	8004b8c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8004e3c:	6835      	ldr	r5, [r6, #0]
			( void ) xTaskResumeAll();
 8004e3e:	f7ff ff4d 	bl	8004cdc <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 8004e42:	2d00      	cmp	r5, #0
 8004e44:	d0e9      	beq.n	8004e1a <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 8004e46:	f7ff f805 	bl	8003e54 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8004e4a:	68f3      	ldr	r3, [r6, #12]
 8004e4c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e4e:	1d28      	adds	r0, r5, #4
 8004e50:	f7fe ff91 	bl	8003d76 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8004e54:	4a0b      	ldr	r2, [pc, #44]	; (8004e84 <prvIdleTask+0x70>)
 8004e56:	6813      	ldr	r3, [r2, #0]
 8004e58:	3b01      	subs	r3, #1
 8004e5a:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 8004e5c:	6823      	ldr	r3, [r4, #0]
 8004e5e:	3b01      	subs	r3, #1
 8004e60:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 8004e62:	f7ff f819 	bl	8003e98 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8004e66:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8004e68:	f7ff f9dc 	bl	8004224 <vPortFree>
			vPortFree( pxTCB );
 8004e6c:	4628      	mov	r0, r5
 8004e6e:	f7ff f9d9 	bl	8004224 <vPortFree>
 8004e72:	e7d2      	b.n	8004e1a <prvIdleTask+0x6>
 8004e74:	20003f0c 	.word	0x20003f0c
 8004e78:	20003e98 	.word	0x20003e98
 8004e7c:	20003e08 	.word	0x20003e08
 8004e80:	e000ed04 	.word	0xe000ed04
 8004e84:	20003e94 	.word	0x20003e94

08004e88 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004e88:	4b17      	ldr	r3, [pc, #92]	; (8004ee8 <vTaskSwitchContext+0x60>)
 8004e8a:	681a      	ldr	r2, [r3, #0]
 8004e8c:	4b17      	ldr	r3, [pc, #92]	; (8004eec <vTaskSwitchContext+0x64>)
{
 8004e8e:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004e90:	b112      	cbz	r2, 8004e98 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8004e92:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004e94:	601a      	str	r2, [r3, #0]
 8004e96:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8004e98:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004e9a:	4b15      	ldr	r3, [pc, #84]	; (8004ef0 <vTaskSwitchContext+0x68>)
 8004e9c:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8004e9e:	fab3 f383 	clz	r3, r3
 8004ea2:	b2db      	uxtb	r3, r3
 8004ea4:	f1c3 031f 	rsb	r3, r3, #31
 8004ea8:	2214      	movs	r2, #20
 8004eaa:	4912      	ldr	r1, [pc, #72]	; (8004ef4 <vTaskSwitchContext+0x6c>)
 8004eac:	435a      	muls	r2, r3
 8004eae:	1888      	adds	r0, r1, r2
 8004eb0:	588c      	ldr	r4, [r1, r2]
 8004eb2:	b944      	cbnz	r4, 8004ec6 <vTaskSwitchContext+0x3e>
	__asm volatile
 8004eb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004eb8:	f383 8811 	msr	BASEPRI, r3
 8004ebc:	f3bf 8f6f 	isb	sy
 8004ec0:	f3bf 8f4f 	dsb	sy
 8004ec4:	e7fe      	b.n	8004ec4 <vTaskSwitchContext+0x3c>
 8004ec6:	6844      	ldr	r4, [r0, #4]
 8004ec8:	3208      	adds	r2, #8
 8004eca:	6864      	ldr	r4, [r4, #4]
 8004ecc:	6044      	str	r4, [r0, #4]
 8004ece:	440a      	add	r2, r1
 8004ed0:	4294      	cmp	r4, r2
 8004ed2:	bf04      	itt	eq
 8004ed4:	6862      	ldreq	r2, [r4, #4]
 8004ed6:	6042      	streq	r2, [r0, #4]
 8004ed8:	2214      	movs	r2, #20
 8004eda:	fb02 1303 	mla	r3, r2, r3, r1
 8004ede:	685b      	ldr	r3, [r3, #4]
 8004ee0:	68da      	ldr	r2, [r3, #12]
 8004ee2:	4b05      	ldr	r3, [pc, #20]	; (8004ef8 <vTaskSwitchContext+0x70>)
 8004ee4:	e7d6      	b.n	8004e94 <vTaskSwitchContext+0xc>
 8004ee6:	bf00      	nop
 8004ee8:	20003ea0 	.word	0x20003ea0
 8004eec:	20003f24 	.word	0x20003f24
 8004ef0:	20003ea8 	.word	0x20003ea8
 8004ef4:	20003e08 	.word	0x20003e08
 8004ef8:	20003dfc 	.word	0x20003dfc

08004efc <vTaskPlaceOnEventList>:
{
 8004efc:	b510      	push	{r4, lr}
 8004efe:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 8004f00:	b940      	cbnz	r0, 8004f14 <vTaskPlaceOnEventList+0x18>
 8004f02:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f06:	f383 8811 	msr	BASEPRI, r3
 8004f0a:	f3bf 8f6f 	isb	sy
 8004f0e:	f3bf 8f4f 	dsb	sy
 8004f12:	e7fe      	b.n	8004f12 <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004f14:	4b05      	ldr	r3, [pc, #20]	; (8004f2c <vTaskPlaceOnEventList+0x30>)
 8004f16:	6819      	ldr	r1, [r3, #0]
 8004f18:	3118      	adds	r1, #24
 8004f1a:	f7fe ff15 	bl	8003d48 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004f1e:	4620      	mov	r0, r4
 8004f20:	2101      	movs	r1, #1
}
 8004f22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004f26:	f7ff bcd5 	b.w	80048d4 <prvAddCurrentTaskToDelayedList>
 8004f2a:	bf00      	nop
 8004f2c:	20003dfc 	.word	0x20003dfc

08004f30 <xTaskRemoveFromEventList>:
{
 8004f30:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8004f32:	68c3      	ldr	r3, [r0, #12]
 8004f34:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8004f36:	b944      	cbnz	r4, 8004f4a <xTaskRemoveFromEventList+0x1a>
 8004f38:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f3c:	f383 8811 	msr	BASEPRI, r3
 8004f40:	f3bf 8f6f 	isb	sy
 8004f44:	f3bf 8f4f 	dsb	sy
 8004f48:	e7fe      	b.n	8004f48 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8004f4a:	f104 0518 	add.w	r5, r4, #24
 8004f4e:	4628      	mov	r0, r5
 8004f50:	f7fe ff11 	bl	8003d76 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004f54:	4b11      	ldr	r3, [pc, #68]	; (8004f9c <xTaskRemoveFromEventList+0x6c>)
 8004f56:	681b      	ldr	r3, [r3, #0]
 8004f58:	b9e3      	cbnz	r3, 8004f94 <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8004f5a:	1d25      	adds	r5, r4, #4
 8004f5c:	4628      	mov	r0, r5
 8004f5e:	f7fe ff0a 	bl	8003d76 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8004f62:	490f      	ldr	r1, [pc, #60]	; (8004fa0 <xTaskRemoveFromEventList+0x70>)
 8004f64:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004f66:	6808      	ldr	r0, [r1, #0]
 8004f68:	2301      	movs	r3, #1
 8004f6a:	4093      	lsls	r3, r2
 8004f6c:	4303      	orrs	r3, r0
 8004f6e:	600b      	str	r3, [r1, #0]
 8004f70:	4b0c      	ldr	r3, [pc, #48]	; (8004fa4 <xTaskRemoveFromEventList+0x74>)
 8004f72:	2014      	movs	r0, #20
 8004f74:	4629      	mov	r1, r5
 8004f76:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004f7a:	f7fe fed9 	bl	8003d30 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004f7e:	4b0a      	ldr	r3, [pc, #40]	; (8004fa8 <xTaskRemoveFromEventList+0x78>)
 8004f80:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004f82:	681b      	ldr	r3, [r3, #0]
 8004f84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004f86:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8004f88:	bf83      	ittte	hi
 8004f8a:	4b08      	ldrhi	r3, [pc, #32]	; (8004fac <xTaskRemoveFromEventList+0x7c>)
 8004f8c:	2001      	movhi	r0, #1
 8004f8e:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 8004f90:	2000      	movls	r0, #0
}
 8004f92:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004f94:	4629      	mov	r1, r5
 8004f96:	4806      	ldr	r0, [pc, #24]	; (8004fb0 <xTaskRemoveFromEventList+0x80>)
 8004f98:	e7ef      	b.n	8004f7a <xTaskRemoveFromEventList+0x4a>
 8004f9a:	bf00      	nop
 8004f9c:	20003ea0 	.word	0x20003ea0
 8004fa0:	20003ea8 	.word	0x20003ea8
 8004fa4:	20003e08 	.word	0x20003e08
 8004fa8:	20003dfc 	.word	0x20003dfc
 8004fac:	20003f24 	.word	0x20003f24
 8004fb0:	20003ee0 	.word	0x20003ee0

08004fb4 <vTaskSetTimeOutState>:
{
 8004fb4:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8004fb6:	b908      	cbnz	r0, 8004fbc <vTaskSetTimeOutState+0x8>
 8004fb8:	f7ff fcd2 	bl	8004960 <prvTaskIsTaskSuspended.part.0>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8004fbc:	4b03      	ldr	r3, [pc, #12]	; (8004fcc <vTaskSetTimeOutState+0x18>)
 8004fbe:	681b      	ldr	r3, [r3, #0]
 8004fc0:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8004fc2:	4b03      	ldr	r3, [pc, #12]	; (8004fd0 <vTaskSetTimeOutState+0x1c>)
 8004fc4:	681b      	ldr	r3, [r3, #0]
 8004fc6:	6043      	str	r3, [r0, #4]
 8004fc8:	bd08      	pop	{r3, pc}
 8004fca:	bf00      	nop
 8004fcc:	20003edc 	.word	0x20003edc
 8004fd0:	20003f20 	.word	0x20003f20

08004fd4 <xTaskCheckForTimeOut>:
{
 8004fd4:	b538      	push	{r3, r4, r5, lr}
 8004fd6:	460d      	mov	r5, r1
	configASSERT( pxTimeOut );
 8004fd8:	4604      	mov	r4, r0
 8004fda:	b940      	cbnz	r0, 8004fee <xTaskCheckForTimeOut+0x1a>
 8004fdc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004fe0:	f383 8811 	msr	BASEPRI, r3
 8004fe4:	f3bf 8f6f 	isb	sy
 8004fe8:	f3bf 8f4f 	dsb	sy
 8004fec:	e7fe      	b.n	8004fec <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
 8004fee:	b941      	cbnz	r1, 8005002 <xTaskCheckForTimeOut+0x2e>
 8004ff0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ff4:	f383 8811 	msr	BASEPRI, r3
 8004ff8:	f3bf 8f6f 	isb	sy
 8004ffc:	f3bf 8f4f 	dsb	sy
 8005000:	e7fe      	b.n	8005000 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
 8005002:	f7fe ff27 	bl	8003e54 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8005006:	4b0e      	ldr	r3, [pc, #56]	; (8005040 <xTaskCheckForTimeOut+0x6c>)
 8005008:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 800500a:	682b      	ldr	r3, [r5, #0]
 800500c:	1c5a      	adds	r2, r3, #1
 800500e:	d010      	beq.n	8005032 <xTaskCheckForTimeOut+0x5e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005010:	4a0c      	ldr	r2, [pc, #48]	; (8005044 <xTaskCheckForTimeOut+0x70>)
 8005012:	6820      	ldr	r0, [r4, #0]
 8005014:	6812      	ldr	r2, [r2, #0]
 8005016:	4290      	cmp	r0, r2
 8005018:	6862      	ldr	r2, [r4, #4]
 800501a:	d001      	beq.n	8005020 <xTaskCheckForTimeOut+0x4c>
 800501c:	4291      	cmp	r1, r2
 800501e:	d20d      	bcs.n	800503c <xTaskCheckForTimeOut+0x68>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005020:	1a88      	subs	r0, r1, r2
 8005022:	4283      	cmp	r3, r0
 8005024:	d90a      	bls.n	800503c <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8005026:	1a5b      	subs	r3, r3, r1
 8005028:	4413      	add	r3, r2
 800502a:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800502c:	4620      	mov	r0, r4
 800502e:	f7ff ffc1 	bl	8004fb4 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 8005032:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8005034:	f7fe ff30 	bl	8003e98 <vPortExitCritical>
}
 8005038:	4620      	mov	r0, r4
 800503a:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdTRUE;
 800503c:	2401      	movs	r4, #1
 800503e:	e7f9      	b.n	8005034 <xTaskCheckForTimeOut+0x60>
 8005040:	20003f20 	.word	0x20003f20
 8005044:	20003edc 	.word	0x20003edc

08005048 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8005048:	4b01      	ldr	r3, [pc, #4]	; (8005050 <vTaskMissedYield+0x8>)
 800504a:	2201      	movs	r2, #1
 800504c:	601a      	str	r2, [r3, #0]
 800504e:	4770      	bx	lr
 8005050:	20003f24 	.word	0x20003f24

08005054 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8005054:	4b05      	ldr	r3, [pc, #20]	; (800506c <xTaskGetSchedulerState+0x18>)
 8005056:	681b      	ldr	r3, [r3, #0]
 8005058:	b133      	cbz	r3, 8005068 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800505a:	4b05      	ldr	r3, [pc, #20]	; (8005070 <xTaskGetSchedulerState+0x1c>)
 800505c:	681b      	ldr	r3, [r3, #0]
 800505e:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8005060:	bf0c      	ite	eq
 8005062:	2002      	moveq	r0, #2
 8005064:	2000      	movne	r0, #0
 8005066:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005068:	2001      	movs	r0, #1
	}
 800506a:	4770      	bx	lr
 800506c:	20003ef4 	.word	0x20003ef4
 8005070:	20003ea0 	.word	0x20003ea0

08005074 <vTaskPriorityInherit>:
	{
 8005074:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 8005078:	4604      	mov	r4, r0
 800507a:	2800      	cmp	r0, #0
 800507c:	d038      	beq.n	80050f0 <vTaskPriorityInherit+0x7c>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800507e:	4d1d      	ldr	r5, [pc, #116]	; (80050f4 <vTaskPriorityInherit+0x80>)
 8005080:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005082:	682a      	ldr	r2, [r5, #0]
 8005084:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005086:	4293      	cmp	r3, r2
 8005088:	d232      	bcs.n	80050f0 <vTaskPriorityInherit+0x7c>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800508a:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800508c:	4e1a      	ldr	r6, [pc, #104]	; (80050f8 <vTaskPriorityInherit+0x84>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800508e:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005090:	bfa1      	itttt	ge
 8005092:	682a      	ldrge	r2, [r5, #0]
 8005094:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 8005096:	f1c2 0207 	rsbge	r2, r2, #7
 800509a:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800509c:	2714      	movs	r7, #20
 800509e:	6942      	ldr	r2, [r0, #20]
 80050a0:	fb07 6303 	mla	r3, r7, r3, r6
 80050a4:	429a      	cmp	r2, r3
 80050a6:	d120      	bne.n	80050ea <vTaskPriorityInherit+0x76>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80050a8:	f100 0804 	add.w	r8, r0, #4
 80050ac:	4640      	mov	r0, r8
 80050ae:	f7fe fe62 	bl	8003d76 <uxListRemove>
 80050b2:	4a12      	ldr	r2, [pc, #72]	; (80050fc <vTaskPriorityInherit+0x88>)
 80050b4:	b948      	cbnz	r0, 80050ca <vTaskPriorityInherit+0x56>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80050b6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80050b8:	4347      	muls	r7, r0
 80050ba:	59f3      	ldr	r3, [r6, r7]
 80050bc:	b92b      	cbnz	r3, 80050ca <vTaskPriorityInherit+0x56>
 80050be:	6813      	ldr	r3, [r2, #0]
 80050c0:	2101      	movs	r1, #1
 80050c2:	4081      	lsls	r1, r0
 80050c4:	ea23 0301 	bic.w	r3, r3, r1
 80050c8:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80050ca:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 80050cc:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80050ce:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80050d0:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80050d2:	2301      	movs	r3, #1
 80050d4:	4083      	lsls	r3, r0
 80050d6:	430b      	orrs	r3, r1
 80050d8:	6013      	str	r3, [r2, #0]
 80050da:	2314      	movs	r3, #20
 80050dc:	4641      	mov	r1, r8
 80050de:	fb03 6000 	mla	r0, r3, r0, r6
	}
 80050e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 80050e6:	f7fe be23 	b.w	8003d30 <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80050ea:	682b      	ldr	r3, [r5, #0]
 80050ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80050ee:	62c3      	str	r3, [r0, #44]	; 0x2c
 80050f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050f4:	20003dfc 	.word	0x20003dfc
 80050f8:	20003e08 	.word	0x20003e08
 80050fc:	20003ea8 	.word	0x20003ea8

08005100 <xTaskPriorityDisinherit>:
	{
 8005100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8005102:	4604      	mov	r4, r0
 8005104:	b908      	cbnz	r0, 800510a <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8005106:	2000      	movs	r0, #0
 8005108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 800510a:	4b22      	ldr	r3, [pc, #136]	; (8005194 <xTaskPriorityDisinherit+0x94>)
 800510c:	681b      	ldr	r3, [r3, #0]
 800510e:	4298      	cmp	r0, r3
 8005110:	d008      	beq.n	8005124 <xTaskPriorityDisinherit+0x24>
 8005112:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005116:	f383 8811 	msr	BASEPRI, r3
 800511a:	f3bf 8f6f 	isb	sy
 800511e:	f3bf 8f4f 	dsb	sy
 8005122:	e7fe      	b.n	8005122 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8005124:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8005126:	b943      	cbnz	r3, 800513a <xTaskPriorityDisinherit+0x3a>
 8005128:	f04f 0350 	mov.w	r3, #80	; 0x50
 800512c:	f383 8811 	msr	BASEPRI, r3
 8005130:	f3bf 8f6f 	isb	sy
 8005134:	f3bf 8f4f 	dsb	sy
 8005138:	e7fe      	b.n	8005138 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800513a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800513c:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 800513e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005140:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8005142:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005144:	d0df      	beq.n	8005106 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8005146:	2b00      	cmp	r3, #0
 8005148:	d1dd      	bne.n	8005106 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800514a:	1d05      	adds	r5, r0, #4
 800514c:	4628      	mov	r0, r5
 800514e:	f7fe fe12 	bl	8003d76 <uxListRemove>
 8005152:	4e11      	ldr	r6, [pc, #68]	; (8005198 <xTaskPriorityDisinherit+0x98>)
 8005154:	4a11      	ldr	r2, [pc, #68]	; (800519c <xTaskPriorityDisinherit+0x9c>)
 8005156:	b950      	cbnz	r0, 800516e <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005158:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800515a:	2114      	movs	r1, #20
 800515c:	4379      	muls	r1, r7
 800515e:	5873      	ldr	r3, [r6, r1]
 8005160:	b92b      	cbnz	r3, 800516e <xTaskPriorityDisinherit+0x6e>
 8005162:	6813      	ldr	r3, [r2, #0]
 8005164:	2001      	movs	r0, #1
 8005166:	40b8      	lsls	r0, r7
 8005168:	ea23 0300 	bic.w	r3, r3, r0
 800516c:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800516e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005170:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005172:	f1c3 0107 	rsb	r1, r3, #7
 8005176:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8005178:	6811      	ldr	r1, [r2, #0]
 800517a:	2401      	movs	r4, #1
 800517c:	fa04 f003 	lsl.w	r0, r4, r3
 8005180:	4308      	orrs	r0, r1
 8005182:	6010      	str	r0, [r2, #0]
 8005184:	2014      	movs	r0, #20
 8005186:	fb00 6003 	mla	r0, r0, r3, r6
 800518a:	4629      	mov	r1, r5
 800518c:	f7fe fdd0 	bl	8003d30 <vListInsertEnd>
					xReturn = pdTRUE;
 8005190:	4620      	mov	r0, r4
	}
 8005192:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005194:	20003dfc 	.word	0x20003dfc
 8005198:	20003e08 	.word	0x20003e08
 800519c:	20003ea8 	.word	0x20003ea8

080051a0 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80051a0:	4b04      	ldr	r3, [pc, #16]	; (80051b4 <pvTaskIncrementMutexHeldCount+0x14>)
 80051a2:	681a      	ldr	r2, [r3, #0]
 80051a4:	b11a      	cbz	r2, 80051ae <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 80051a6:	6819      	ldr	r1, [r3, #0]
 80051a8:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 80051aa:	3201      	adds	r2, #1
 80051ac:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 80051ae:	6818      	ldr	r0, [r3, #0]
	}
 80051b0:	4770      	bx	lr
 80051b2:	bf00      	nop
 80051b4:	20003dfc 	.word	0x20003dfc

080051b8 <CAN_Config>:

/*
 * Configures CAN protocol for 250kbit/s without interrupt for reading (only polling).
 */
void CAN_Config(uint32_t id)
{
 80051b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  CAN_FilterTypeDef  sFilterConfig;

  /*##-1- Configure the CAN peripheral #######################################*/
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 9;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
 80051ba:	4a1a      	ldr	r2, [pc, #104]	; (8005224 <CAN_Config+0x6c>)
  hcan1.Instance = CAN1;
 80051bc:	4d1a      	ldr	r5, [pc, #104]	; (8005228 <CAN_Config+0x70>)
  hcan1.Init.Mode = CAN_MODE_NORMAL;
 80051be:	2400      	movs	r4, #0
 80051c0:	2309      	movs	r3, #9
 80051c2:	e885 001c 	stmia.w	r5, {r2, r3, r4}
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;
 80051c6:	f44f 2340 	mov.w	r3, #786432	; 0xc0000
{
 80051ca:	b08b      	sub	sp, #44	; 0x2c
 80051cc:	4607      	mov	r7, r0
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
  hcan1.Init.TimeTriggeredMode = DISABLE;
  hcan1.Init.AutoBusOff = DISABLE;
  hcan1.Init.AutoWakeUp = DISABLE;
  hcan1.Init.AutoRetransmission = ENABLE;
 80051ce:	2601      	movs	r6, #1
  hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;
 80051d0:	612b      	str	r3, [r5, #16]
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
 80051d2:	4628      	mov	r0, r5
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
 80051d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80051d8:	616b      	str	r3, [r5, #20]
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
 80051da:	60ec      	str	r4, [r5, #12]
  hcan1.Init.TimeTriggeredMode = DISABLE;
 80051dc:	762c      	strb	r4, [r5, #24]
  hcan1.Init.AutoBusOff = DISABLE;
 80051de:	766c      	strb	r4, [r5, #25]
  hcan1.Init.AutoWakeUp = DISABLE;
 80051e0:	76ac      	strb	r4, [r5, #26]
  hcan1.Init.AutoRetransmission = ENABLE;
 80051e2:	76ee      	strb	r6, [r5, #27]
  hcan1.Init.ReceiveFifoLocked = DISABLE;
 80051e4:	772c      	strb	r4, [r5, #28]
  hcan1.Init.TransmitFifoPriority = DISABLE;
 80051e6:	776c      	strb	r4, [r5, #29]
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
 80051e8:	f7fb f9fe 	bl	80005e8 <HAL_CAN_Init>
  sFilterConfig.FilterIdLow = 0x0000;
  sFilterConfig.FilterMaskIdHigh = 0x0000;
  sFilterConfig.FilterMaskIdLow = 0x0000;
  sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
  sFilterConfig.FilterActivation = ENABLE;
  sFilterConfig.SlaveStartFilterBank = 14;
 80051ec:	230e      	movs	r3, #14

  if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK)
 80051ee:	4669      	mov	r1, sp
 80051f0:	4628      	mov	r0, r5
  sFilterConfig.SlaveStartFilterBank = 14;
 80051f2:	9309      	str	r3, [sp, #36]	; 0x24
  sFilterConfig.FilterBank = 0;
 80051f4:	9405      	str	r4, [sp, #20]
  sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 80051f6:	9406      	str	r4, [sp, #24]
  sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 80051f8:	9607      	str	r6, [sp, #28]
  sFilterConfig.FilterIdHigh = 0x0000;
 80051fa:	9400      	str	r4, [sp, #0]
  sFilterConfig.FilterIdLow = 0x0000;
 80051fc:	9401      	str	r4, [sp, #4]
  sFilterConfig.FilterMaskIdHigh = 0x0000;
 80051fe:	9402      	str	r4, [sp, #8]
  sFilterConfig.FilterMaskIdLow = 0x0000;
 8005200:	9403      	str	r4, [sp, #12]
  sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
 8005202:	9404      	str	r4, [sp, #16]
  sFilterConfig.FilterActivation = ENABLE;
 8005204:	9608      	str	r6, [sp, #32]
  if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK)
 8005206:	f7fb fa6b 	bl	80006e0 <HAL_CAN_ConfigFilter>
    /* Filter configuration Error */
//	  _Error_Handler(__FILE__, __LINE__);
  }

  /*##-3- Start the CAN peripheral ###########################################*/
  if (HAL_CAN_Start(&hcan1) != HAL_OK)
 800520a:	4628      	mov	r0, r5
 800520c:	f7fb faf2 	bl	80007f4 <HAL_CAN_Start>
//    /* Notification Error */
//	  _Error_Handler(__FILE__, __LINE__);
//  }

  /*##-5- Configure Transmission process #####################################*/
  TxHeader.StdId = id;
 8005210:	4b06      	ldr	r3, [pc, #24]	; (800522c <CAN_Config+0x74>)
  TxHeader.ExtId = id; // not needed
  TxHeader.RTR = CAN_RTR_DATA;
  TxHeader.IDE = CAN_ID_STD;
  TxHeader.DLC = 8;
 8005212:	2208      	movs	r2, #8
  TxHeader.StdId = id;
 8005214:	601f      	str	r7, [r3, #0]
  TxHeader.ExtId = id; // not needed
 8005216:	605f      	str	r7, [r3, #4]
  TxHeader.RTR = CAN_RTR_DATA;
 8005218:	60dc      	str	r4, [r3, #12]
  TxHeader.IDE = CAN_ID_STD;
 800521a:	609c      	str	r4, [r3, #8]
  TxHeader.DLC = 8;
 800521c:	611a      	str	r2, [r3, #16]
  TxHeader.TransmitGlobalTime = DISABLE;
 800521e:	751c      	strb	r4, [r3, #20]
}
 8005220:	b00b      	add	sp, #44	; 0x2c
 8005222:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005224:	40006400 	.word	0x40006400
 8005228:	20003fb0 	.word	0x20003fb0
 800522c:	20003f4c 	.word	0x20003f4c

08005230 <setFrame>:
 * Sends a frame of 8 bytes (payload) on the CAN bus using our predefined protocol.
 * byte 0..3 --> some uint32_t
 * byte 4    --> data_id, see CAN_communication.h
 * byte 5..7 --> timestamp
 */
void setFrame(uint32_t data, uint8_t data_id, uint32_t timestamp) {
 8005230:	4613      	mov	r3, r2
	TxData[0] = (uint8_t) (data >> 24);
 8005232:	4a10      	ldr	r2, [pc, #64]	; (8005274 <setFrame+0x44>)
void setFrame(uint32_t data, uint8_t data_id, uint32_t timestamp) {
 8005234:	b510      	push	{r4, lr}
	TxData[0] = (uint8_t) (data >> 24);
 8005236:	0e04      	lsrs	r4, r0, #24
	TxData[1] = (uint8_t) (data >> 16);
	TxData[2] = (uint8_t) (data >> 8);
	TxData[3] = (uint8_t) (data >> 0);
	TxData[4] = data_id;
 8005238:	7111      	strb	r1, [r2, #4]
	TxData[5] = (uint8_t) (timestamp >> 16);
 800523a:	0c19      	lsrs	r1, r3, #16
	TxData[0] = (uint8_t) (data >> 24);
 800523c:	7014      	strb	r4, [r2, #0]
	TxData[5] = (uint8_t) (timestamp >> 16);
 800523e:	7151      	strb	r1, [r2, #5]
	TxData[1] = (uint8_t) (data >> 16);
 8005240:	0c04      	lsrs	r4, r0, #16
	TxData[6] = (uint8_t) (timestamp >> 8);
 8005242:	0a19      	lsrs	r1, r3, #8
	TxData[1] = (uint8_t) (data >> 16);
 8005244:	7054      	strb	r4, [r2, #1]
	TxData[3] = (uint8_t) (data >> 0);
 8005246:	70d0      	strb	r0, [r2, #3]
	TxData[6] = (uint8_t) (timestamp >> 8);
 8005248:	7191      	strb	r1, [r2, #6]
	TxData[7] = (uint8_t) (timestamp >> 0);
 800524a:	71d3      	strb	r3, [r2, #7]
	TxData[2] = (uint8_t) (data >> 8);
 800524c:	0a04      	lsrs	r4, r0, #8

	if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, TxData, &TxMailbox) != HAL_OK) {
 800524e:	4b0a      	ldr	r3, [pc, #40]	; (8005278 <setFrame+0x48>)
 8005250:	490a      	ldr	r1, [pc, #40]	; (800527c <setFrame+0x4c>)
 8005252:	480b      	ldr	r0, [pc, #44]	; (8005280 <setFrame+0x50>)
	TxData[2] = (uint8_t) (data >> 8);
 8005254:	7094      	strb	r4, [r2, #2]
	if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, TxData, &TxMailbox) != HAL_OK) {
 8005256:	f7fb faf8 	bl	800084a <HAL_CAN_AddTxMessage>
 800525a:	4602      	mov	r2, r0
 800525c:	b130      	cbz	r0, 800526c <setFrame+0x3c>
		// deal with it (never fails)
		led_set_rgb(50, 0, 0);
 800525e:	2200      	movs	r2, #0
 8005260:	4611      	mov	r1, r2
 8005262:	2032      	movs	r0, #50	; 0x32
	}
	else {
		led_set_rgb(0, 1000, 0);
	}
}
 8005264:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		led_set_rgb(0, 1000, 0);
 8005268:	f000 bd6c 	b.w	8005d44 <led_set_rgb>
 800526c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005270:	e7f8      	b.n	8005264 <setFrame+0x34>
 8005272:	bf00      	nop
 8005274:	20003f38 	.word	0x20003f38
 8005278:	20003f40 	.word	0x20003f40
 800527c:	20003f4c 	.word	0x20003f4c
 8005280:	20003fb0 	.word	0x20003fb0

08005284 <readFrame>:
 *
 * byte 0..3 --> some uint32_t
 * byte 4    --> data_id, see CAN_communication.h
 * byte 5..7 --> timestamp
 */
uint32_t readFrame(void) {
 8005284:	b570      	push	{r4, r5, r6, lr}
	uint32_t fill_level = HAL_CAN_GetRxFifoFillLevel(&hcan1, CAN_RX_FIFO0);
 8005286:	2100      	movs	r1, #0
 8005288:	4810      	ldr	r0, [pc, #64]	; (80052cc <readFrame+0x48>)
 800528a:	f7fb fbab 	bl	80009e4 <HAL_CAN_GetRxFifoFillLevel>
	if (fill_level > 0) {
 800528e:	4605      	mov	r5, r0
 8005290:	b1d0      	cbz	r0, 80052c8 <readFrame+0x44>
		HAL_CAN_GetRxMessage(&hcan1, CAN_RX_FIFO0, &RxHeader, RxData);
 8005292:	4c0f      	ldr	r4, [pc, #60]	; (80052d0 <readFrame+0x4c>)
 8005294:	4e0f      	ldr	r6, [pc, #60]	; (80052d4 <readFrame+0x50>)
 8005296:	480d      	ldr	r0, [pc, #52]	; (80052cc <readFrame+0x48>)
 8005298:	4623      	mov	r3, r4
 800529a:	4632      	mov	r2, r6
 800529c:	2100      	movs	r1, #0
 800529e:	f7fb fb23 	bl	80008e8 <HAL_CAN_GetRxMessage>
		memcpy(&current_msg.data, RxData, 4);
 80052a2:	4b0d      	ldr	r3, [pc, #52]	; (80052d8 <readFrame+0x54>)
 80052a4:	6822      	ldr	r2, [r4, #0]
 80052a6:	601a      	str	r2, [r3, #0]
		current_msg.id = RxData[4];
 80052a8:	7922      	ldrb	r2, [r4, #4]
 80052aa:	711a      	strb	r2, [r3, #4]
		//----------------------------------------------------------------------check if works
		uint8_t* ptr = (uint8_t*) &current_msg.timestamp;
		*ptr = 0;
		memcpy(&ptr[1], &RxData[5], 3);
 80052ac:	f834 2f05 	ldrh.w	r2, [r4, #5]!
 80052b0:	f8a3 2009 	strh.w	r2, [r3, #9]
 80052b4:	78a2      	ldrb	r2, [r4, #2]
 80052b6:	72da      	strb	r2, [r3, #11]
		*ptr = 0;
 80052b8:	2100      	movs	r1, #0
		//----------------------------------------------------------------------check if works
		current_msg.id_CAN = RxHeader.StdId;
 80052ba:	6832      	ldr	r2, [r6, #0]
 80052bc:	60da      	str	r2, [r3, #12]
		*ptr = 0;
 80052be:	7219      	strb	r1, [r3, #8]
		led_set_rgb(0, 0, 50);
 80052c0:	2232      	movs	r2, #50	; 0x32
 80052c2:	4608      	mov	r0, r1
 80052c4:	f000 fd3e 	bl	8005d44 <led_set_rgb>
	}
	return fill_level;
}
 80052c8:	4628      	mov	r0, r5
 80052ca:	bd70      	pop	{r4, r5, r6, pc}
 80052cc:	20003fb0 	.word	0x20003fb0
 80052d0:	20003f44 	.word	0x20003f44
 80052d4:	20003f64 	.word	0x20003f64
 80052d8:	20003f80 	.word	0x20003f80

080052dc <longBip>:
//  HAL_GPIO_WritePin (BUZZER_GPIO_Port, BUZZER_Pin, SET);
//  buzzerDelayMs = 300;
}

void longBip ()
{
 80052dc:	4770      	bx	lr
	...

080052e0 <TK_state_machine>:
volatile uint32_t currentBaroSeqNumber = 0;
volatile uint32_t currentBaroTimestamp = 0;
volatile uint32_t currentPitotSeqNumber = 0;

void TK_state_machine (void const * argument)
{
 80052e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80052e4:	ed2d 8b02 	vpush	{d8}

  osDelay (2000);
 80052e8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
{
 80052ec:	b0b9      	sub	sp, #228	; 0xe4
  osDelay (2000);
 80052ee:	f7fe fc98 	bl	8003c22 <osDelay>
  // TODO: Set low package data rate
  // TODO: Airbrakes HelloWorld

  // State Machine initialization
  // Hyp: rocket is on rail waiting for lift-off
  currentState = STATE_CALIBRATION;
 80052f2:	4eb3      	ldr	r6, [pc, #716]	; (80055c0 <TK_state_machine+0x2e0>)
  float32_t max_altitude = calib_initial_altitude;
 80052f4:	4bb3      	ldr	r3, [pc, #716]	; (80055c4 <TK_state_machine+0x2e4>)
  float32_t td_last_alt = 0;
 80052f6:	ed9f 8ab4 	vldr	s16, [pc, #720]	; 80055c8 <TK_state_machine+0x2e8>
  float32_t max_altitude = calib_initial_altitude;
 80052fa:	edd3 8a00 	vldr	s17, [r3]
 80052fe:	9300      	str	r3, [sp, #0]
  currentState = STATE_CALIBRATION;
 8005300:	2400      	movs	r4, #0
 8005302:	7034      	strb	r4, [r6, #0]
  uint32_t sec_counter = 0;
 8005304:	46a3      	mov	fp, r4
  uint32_t apogee_counter = 0;
 8005306:	46a2      	mov	sl, r4
  uint8_t calibDataCounter = 0;
 8005308:	46a0      	mov	r8, r4
  uint32_t lastImuSeqNumber = 0, lastBaroSeqNumber = 0;
 800530a:	9402      	str	r4, [sp, #8]
 800530c:	9401      	str	r4, [sp, #4]
  uint32_t time_tmp = 0;
 800530e:	4625      	mov	r5, r4

  // State Machine main task loop
  for (;;)
    {
      // Check state at max period where sensors are updated
      osDelay (8);
 8005310:	2008      	movs	r0, #8
 8005312:	f7fe fc86 	bl	8003c22 <osDelay>

      // if new imu data is available
      if (currentImuSeqNumber > lastImuSeqNumber)
 8005316:	4bad      	ldr	r3, [pc, #692]	; (80055cc <TK_state_machine+0x2ec>)
 8005318:	9a01      	ldr	r2, [sp, #4]
 800531a:	681b      	ldr	r3, [r3, #0]
 800531c:	429a      	cmp	r2, r3
 800531e:	d241      	bcs.n	80053a4 <TK_state_machine+0xc4>
extern IMU_data IMU_buffer[];
extern BARO_data BARO_buffer[];

static inline IMU_data* getCurrentIMU_data ()
{
  return &IMU_buffer[currentImuSeqNumber % CIRC_BUFFER_SIZE];
 8005320:	4baa      	ldr	r3, [pc, #680]	; (80055cc <TK_state_machine+0x2ec>)
 8005322:	49ab      	ldr	r1, [pc, #684]	; (80055d0 <TK_state_machine+0x2f0>)
 8005324:	681b      	ldr	r3, [r3, #0]
 8005326:	2228      	movs	r2, #40	; 0x28
 8005328:	f003 0307 	and.w	r3, r3, #7
 800532c:	fb02 1303 	mla	r3, r2, r3, r1
 8005330:	9303      	str	r3, [sp, #12]
        {
          // Update accelerometer reading
          imu_data = getCurrentIMU_data ();
          lastImuSeqNumber = currentImuSeqNumber;
 8005332:	4ba6      	ldr	r3, [pc, #664]	; (80055cc <TK_state_machine+0x2ec>)
 8005334:	681b      	ldr	r3, [r3, #0]
 8005336:	9301      	str	r3, [sp, #4]
          imuIsReady = 1; // set new data flag to true
 8005338:	2101      	movs	r1, #1
        {
          imuIsReady = 0; // set new data flag to false
        }

      // if new barometer data is available
      if (currentBaroSeqNumber > lastBaroSeqNumber)
 800533a:	4ba6      	ldr	r3, [pc, #664]	; (80055d4 <TK_state_machine+0x2f4>)
 800533c:	9802      	ldr	r0, [sp, #8]
 800533e:	681a      	ldr	r2, [r3, #0]
 8005340:	4290      	cmp	r0, r2
 8005342:	d231      	bcs.n	80053a8 <TK_state_machine+0xc8>
}

static inline BARO_data* getCurrentBARO_data ()
{
  return &BARO_buffer[currentBaroSeqNumber % CIRC_BUFFER_SIZE];
 8005344:	681f      	ldr	r7, [r3, #0]
 8005346:	4aa4      	ldr	r2, [pc, #656]	; (80055d8 <TK_state_machine+0x2f8>)
        {
          // Update barometer reading
          baro_data = getCurrentBARO_data ();
          lastBaroSeqNumber = currentBaroSeqNumber;
 8005348:	681b      	ldr	r3, [r3, #0]
 800534a:	9302      	str	r3, [sp, #8]
 800534c:	f007 0707 	and.w	r7, r7, #7
 8005350:	200c      	movs	r0, #12
 8005352:	fb00 2707 	mla	r7, r0, r7, r2
          baroIsReady = 1; // set new data flag to true
 8005356:	f04f 0901 	mov.w	r9, #1
      else
        {
          baroIsReady = 0; // set new data flag to false
        }

      if (LIFTOFF_TIME != 0 && (HAL_GetTick() - LIFTOFF_TIME) > 4 * 60 * 1000) {
 800535a:	4aa0      	ldr	r2, [pc, #640]	; (80055dc <TK_state_machine+0x2fc>)
 800535c:	6810      	ldr	r0, [r2, #0]
 800535e:	b168      	cbz	r0, 800537c <TK_state_machine+0x9c>
 8005360:	9205      	str	r2, [sp, #20]
 8005362:	9104      	str	r1, [sp, #16]
 8005364:	f7fb f926 	bl	80005b4 <HAL_GetTick>
 8005368:	9a05      	ldr	r2, [sp, #20]
 800536a:	9904      	ldr	r1, [sp, #16]
 800536c:	6812      	ldr	r2, [r2, #0]
 800536e:	1a80      	subs	r0, r0, r2
 8005370:	4a9b      	ldr	r2, [pc, #620]	; (80055e0 <TK_state_machine+0x300>)
 8005372:	4290      	cmp	r0, r2
          currentState = STATE_TOUCHDOWN;
 8005374:	bf82      	ittt	hi
 8005376:	4b92      	ldrhi	r3, [pc, #584]	; (80055c0 <TK_state_machine+0x2e0>)
 8005378:	2206      	movhi	r2, #6
 800537a:	701a      	strbhi	r2, [r3, #0]
      }

      // State Machine
      switch (currentState)
 800537c:	4b90      	ldr	r3, [pc, #576]	; (80055c0 <TK_state_machine+0x2e0>)
 800537e:	781a      	ldrb	r2, [r3, #0]
 8005380:	2a06      	cmp	r2, #6
 8005382:	d8c5      	bhi.n	8005310 <TK_state_machine+0x30>
 8005384:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005388:	00380013 	.word	0x00380013
 800538c:	007b006e 	.word	0x007b006e
 8005390:	00e000b1 	.word	0x00e000b1
 8005394:	010a      	.short	0x010a

                // update the minimum altitude detected up to this point
                if ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_REC_SECONDARY_ALT)
                  {
                    // As long as the measured altitude is above the secondary recovery event altitude, keep buffer counter to 0
                    sec_counter = 0;
 8005396:	f04f 0b00 	mov.w	fp, #0
 800539a:	e7b9      	b.n	8005310 <TK_state_machine+0x30>
                          {
                            // if the counter is larger than a given value, toggle the state trigger
                            counterTdTrig = 1;
                          }
                      }
                    td_last_alt = baro_data->altitude;
 800539c:	eeb0 8a67 	vmov.f32	s16, s15
                        td_counter = 0;
 80053a0:	2400      	movs	r4, #0
 80053a2:	e7b5      	b.n	8005310 <TK_state_machine+0x30>
          imuIsReady = 0; // set new data flag to false
 80053a4:	2100      	movs	r1, #0
 80053a6:	e7c8      	b.n	800533a <TK_state_machine+0x5a>
          baroIsReady = 0; // set new data flag to false
 80053a8:	f04f 0900 	mov.w	r9, #0
 80053ac:	e7d5      	b.n	800535a <TK_state_machine+0x7a>
            if (baroIsReady)
 80053ae:	f1b9 0f00 	cmp.w	r9, #0
 80053b2:	d0ad      	beq.n	8005310 <TK_state_machine+0x30>
                if (calibDataCounter > CALIB_BARO_BUFFER_SIZE)
 80053b4:	f1b8 0f32 	cmp.w	r8, #50	; 0x32
 80053b8:	d913      	bls.n	80053e2 <TK_state_machine+0x102>
 80053ba:	eddf 7a83 	vldr	s15, [pc, #524]	; 80055c8 <TK_state_machine+0x2e8>
 80053be:	ab06      	add	r3, sp, #24
 80053c0:	aa38      	add	r2, sp, #224	; 0xe0
  uint8_t i;
  float32_t sum = 0.0;

  for(i = 0 ; i < arraySize ; i++)
    {
      sum += array[i];
 80053c2:	ecb3 7a01 	vldmia	r3!, {s14}
  for(i = 0 ; i < arraySize ; i++)
 80053c6:	429a      	cmp	r2, r3
      sum += array[i];
 80053c8:	ee77 7a87 	vadd.f32	s15, s15, s14
  for(i = 0 ; i < arraySize ; i++)
 80053cc:	d1f9      	bne.n	80053c2 <TK_state_machine+0xe2>
    }

  return sum/arraySize;
 80053ce:	eddf 6a85 	vldr	s13, [pc, #532]	; 80055e4 <TK_state_machine+0x304>
                    calib_initial_altitude = array_mean (calibData, CALIB_BARO_BUFFER_SIZE);
 80053d2:	9b00      	ldr	r3, [sp, #0]
 80053d4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 80053d8:	ed83 7a00 	vstr	s14, [r3]
                    currentState = STATE_IDLE;
 80053dc:	2301      	movs	r3, #1
                currentState = STATE_COAST; // switch to coast state
 80053de:	7033      	strb	r3, [r6, #0]
 80053e0:	e796      	b.n	8005310 <TK_state_machine+0x30>
                    calibData[calibDataCounter++] = baro_data->altitude;
 80053e2:	aa38      	add	r2, sp, #224	; 0xe0
 80053e4:	f108 0301 	add.w	r3, r8, #1
 80053e8:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 80053ec:	68ba      	ldr	r2, [r7, #8]
 80053ee:	f848 2cc8 	str.w	r2, [r8, #-200]
 80053f2:	fa5f f883 	uxtb.w	r8, r3
 80053f6:	e78b      	b.n	8005310 <TK_state_machine+0x30>
            if (imuIsReady)
 80053f8:	2900      	cmp	r1, #0
 80053fa:	d089      	beq.n	8005310 <TK_state_machine+0x30>
                uint8_t liftoffAccelTrig = (abs_fl32 (imu_data->acceleration.y) > ROCKET_CST_LIFTOFF_TRIG_ACCEL);
 80053fc:	9b03      	ldr	r3, [sp, #12]
                if (LIFTOFF_TIME != 0)
 80053fe:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 80055dc <TK_state_machine+0x2fc>
                uint8_t liftoffAccelTrig = (abs_fl32 (imu_data->acceleration.y) > ROCKET_CST_LIFTOFF_TRIG_ACCEL);
 8005402:	edd3 7a01 	vldr	s15, [r3, #4]
                if (LIFTOFF_TIME != 0)
 8005406:	f8d9 2000 	ldr.w	r2, [r9]
  return (v >= 0) ? v : -v;
 800540a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800540e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005412:	bfb8      	it	lt
 8005414:	eef1 7a67 	vneglt.f32	s15, s15
 8005418:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
                    if (liftoffAccelTrig && HAL_GetTick () - LIFTOFF_TIME > LIFTOFF_DETECTION_DELAY)
 800541c:	eef4 7ac7 	vcmpe.f32	s15, s14
                if (LIFTOFF_TIME != 0)
 8005420:	b1a2      	cbz	r2, 800544c <TK_state_machine+0x16c>
                    if (liftoffAccelTrig && HAL_GetTick () - LIFTOFF_TIME > LIFTOFF_DETECTION_DELAY)
 8005422:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005426:	dd0d      	ble.n	8005444 <TK_state_machine+0x164>
 8005428:	f7fb f8c4 	bl	80005b4 <HAL_GetTick>
 800542c:	f8d9 3000 	ldr.w	r3, [r9]
 8005430:	1ac0      	subs	r0, r0, r3
 8005432:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
 8005436:	f67f af6b 	bls.w	8005310 <TK_state_machine+0x30>
                        currentState = STATE_LIFTOFF; // Switch to lift-off state
 800543a:	2302      	movs	r3, #2
 800543c:	7033      	strb	r3, [r6, #0]
                        longBip();
 800543e:	f7ff ff4d 	bl	80052dc <longBip>
                        break;
 8005442:	e765      	b.n	8005310 <TK_state_machine+0x30>
                        LIFTOFF_TIME = 0;
 8005444:	2500      	movs	r5, #0
 8005446:	f8c9 5000 	str.w	r5, [r9]
 800544a:	e761      	b.n	8005310 <TK_state_machine+0x30>
                if (liftoffAccelTrig)
 800544c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005450:	f77f af5e 	ble.w	8005310 <TK_state_machine+0x30>
                    LIFTOFF_TIME = HAL_GetTick ();
 8005454:	f7fb f8ae 	bl	80005b4 <HAL_GetTick>
 8005458:	f8c9 0000 	str.w	r0, [r9]
                    time_tmp = HAL_GetTick (); // Start timer to estimate motor burn out
 800545c:	f7fb f8aa 	bl	80005b4 <HAL_GetTick>
 8005460:	4605      	mov	r5, r0
 8005462:	e755      	b.n	8005310 <TK_state_machine+0x30>
            flight_status = 10;
 8005464:	4b60      	ldr	r3, [pc, #384]	; (80055e8 <TK_state_machine+0x308>)
 8005466:	220a      	movs	r2, #10
 8005468:	601a      	str	r2, [r3, #0]
            uint32_t currentTime = HAL_GetTick ();
 800546a:	f7fb f8a3 	bl	80005b4 <HAL_GetTick>
            if ((currentTime - time_tmp) > ROCKET_CST_MOTOR_BURNTIME)
 800546e:	f641 1364 	movw	r3, #6500	; 0x1964
 8005472:	1b40      	subs	r0, r0, r5
 8005474:	4298      	cmp	r0, r3
 8005476:	f67f af4b 	bls.w	8005310 <TK_state_machine+0x30>
                currentState = STATE_COAST; // switch to coast state
 800547a:	2303      	movs	r3, #3
 800547c:	e7af      	b.n	80053de <TK_state_machine+0xfe>
            flight_status = 20;
 800547e:	4a5a      	ldr	r2, [pc, #360]	; (80055e8 <TK_state_machine+0x308>)
 8005480:	2114      	movs	r1, #20
 8005482:	6011      	str	r1, [r2, #0]
            if (baroIsReady)
 8005484:	f1b9 0f00 	cmp.w	r9, #0
 8005488:	f43f af42 	beq.w	8005310 <TK_state_machine+0x30>
                uint8_t minAltTrig = ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_MIN_TRIG_AGL);
 800548c:	edd7 7a02 	vldr	s15, [r7, #8]
 8005490:	9b00      	ldr	r3, [sp, #0]
                if (max_altitude < baro_data->altitude)
 8005492:	eef4 8ae7 	vcmpe.f32	s17, s15
                uint8_t minAltTrig = ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_MIN_TRIG_AGL);
 8005496:	ed93 7a00 	vldr	s14, [r3]
                if (max_altitude < baro_data->altitude)
 800549a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                uint8_t minAltTrig = ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_MIN_TRIG_AGL);
 800549e:	ee37 7ac7 	vsub.f32	s14, s15, s14
                if (max_altitude < baro_data->altitude)
 80054a2:	f100 8088 	bmi.w	80055b6 <TK_state_machine+0x2d6>
                    apogee_counter++;
 80054a6:	f10a 0a01 	add.w	sl, sl, #1
                    if (apogee_counter > APOGEE_BUFFER_SIZE)
 80054aa:	f1ba 0f64 	cmp.w	sl, #100	; 0x64
 80054ae:	f67f af2f 	bls.w	8005310 <TK_state_machine+0x30>
                if (minAltTrig && counterAltTrig && diffAltTrig)
 80054b2:	eddf 6a4e 	vldr	s13, [pc, #312]	; 80055ec <TK_state_machine+0x30c>
 80054b6:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80054ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                        if (( max_altitude - baro_data->altitude) > APOGEE_ALT_DIFF)
 80054be:	ee78 7ae7 	vsub.f32	s15, s17, s15
                if (minAltTrig && counterAltTrig && diffAltTrig)
 80054c2:	f77f af25 	ble.w	8005310 <TK_state_machine+0x30>
 80054c6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80054ca:	eef4 7ac7 	vcmpe.f32	s15, s14
 80054ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80054d2:	f77f af1d 	ble.w	8005310 <TK_state_machine+0x30>
 80054d6:	9204      	str	r2, [sp, #16]
                    time_tmp = HAL_GetTick (); // save time to mute sensors while ejection occures
 80054d8:	f7fb f86c 	bl	80005b4 <HAL_GetTick>
                    currentState = STATE_PRIMARY; // switch to primary descent phase
 80054dc:	2304      	movs	r3, #4
                    flight_status = 30;
 80054de:	9a04      	ldr	r2, [sp, #16]
                    currentState = STATE_PRIMARY; // switch to primary descent phase
 80054e0:	7033      	strb	r3, [r6, #0]
                    flight_status = 30;
 80054e2:	231e      	movs	r3, #30
                    time_tmp = HAL_GetTick (); // save time to mute sensors while ejection occures
 80054e4:	4605      	mov	r5, r0
                    flight_status = 30;
 80054e6:	6013      	str	r3, [r2, #0]
 80054e8:	e712      	b.n	8005310 <TK_state_machine+0x30>
            longBip();
 80054ea:	f7ff fef7 	bl	80052dc <longBip>
            if (baroIsReady)
 80054ee:	f1b9 0f00 	cmp.w	r9, #0
 80054f2:	f43f af0d 	beq.w	8005310 <TK_state_machine+0x30>
                uint8_t sensorMuteTimeTrig = ((HAL_GetTick () - time_tmp) > APOGEE_MUTE_TIME);
 80054f6:	f7fb f85d 	bl	80005b4 <HAL_GetTick>
                if ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_REC_SECONDARY_ALT)
 80054fa:	9b00      	ldr	r3, [sp, #0]
 80054fc:	edd7 7a02 	vldr	s15, [r7, #8]
 8005500:	ed93 7a00 	vldr	s14, [r3]
 8005504:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8005508:	ed9f 7a39 	vldr	s14, [pc, #228]	; 80055f0 <TK_state_machine+0x310>
 800550c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8005510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                uint8_t sensorMuteTimeTrig = ((HAL_GetTick () - time_tmp) > APOGEE_MUTE_TIME);
 8005514:	eba0 0005 	sub.w	r0, r0, r5
                if ((baro_data->altitude - calib_initial_altitude) > ROCKET_CST_REC_SECONDARY_ALT)
 8005518:	f73f af3d 	bgt.w	8005396 <TK_state_machine+0xb6>
                    sec_counter++;
 800551c:	f10b 0b01 	add.w	fp, fp, #1
                    if (sec_counter > SECONDARY_BUFFER_SIZE)
 8005520:	f1bb 0f05 	cmp.w	fp, #5
 8005524:	f67f aef4 	bls.w	8005310 <TK_state_machine+0x30>
                if (sensorMuteTimeTrig && counterSecTrig)
 8005528:	f241 3388 	movw	r3, #5000	; 0x1388
 800552c:	4298      	cmp	r0, r3
 800552e:	f67f aeef 	bls.w	8005310 <TK_state_machine+0x30>
                    time_tmp = HAL_GetTick (); // save current time to start differed touchdown detection rate
 8005532:	f7fb f83f 	bl	80005b4 <HAL_GetTick>
                    currentState = STATE_SECONDARY; // switch to secondary recovery phase
 8005536:	2305      	movs	r3, #5
 8005538:	7033      	strb	r3, [r6, #0]
                    flight_status = 35;
 800553a:	4b2b      	ldr	r3, [pc, #172]	; (80055e8 <TK_state_machine+0x308>)
                    td_last_alt = baro_data->altitude; // save altitude measurement for touchdown detection
 800553c:	ed97 8a02 	vldr	s16, [r7, #8]
                    flight_status = 35;
 8005540:	2223      	movs	r2, #35	; 0x23
                    time_tmp = HAL_GetTick (); // save current time to start differed touchdown detection rate
 8005542:	4605      	mov	r5, r0
                    flight_status = 35;
 8005544:	601a      	str	r2, [r3, #0]
 8005546:	e6e3      	b.n	8005310 <TK_state_machine+0x30>
            longBip();
 8005548:	f7ff fec8 	bl	80052dc <longBip>
            if ((HAL_GetTick () - time_tmp) > TOUCHDOWN_DELAY_TIME)
 800554c:	f7fb f832 	bl	80005b4 <HAL_GetTick>
 8005550:	f241 3288 	movw	r2, #5000	; 0x1388
 8005554:	1b40      	subs	r0, r0, r5
 8005556:	4290      	cmp	r0, r2
 8005558:	f67f aeda 	bls.w	8005310 <TK_state_machine+0x30>
                if (baroIsReady)
 800555c:	f1b9 0f00 	cmp.w	r9, #0
 8005560:	f43f aed6 	beq.w	8005310 <TK_state_machine+0x30>
                    time_tmp = HAL_GetTick ();
 8005564:	f7fb f826 	bl	80005b4 <HAL_GetTick>
                    if (abs_fl32 (baro_data->altitude - td_last_alt) > TOUCHDOWN_ALT_DIFF)
 8005568:	edd7 7a02 	vldr	s15, [r7, #8]
 800556c:	ee37 8ac8 	vsub.f32	s16, s15, s16
 8005570:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8005574:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8005578:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800557c:	bfb8      	it	lt
 800557e:	eeb1 8a48 	vneglt.f32	s16, s16
 8005582:	eeb4 8ac7 	vcmpe.f32	s16, s14
 8005586:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    time_tmp = HAL_GetTick ();
 800558a:	4605      	mov	r5, r0
                    if (abs_fl32 (baro_data->altitude - td_last_alt) > TOUCHDOWN_ALT_DIFF)
 800558c:	f73f af06 	bgt.w	800539c <TK_state_machine+0xbc>
                        td_counter++;
 8005590:	3401      	adds	r4, #1
                        if (td_counter > TOUCHDOWN_BUFFER_SIZE)
 8005592:	2c05      	cmp	r4, #5
 8005594:	d809      	bhi.n	80055aa <TK_state_machine+0x2ca>
                    td_last_alt = baro_data->altitude;
 8005596:	eeb0 8a67 	vmov.f32	s16, s15
 800559a:	e6b9      	b.n	8005310 <TK_state_machine+0x30>

        case STATE_TOUCHDOWN:
          {

            for(;;) {
                longBip();
 800559c:	f7ff fe9e 	bl	80052dc <longBip>
                osDelay(2000);
 80055a0:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80055a4:	f7fe fb3d 	bl	8003c22 <osDelay>
 80055a8:	e7f8      	b.n	800559c <TK_state_machine+0x2bc>
                        currentState = STATE_TOUCHDOWN;
 80055aa:	2306      	movs	r3, #6
 80055ac:	7033      	strb	r3, [r6, #0]
                        flight_status = 40;
 80055ae:	4b0e      	ldr	r3, [pc, #56]	; (80055e8 <TK_state_machine+0x308>)
 80055b0:	2228      	movs	r2, #40	; 0x28
 80055b2:	601a      	str	r2, [r3, #0]
 80055b4:	e7ef      	b.n	8005596 <TK_state_machine+0x2b6>
                    max_altitude = baro_data->altitude;
 80055b6:	eef0 8a67 	vmov.f32	s17, s15
                    apogee_counter = 0;
 80055ba:	f04f 0a00 	mov.w	sl, #0
 80055be:	e6a7      	b.n	8005310 <TK_state_machine+0x30>
 80055c0:	20003f94 	.word	0x20003f94
 80055c4:	20003fac 	.word	0x20003fac
 80055c8:	00000000 	.word	0x00000000
 80055cc:	20003f2c 	.word	0x20003f2c
 80055d0:	20000014 	.word	0x20000014
 80055d4:	20003f28 	.word	0x20003f28
 80055d8:	20000154 	.word	0x20000154
 80055dc:	20003f98 	.word	0x20003f98
 80055e0:	0003a980 	.word	0x0003a980
 80055e4:	42480000 	.word	0x42480000
 80055e8:	20003fa4 	.word	0x20003fa4
 80055ec:	44a28000 	.word	0x44a28000
 80055f0:	43480000 	.word	0x43480000

080055f4 <LL_AHB1_GRP1_EnableClock>:
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 80055f4:	4b05      	ldr	r3, [pc, #20]	; (800560c <LL_AHB1_GRP1_EnableClock+0x18>)
 80055f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80055f8:	4302      	orrs	r2, r0
 80055fa:	631a      	str	r2, [r3, #48]	; 0x30
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80055fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
{
 80055fe:	b082      	sub	sp, #8
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8005600:	4018      	ands	r0, r3
 8005602:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 8005604:	9b01      	ldr	r3, [sp, #4]
}
 8005606:	b002      	add	sp, #8
 8005608:	4770      	bx	lr
 800560a:	bf00      	nop
 800560c:	40023800 	.word	0x40023800

08005610 <LL_ADC_SetChannelSamplingTime.constprop.0>:
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
 8005610:	b510      	push	{r4, lr}
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005612:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8005616:	fa93 f3a3 	rbit	r3, r3
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPRX_REGOFFSET_MASK));
 800561a:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
 800561e:	fab3 f383 	clz	r3, r3
 8005622:	fa22 f303 	lsr.w	r3, r2, r3
 8005626:	300c      	adds	r0, #12
 8005628:	f04f 74f8 	mov.w	r4, #32505856	; 0x1f00000
 800562c:	fa94 f2a4 	rbit	r2, r4
  MODIFY_REG(*preg,
 8005630:	fab2 f282 	clz	r2, r2
 8005634:	fa94 f4a4 	rbit	r4, r4
 8005638:	f001 71f8 	and.w	r1, r1, #32505856	; 0x1f00000
 800563c:	40d1      	lsrs	r1, r2
 800563e:	2207      	movs	r2, #7
 8005640:	fa02 f101 	lsl.w	r1, r2, r1
 8005644:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
 8005648:	ea22 0201 	bic.w	r2, r2, r1
 800564c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8005650:	bd10      	pop	{r4, pc}
	...

08005654 <MX_ADC1_Init>:

/* USER CODE END 0 */

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8005654:	b570      	push	{r4, r5, r6, lr}
  LL_ADC_InitTypeDef ADC_InitStruct = {0};
 8005656:	2400      	movs	r4, #0
{
 8005658:	b094      	sub	sp, #80	; 0x50
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 800565a:	4621      	mov	r1, r4
  LL_ADC_CommonInitTypeDef ADC_CommonInitStruct = {0};
 800565c:	2610      	movs	r6, #16
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 800565e:	2214      	movs	r2, #20
 8005660:	a809      	add	r0, sp, #36	; 0x24
  LL_ADC_InitTypeDef ADC_InitStruct = {0};
 8005662:	9402      	str	r4, [sp, #8]
 8005664:	9403      	str	r4, [sp, #12]
 8005666:	9404      	str	r4, [sp, #16]
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 8005668:	f001 fc29 	bl	8006ebe <memset>
  LL_ADC_CommonInitTypeDef ADC_CommonInitStruct = {0};
 800566c:	4632      	mov	r2, r6
 800566e:	4621      	mov	r1, r4
 8005670:	a805      	add	r0, sp, #20
 8005672:	f001 fc24 	bl	8006ebe <memset>

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005676:	4621      	mov	r1, r4
 8005678:	2218      	movs	r2, #24
 800567a:	a80e      	add	r0, sp, #56	; 0x38
 800567c:	f001 fc1f 	bl	8006ebe <memset>
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8005680:	4b2c      	ldr	r3, [pc, #176]	; (8005734 <MX_ADC1_Init+0xe0>)
 8005682:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005684:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005688:	645a      	str	r2, [r3, #68]	; 0x44
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800568a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800568c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005690:	9301      	str	r3, [sp, #4]
  /* Peripheral clock enable */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_ADC1);
  
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 8005692:	2001      	movs	r0, #1
  (void)tmpreg;
 8005694:	9b01      	ldr	r3, [sp, #4]
 8005696:	f7ff ffad 	bl	80055f4 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
 800569a:	2004      	movs	r0, #4
 800569c:	f7ff ffaa 	bl	80055f4 <LL_AHB1_GRP1_EnableClock>
  PA2   ------> ADC1_IN2
  PA3   ------> ADC1_IN3
  PC4   ------> ADC1_IN14 
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 80056a0:	2503      	movs	r5, #3
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
 80056a2:	230c      	movs	r3, #12
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80056a4:	a90e      	add	r1, sp, #56	; 0x38
 80056a6:	4824      	ldr	r0, [pc, #144]	; (8005738 <MX_ADC1_Init+0xe4>)
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
 80056a8:	930e      	str	r3, [sp, #56]	; 0x38
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 80056aa:	950f      	str	r5, [sp, #60]	; 0x3c
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 80056ac:	9412      	str	r4, [sp, #72]	; 0x48
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80056ae:	f7fd fd37 	bl	8003120 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_4;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 80056b2:	950f      	str	r5, [sp, #60]	; 0x3c
  /**Common config 
  */
  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
  ADC_InitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_DISABLE;
  LL_ADC_Init(ADC1, &ADC_InitStruct);
 80056b4:	4d21      	ldr	r5, [pc, #132]	; (800573c <MX_ADC1_Init+0xe8>)
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80056b6:	4822      	ldr	r0, [pc, #136]	; (8005740 <MX_ADC1_Init+0xec>)
  GPIO_InitStruct.Pin = LL_GPIO_PIN_4;
 80056b8:	960e      	str	r6, [sp, #56]	; 0x38
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80056ba:	a90e      	add	r1, sp, #56	; 0x38
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 80056bc:	9412      	str	r4, [sp, #72]	; 0x48
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80056be:	f7fd fd2f 	bl	8003120 <LL_GPIO_Init>
  LL_ADC_Init(ADC1, &ADC_InitStruct);
 80056c2:	a902      	add	r1, sp, #8
 80056c4:	4628      	mov	r0, r5
  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
 80056c6:	9402      	str	r4, [sp, #8]
  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
 80056c8:	9403      	str	r4, [sp, #12]
  ADC_InitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_DISABLE;
 80056ca:	9404      	str	r4, [sp, #16]
  LL_ADC_Init(ADC1, &ADC_InitStruct);
 80056cc:	f7fd fcec 	bl	80030a8 <LL_ADC_Init>
  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_LIMITED;
 80056d0:	f44f 7380 	mov.w	r3, #256	; 0x100
  LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);
 80056d4:	a909      	add	r1, sp, #36	; 0x24
 80056d6:	4628      	mov	r0, r5
  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_LIMITED;
 80056d8:	930d      	str	r3, [sp, #52]	; 0x34
  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
 80056da:	9409      	str	r4, [sp, #36]	; 0x24
  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
 80056dc:	940a      	str	r4, [sp, #40]	; 0x28
  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
 80056de:	940b      	str	r4, [sp, #44]	; 0x2c
  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
 80056e0:	940c      	str	r4, [sp, #48]	; 0x30
  LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);
 80056e2:	f7fd fcf9 	bl	80030d8 <LL_ADC_REG_Init>
  MODIFY_REG(ADCx->CR2, ADC_CR2_EOCS, EocSelection);
 80056e6:	68ab      	ldr	r3, [r5, #8]
  LL_ADC_REG_SetFlagEndOfConversion(ADC1, LL_ADC_REG_FLAG_EOC_UNITARY_CONV);
  LL_ADC_DisableIT_EOCS(ADC1);
  ADC_CommonInitStruct.CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
  ADC_CommonInitStruct.Multimode = LL_ADC_MULTI_INDEPENDENT;
  LL_ADC_CommonInit(__LL_ADC_COMMON_INSTANCE(ADC1), &ADC_CommonInitStruct);
 80056e8:	4816      	ldr	r0, [pc, #88]	; (8005744 <MX_ADC1_Init+0xf0>)
 80056ea:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80056ee:	60ab      	str	r3, [r5, #8]
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOCS(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->CR1, LL_ADC_IT_EOCS);
 80056f0:	686b      	ldr	r3, [r5, #4]
 80056f2:	f023 0320 	bic.w	r3, r3, #32
 80056f6:	606b      	str	r3, [r5, #4]
 80056f8:	a905      	add	r1, sp, #20
  ADC_CommonInitStruct.CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
 80056fa:	9405      	str	r4, [sp, #20]
  ADC_CommonInitStruct.Multimode = LL_ADC_MULTI_INDEPENDENT;
 80056fc:	9406      	str	r4, [sp, #24]
  LL_ADC_CommonInit(__LL_ADC_COMMON_INSTANCE(ADC1), &ADC_CommonInitStruct);
 80056fe:	f7fd fcaf 	bl	8003060 <LL_ADC_CommonInit>
 8005702:	f44f 7340 	mov.w	r3, #768	; 0x300
 8005706:	fa93 f3a3 	rbit	r3, r3
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
 800570a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800570e:	fab3 f383 	clz	r3, r3
 8005712:	40da      	lsrs	r2, r3
 8005714:	490c      	ldr	r1, [pc, #48]	; (8005748 <MX_ADC1_Init+0xf4>)
  MODIFY_REG(*preg,
 8005716:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 800571a:	f023 031f 	bic.w	r3, r3, #31
 800571e:	f043 0302 	orr.w	r3, r3, #2
 8005722:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  /**Configure Regular Channel 
  */
  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_2);
  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_2, LL_ADC_SAMPLINGTIME_3CYCLES);
 8005726:	4628      	mov	r0, r5
 8005728:	4908      	ldr	r1, [pc, #32]	; (800574c <MX_ADC1_Init+0xf8>)
 800572a:	f7ff ff71 	bl	8005610 <LL_ADC_SetChannelSamplingTime.constprop.0>

}
 800572e:	b014      	add	sp, #80	; 0x50
 8005730:	bd70      	pop	{r4, r5, r6, pc}
 8005732:	bf00      	nop
 8005734:	40023800 	.word	0x40023800
 8005738:	40020000 	.word	0x40020000
 800573c:	40012000 	.word	0x40012000
 8005740:	40020800 	.word	0x40020800
 8005744:	40012300 	.word	0x40012300
 8005748:	4001202c 	.word	0x4001202c
 800574c:	02600002 	.word	0x02600002

08005750 <MX_ADC2_Init>:
/* ADC2 init function */
void MX_ADC2_Init(void)
{
 8005750:	b530      	push	{r4, r5, lr}
  LL_ADC_InitTypeDef ADC_InitStruct = {0};
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 8005752:	2214      	movs	r2, #20
{
 8005754:	b091      	sub	sp, #68	; 0x44
  LL_ADC_InitTypeDef ADC_InitStruct = {0};
 8005756:	2400      	movs	r4, #0
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 8005758:	4621      	mov	r1, r4
 800575a:	eb0d 0002 	add.w	r0, sp, r2
  LL_ADC_InitTypeDef ADC_InitStruct = {0};
 800575e:	9402      	str	r4, [sp, #8]
 8005760:	9403      	str	r4, [sp, #12]
 8005762:	9404      	str	r4, [sp, #16]
  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
 8005764:	f001 fbab 	bl	8006ebe <memset>

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005768:	4621      	mov	r1, r4
 800576a:	2218      	movs	r2, #24
 800576c:	a80a      	add	r0, sp, #40	; 0x28
 800576e:	f001 fba6 	bl	8006ebe <memset>
  SET_BIT(RCC->APB2ENR, Periphs);
 8005772:	4b29      	ldr	r3, [pc, #164]	; (8005818 <MX_ADC2_Init+0xc8>)
 8005774:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005776:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800577a:	645a      	str	r2, [r3, #68]	; 0x44
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800577c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800577e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8005782:	9301      	str	r3, [sp, #4]
  /* Peripheral clock enable */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_ADC2);
  
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
 8005784:	2004      	movs	r0, #4
  (void)tmpreg;
 8005786:	9b01      	ldr	r3, [sp, #4]
 8005788:	f7ff ff34 	bl	80055f4 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 800578c:	2001      	movs	r0, #1
 800578e:	f7ff ff31 	bl	80055f4 <LL_AHB1_GRP1_EnableClock>
  PC0   ------> ADC2_IN10
  PC1   ------> ADC2_IN11
  PA4   ------> ADC2_IN4
  PA5   ------> ADC2_IN5 
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_1;
 8005792:	2503      	movs	r5, #3
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005794:	a90a      	add	r1, sp, #40	; 0x28
 8005796:	4821      	ldr	r0, [pc, #132]	; (800581c <MX_ADC2_Init+0xcc>)
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_1;
 8005798:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 800579a:	950b      	str	r5, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800579c:	940e      	str	r4, [sp, #56]	; 0x38
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800579e:	f7fd fcbf 	bl	8003120 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_4|LL_GPIO_PIN_5;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 80057a2:	950b      	str	r5, [sp, #44]	; 0x2c
  /**Common config 
  */
  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
  ADC_InitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_DISABLE;
  LL_ADC_Init(ADC2, &ADC_InitStruct);
 80057a4:	4d1e      	ldr	r5, [pc, #120]	; (8005820 <MX_ADC2_Init+0xd0>)
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80057a6:	481f      	ldr	r0, [pc, #124]	; (8005824 <MX_ADC2_Init+0xd4>)
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 80057a8:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = LL_GPIO_PIN_4|LL_GPIO_PIN_5;
 80057aa:	2330      	movs	r3, #48	; 0x30
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80057ac:	a90a      	add	r1, sp, #40	; 0x28
  GPIO_InitStruct.Pin = LL_GPIO_PIN_4|LL_GPIO_PIN_5;
 80057ae:	930a      	str	r3, [sp, #40]	; 0x28
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80057b0:	f7fd fcb6 	bl	8003120 <LL_GPIO_Init>
  LL_ADC_Init(ADC2, &ADC_InitStruct);
 80057b4:	a902      	add	r1, sp, #8
 80057b6:	4628      	mov	r0, r5
  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
 80057b8:	9402      	str	r4, [sp, #8]
  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
 80057ba:	9403      	str	r4, [sp, #12]
  ADC_InitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_DISABLE;
 80057bc:	9404      	str	r4, [sp, #16]
  LL_ADC_Init(ADC2, &ADC_InitStruct);
 80057be:	f7fd fc73 	bl	80030a8 <LL_ADC_Init>
  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_LIMITED;
 80057c2:	f44f 7380 	mov.w	r3, #256	; 0x100
  LL_ADC_REG_Init(ADC2, &ADC_REG_InitStruct);
 80057c6:	a905      	add	r1, sp, #20
 80057c8:	4628      	mov	r0, r5
  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_LIMITED;
 80057ca:	9309      	str	r3, [sp, #36]	; 0x24
  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
 80057cc:	9405      	str	r4, [sp, #20]
  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
 80057ce:	9406      	str	r4, [sp, #24]
  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
 80057d0:	9407      	str	r4, [sp, #28]
  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
 80057d2:	9408      	str	r4, [sp, #32]
  LL_ADC_REG_Init(ADC2, &ADC_REG_InitStruct);
 80057d4:	f7fd fc80 	bl	80030d8 <LL_ADC_REG_Init>
  MODIFY_REG(ADCx->CR2, ADC_CR2_EOCS, EocSelection);
 80057d8:	68ab      	ldr	r3, [r5, #8]
 80057da:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80057de:	60ab      	str	r3, [r5, #8]
  CLEAR_BIT(ADCx->CR1, LL_ADC_IT_EOCS);
 80057e0:	686b      	ldr	r3, [r5, #4]
 80057e2:	f023 0320 	bic.w	r3, r3, #32
 80057e6:	606b      	str	r3, [r5, #4]
 80057e8:	f44f 7340 	mov.w	r3, #768	; 0x300
 80057ec:	fa93 f3a3 	rbit	r3, r3
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
 80057f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80057f4:	fab3 f383 	clz	r3, r3
 80057f8:	40da      	lsrs	r2, r3
 80057fa:	490b      	ldr	r1, [pc, #44]	; (8005828 <MX_ADC2_Init+0xd8>)
  MODIFY_REG(*preg,
 80057fc:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 8005800:	f023 031f 	bic.w	r3, r3, #31
 8005804:	f043 0304 	orr.w	r3, r3, #4
 8005808:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  LL_ADC_REG_SetFlagEndOfConversion(ADC2, LL_ADC_REG_FLAG_EOC_UNITARY_CONV);
  LL_ADC_DisableIT_EOCS(ADC2);
  /**Configure Regular Channel 
  */
  LL_ADC_REG_SetSequencerRanks(ADC2, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_4);
  LL_ADC_SetChannelSamplingTime(ADC2, LL_ADC_CHANNEL_4, LL_ADC_SAMPLINGTIME_3CYCLES);
 800580c:	4628      	mov	r0, r5
 800580e:	4907      	ldr	r1, [pc, #28]	; (800582c <MX_ADC2_Init+0xdc>)
 8005810:	f7ff fefe 	bl	8005610 <LL_ADC_SetChannelSamplingTime.constprop.0>

}
 8005814:	b011      	add	sp, #68	; 0x44
 8005816:	bd30      	pop	{r4, r5, pc}
 8005818:	40023800 	.word	0x40023800
 800581c:	40020800 	.word	0x40020800
 8005820:	40012100 	.word	0x40012100
 8005824:	40020000 	.word	0x40020000
 8005828:	4001212c 	.word	0x4001212c
 800582c:	02c00004 	.word	0x02c00004

08005830 <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 8005830:	b507      	push	{r0, r1, r2, lr}
 * @param  None
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 8005832:	2001      	movs	r0, #1
 8005834:	f88d 0007 	strb.w	r0, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8005838:	f89d 3007 	ldrb.w	r3, [sp, #7]
  if (BSP_SD_IsDetected() != SD_PRESENT)
 800583c:	4283      	cmp	r3, r0
 800583e:	d10b      	bne.n	8005858 <BSP_SD_Init+0x28>
  sd_state = HAL_SD_Init(&hsd);
 8005840:	4807      	ldr	r0, [pc, #28]	; (8005860 <BSP_SD_Init+0x30>)
 8005842:	f7fc fcb3 	bl	80021ac <HAL_SD_Init>
  if (sd_state == MSD_OK)
 8005846:	b938      	cbnz	r0, 8005858 <BSP_SD_Init+0x28>
    if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) != HAL_OK)
 8005848:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800584c:	4804      	ldr	r0, [pc, #16]	; (8005860 <BSP_SD_Init+0x30>)
 800584e:	f7fc fcd9 	bl	8002204 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR;
 8005852:	3000      	adds	r0, #0
 8005854:	bf18      	it	ne
 8005856:	2001      	movne	r0, #1
}
 8005858:	b003      	add	sp, #12
 800585a:	f85d fb04 	ldr.w	pc, [sp], #4
 800585e:	bf00      	nop
 8005860:	20004610 	.word	0x20004610

08005864 <BSP_SD_ReadBlocks_DMA>:
{
 8005864:	b508      	push	{r3, lr}
  if (HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 8005866:	4613      	mov	r3, r2
 8005868:	460a      	mov	r2, r1
 800586a:	4601      	mov	r1, r0
 800586c:	4803      	ldr	r0, [pc, #12]	; (800587c <BSP_SD_ReadBlocks_DMA+0x18>)
 800586e:	f7fc f9ab 	bl	8001bc8 <HAL_SD_ReadBlocks_DMA>
}
 8005872:	3000      	adds	r0, #0
 8005874:	bf18      	it	ne
 8005876:	2001      	movne	r0, #1
 8005878:	bd08      	pop	{r3, pc}
 800587a:	bf00      	nop
 800587c:	20004610 	.word	0x20004610

08005880 <BSP_SD_WriteBlocks_DMA>:
{
 8005880:	b508      	push	{r3, lr}
  if (HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 8005882:	4613      	mov	r3, r2
 8005884:	460a      	mov	r2, r1
 8005886:	4601      	mov	r1, r0
 8005888:	4803      	ldr	r0, [pc, #12]	; (8005898 <BSP_SD_WriteBlocks_DMA+0x18>)
 800588a:	f7fc fa23 	bl	8001cd4 <HAL_SD_WriteBlocks_DMA>
}
 800588e:	3000      	adds	r0, #0
 8005890:	bf18      	it	ne
 8005892:	2001      	movne	r0, #1
 8005894:	bd08      	pop	{r3, pc}
 8005896:	bf00      	nop
 8005898:	20004610 	.word	0x20004610

0800589c <BSP_SD_GetCardState>:
{
 800589c:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 800589e:	4803      	ldr	r0, [pc, #12]	; (80058ac <BSP_SD_GetCardState+0x10>)
 80058a0:	f7fc fd34 	bl	800230c <HAL_SD_GetCardState>
}
 80058a4:	3804      	subs	r0, #4
 80058a6:	bf18      	it	ne
 80058a8:	2001      	movne	r0, #1
 80058aa:	bd08      	pop	{r3, pc}
 80058ac:	20004610 	.word	0x20004610

080058b0 <BSP_SD_GetCardInfo>:
  HAL_SD_GetCardInfo(&hsd, CardInfo);
 80058b0:	4601      	mov	r1, r0
 80058b2:	4801      	ldr	r0, [pc, #4]	; (80058b8 <BSP_SD_GetCardInfo+0x8>)
 80058b4:	f7fc bc94 	b.w	80021e0 <HAL_SD_GetCardInfo>
 80058b8:	20004610 	.word	0x20004610

080058bc <BSP_SD_AbortCallback>:
 80058bc:	4770      	bx	lr

080058be <HAL_SD_AbortCallback>:
{
 80058be:	b508      	push	{r3, lr}
  BSP_SD_AbortCallback();
 80058c0:	f7ff fffc 	bl	80058bc <BSP_SD_AbortCallback>
 80058c4:	bd08      	pop	{r3, pc}

080058c6 <HAL_SD_TxCpltCallback>:
{
 80058c6:	b508      	push	{r3, lr}
  BSP_SD_WriteCpltCallback();
 80058c8:	f000 fc1c 	bl	8006104 <BSP_SD_WriteCpltCallback>
 80058cc:	bd08      	pop	{r3, pc}

080058ce <HAL_SD_RxCpltCallback>:
{
 80058ce:	b508      	push	{r3, lr}
  BSP_SD_ReadCpltCallback();
 80058d0:	f000 fc22 	bl	8006118 <BSP_SD_ReadCpltCallback>
 80058d4:	bd08      	pop	{r3, pc}
	...

080058d8 <HAL_CAN_MspInit>:
  }

}

void HAL_CAN_MspInit(CAN_HandleTypeDef* canHandle)
{
 80058d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80058da:	4604      	mov	r4, r0
 80058dc:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80058de:	2214      	movs	r2, #20
 80058e0:	2100      	movs	r1, #0
 80058e2:	a803      	add	r0, sp, #12
 80058e4:	f001 faeb 	bl	8006ebe <memset>
  if(canHandle->Instance==CAN1)
 80058e8:	6822      	ldr	r2, [r4, #0]
 80058ea:	4b1f      	ldr	r3, [pc, #124]	; (8005968 <HAL_CAN_MspInit+0x90>)
 80058ec:	429a      	cmp	r2, r3
 80058ee:	d138      	bne.n	8005962 <HAL_CAN_MspInit+0x8a>
  {
  /* USER CODE BEGIN CAN1_MspInit 0 */

  /* USER CODE END CAN1_MspInit 0 */
    /* CAN1 clock enable */
    __HAL_RCC_CAN1_CLK_ENABLE();
 80058f0:	f503 33ea 	add.w	r3, r3, #119808	; 0x1d400
 80058f4:	2400      	movs	r4, #0
 80058f6:	9400      	str	r4, [sp, #0]
 80058f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80058fa:	481c      	ldr	r0, [pc, #112]	; (800596c <HAL_CAN_MspInit+0x94>)
    __HAL_RCC_CAN1_CLK_ENABLE();
 80058fc:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8005900:	641a      	str	r2, [r3, #64]	; 0x40
 8005902:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005904:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 8005908:	9200      	str	r2, [sp, #0]
 800590a:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800590c:	9401      	str	r4, [sp, #4]
 800590e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005910:	f042 0201 	orr.w	r2, r2, #1
 8005914:	631a      	str	r2, [r3, #48]	; 0x30
 8005916:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005918:	f002 0201 	and.w	r2, r2, #1
 800591c:	9201      	str	r2, [sp, #4]
 800591e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005920:	9402      	str	r4, [sp, #8]
 8005922:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005924:	f042 0202 	orr.w	r2, r2, #2
 8005928:	631a      	str	r2, [r3, #48]	; 0x30
 800592a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800592c:	f003 0302 	and.w	r3, r3, #2
 8005930:	9302      	str	r3, [sp, #8]
 8005932:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005934:	2702      	movs	r7, #2
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 8005936:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800593a:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 800593c:	2509      	movs	r5, #9
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800593e:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 8005940:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005942:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005944:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 8005946:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005948:	f7fb fa64 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8;
 800594c:	f44f 7380 	mov.w	r3, #256	; 0x100
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005950:	a903      	add	r1, sp, #12
 8005952:	4807      	ldr	r0, [pc, #28]	; (8005970 <HAL_CAN_MspInit+0x98>)
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 8005954:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005956:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005958:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800595a:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 800595c:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800595e:	f7fb fa59 	bl	8000e14 <HAL_GPIO_Init>

  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }
}
 8005962:	b009      	add	sp, #36	; 0x24
 8005964:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005966:	bf00      	nop
 8005968:	40006400 	.word	0x40006400
 800596c:	40020000 	.word	0x40020000
 8005970:	40020400 	.word	0x40020400

08005974 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8005974:	b513      	push	{r0, r1, r4, lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8005976:	4b20      	ldr	r3, [pc, #128]	; (80059f8 <MX_DMA_Init+0x84>)
 8005978:	2400      	movs	r4, #0
 800597a:	9400      	str	r4, [sp, #0]
 800597c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800597e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8005982:	631a      	str	r2, [r3, #48]	; 0x30
 8005984:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005986:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 800598a:	9200      	str	r2, [sp, #0]
 800598c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 800598e:	9401      	str	r4, [sp, #4]
 8005990:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005992:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8005996:	631a      	str	r2, [r3, #48]	; 0x30
 8005998:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800599a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
 800599e:	4622      	mov	r2, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 80059a0:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
 80059a2:	2105      	movs	r1, #5
 80059a4:	200c      	movs	r0, #12
  __HAL_RCC_DMA1_CLK_ENABLE();
 80059a6:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
 80059a8:	f7fb f840 	bl	8000a2c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 80059ac:	200c      	movs	r0, #12
 80059ae:	f7fb f871 	bl	8000a94 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 5, 0);
 80059b2:	4622      	mov	r2, r4
 80059b4:	2105      	movs	r1, #5
 80059b6:	200d      	movs	r0, #13
 80059b8:	f7fb f838 	bl	8000a2c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
 80059bc:	200d      	movs	r0, #13
 80059be:	f7fb f869 	bl	8000a94 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 5, 0);
 80059c2:	4622      	mov	r2, r4
 80059c4:	2105      	movs	r1, #5
 80059c6:	200f      	movs	r0, #15
 80059c8:	f7fb f830 	bl	8000a2c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn);
 80059cc:	200f      	movs	r0, #15
 80059ce:	f7fb f861 	bl	8000a94 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
 80059d2:	4622      	mov	r2, r4
 80059d4:	2105      	movs	r1, #5
 80059d6:	203b      	movs	r0, #59	; 0x3b
 80059d8:	f7fb f828 	bl	8000a2c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 80059dc:	203b      	movs	r0, #59	; 0x3b
 80059de:	f7fb f859 	bl	8000a94 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 5, 0);
 80059e2:	4622      	mov	r2, r4
 80059e4:	2105      	movs	r1, #5
 80059e6:	2045      	movs	r0, #69	; 0x45
 80059e8:	f7fb f820 	bl	8000a2c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 80059ec:	2045      	movs	r0, #69	; 0x45
 80059ee:	f7fb f851 	bl	8000a94 <HAL_NVIC_EnableIRQ>

}
 80059f2:	b002      	add	sp, #8
 80059f4:	bd10      	pop	{r4, pc}
 80059f6:	bf00      	nop
 80059f8:	40023800 	.word	0x40023800

080059fc <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 80059fc:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 80059fe:	4903      	ldr	r1, [pc, #12]	; (8005a0c <MX_FATFS_Init+0x10>)
 8005a00:	4803      	ldr	r0, [pc, #12]	; (8005a10 <MX_FATFS_Init+0x14>)
 8005a02:	f7fe f8df 	bl	8003bc4 <FATFS_LinkDriver>
 8005a06:	4b03      	ldr	r3, [pc, #12]	; (8005a14 <MX_FATFS_Init+0x18>)
 8005a08:	7018      	strb	r0, [r3, #0]
 8005a0a:	bd08      	pop	{r3, pc}
 8005a0c:	20003fd9 	.word	0x20003fd9
 8005a10:	08006f5c 	.word	0x08006f5c
 8005a14:	20003fd8 	.word	0x20003fd8

08005a18 <StartDefaultTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 8005a18:	b508      	push	{r3, lr}
  /* init code for FATFS */
  MX_FATFS_Init();
 8005a1a:	f7ff ffef 	bl	80059fc <MX_FATFS_Init>

  /* USER CODE BEGIN StartDefaultTask */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8005a1e:	2001      	movs	r0, #1
 8005a20:	f7fe f8ff 	bl	8003c22 <osDelay>
 8005a24:	e7fb      	b.n	8005a1e <StartDefaultTask+0x6>
	...

08005a28 <StartReadCAN>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartReadCAN */
void StartReadCAN(void const * argument)
{
 8005a28:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* USER CODE BEGIN StartReadCAN */
  /* Infinite loop */
	BARO_data* new_baro_data = 0;
	IMU_data* new_imu_data = 0;
	uint32_t timestamp = HAL_GetTick();
 8005a2c:	f7fa fdc2 	bl	80005b4 <HAL_GetTick>
	uint32_t a = HAL_GetTick();
	uint8_t oldState = currentState;
 8005a30:	4f3e      	ldr	r7, [pc, #248]	; (8005b2c <StartReadCAN+0x104>)
		if (currentState != oldState) {
			setFrame(0, currentState, a);
			oldState = currentState;
		}
		if (readFrame() > 0) {
			if (current_msg.id_CAN == ID_GPS_SENSOR) {
 8005a32:	4d3f      	ldr	r5, [pc, #252]	; (8005b30 <StartReadCAN+0x108>)
					new_imu_data->gyro_rps.z = current_msg.data;
					//setFrame(255, 255, 255);
					//----------------------------------------------------
					// Call Loic's function
					//----------------------------------------------------
				    currentBaroSeqNumber++;
 8005a34:	f8df 8104 	ldr.w	r8, [pc, #260]	; 8005b3c <StartReadCAN+0x114>
	uint32_t timestamp = HAL_GetTick();
 8005a38:	4681      	mov	r9, r0
	uint32_t a = HAL_GetTick();
 8005a3a:	f7fa fdbb 	bl	80005b4 <HAL_GetTick>
	uint8_t oldState = currentState;
 8005a3e:	f897 b000 	ldrb.w	fp, [r7]
	IMU_data* new_imu_data = 0;
 8005a42:	2400      	movs	r4, #0
	uint8_t oldState = currentState;
 8005a44:	fa5f fb8b 	uxtb.w	fp, fp
		a = HAL_GetTick();
 8005a48:	f7fa fdb4 	bl	80005b4 <HAL_GetTick>
		if (a - timestamp > 2000) {
 8005a4c:	eba0 0309 	sub.w	r3, r0, r9
 8005a50:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
		a = HAL_GetTick();
 8005a54:	4682      	mov	sl, r0
		if (a - timestamp > 2000) {
 8005a56:	d905      	bls.n	8005a64 <StartReadCAN+0x3c>
			setFrame(0, currentState, a);
 8005a58:	4602      	mov	r2, r0
 8005a5a:	7839      	ldrb	r1, [r7, #0]
 8005a5c:	2000      	movs	r0, #0
 8005a5e:	f7ff fbe7 	bl	8005230 <setFrame>
			timestamp = a;
 8005a62:	46d1      	mov	r9, sl
		if (currentState != oldState) {
 8005a64:	783e      	ldrb	r6, [r7, #0]
 8005a66:	b2f6      	uxtb	r6, r6
 8005a68:	45b3      	cmp	fp, r6
 8005a6a:	d006      	beq.n	8005a7a <StartReadCAN+0x52>
			setFrame(0, currentState, a);
 8005a6c:	7839      	ldrb	r1, [r7, #0]
 8005a6e:	4652      	mov	r2, sl
 8005a70:	2000      	movs	r0, #0
 8005a72:	f7ff fbdd 	bl	8005230 <setFrame>
			oldState = currentState;
 8005a76:	783e      	ldrb	r6, [r7, #0]
 8005a78:	b2f6      	uxtb	r6, r6
		if (readFrame() > 0) {
 8005a7a:	f7ff fc03 	bl	8005284 <readFrame>
 8005a7e:	b1d8      	cbz	r0, 8005ab8 <StartReadCAN+0x90>
			if (current_msg.id_CAN == ID_GPS_SENSOR) {
 8005a80:	68eb      	ldr	r3, [r5, #12]
 8005a82:	2b03      	cmp	r3, #3
 8005a84:	d118      	bne.n	8005ab8 <StartReadCAN+0x90>
				if (current_msg.id == DATA_ID_ALTITUDE) {
 8005a86:	792b      	ldrb	r3, [r5, #4]
 8005a88:	b9c3      	cbnz	r3, 8005abc <StartReadCAN+0x94>
					new_imu_data = &IMU_buffer[(currentImuSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005a8a:	4a2a      	ldr	r2, [pc, #168]	; (8005b34 <StartReadCAN+0x10c>)
					new_baro_data = &BARO_buffer[(currentBaroSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005a8c:	f8d8 3000 	ldr.w	r3, [r8]
					new_imu_data = &IMU_buffer[(currentImuSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005a90:	6814      	ldr	r4, [r2, #0]
					new_baro_data->altitude = current_msg.data;
 8005a92:	edd5 7a00 	vldr	s15, [r5]
					new_imu_data = &IMU_buffer[(currentImuSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005a96:	4a28      	ldr	r2, [pc, #160]	; (8005b38 <StartReadCAN+0x110>)
 8005a98:	3401      	adds	r4, #1
 8005a9a:	2128      	movs	r1, #40	; 0x28
 8005a9c:	f004 0407 	and.w	r4, r4, #7
					new_baro_data = &BARO_buffer[(currentBaroSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005aa0:	3301      	adds	r3, #1
					new_imu_data = &IMU_buffer[(currentImuSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005aa2:	fb01 2404 	mla	r4, r1, r4, r2
					new_baro_data = &BARO_buffer[(currentBaroSeqNumber + 1) % CIRC_BUFFER_SIZE];
 8005aa6:	f003 0307 	and.w	r3, r3, #7
					new_baro_data->altitude = current_msg.data;
 8005aaa:	210c      	movs	r1, #12
 8005aac:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005ab0:	fb01 2303 	mla	r3, r1, r3, r2
 8005ab4:	edc3 7a52 	vstr	s15, [r3, #328]	; 0x148
{
 8005ab8:	46b3      	mov	fp, r6
 8005aba:	e7c5      	b.n	8005a48 <StartReadCAN+0x20>
				if (current_msg.id == DATA_ID_ACCELERATION_X) {
 8005abc:	2b01      	cmp	r3, #1
 8005abe:	d106      	bne.n	8005ace <StartReadCAN+0xa6>
					new_imu_data->acceleration.x = current_msg.data;
 8005ac0:	edd5 7a00 	vldr	s15, [r5]
 8005ac4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005ac8:	edc4 7a00 	vstr	s15, [r4]
 8005acc:	e7f4      	b.n	8005ab8 <StartReadCAN+0x90>
				if (current_msg.id == DATA_ID_ACCELERATION_Y) {
 8005ace:	2b02      	cmp	r3, #2
 8005ad0:	d106      	bne.n	8005ae0 <StartReadCAN+0xb8>
					new_imu_data->acceleration.y = current_msg.data;
 8005ad2:	edd5 7a00 	vldr	s15, [r5]
 8005ad6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005ada:	edc4 7a01 	vstr	s15, [r4, #4]
 8005ade:	e7eb      	b.n	8005ab8 <StartReadCAN+0x90>
				if (current_msg.id == DATA_ID_ACCELERATION_Z) {
 8005ae0:	2b03      	cmp	r3, #3
 8005ae2:	d0f6      	beq.n	8005ad2 <StartReadCAN+0xaa>
				if (current_msg.id == DATA_ID_GYRO_X) {
 8005ae4:	2b04      	cmp	r3, #4
 8005ae6:	d106      	bne.n	8005af6 <StartReadCAN+0xce>
					new_imu_data->gyro_rps.x = current_msg.data;
 8005ae8:	edd5 7a00 	vldr	s15, [r5]
 8005aec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005af0:	edc4 7a03 	vstr	s15, [r4, #12]
 8005af4:	e7e0      	b.n	8005ab8 <StartReadCAN+0x90>
				if (current_msg.id == DATA_ID_GYRO_Y) {
 8005af6:	2b05      	cmp	r3, #5
 8005af8:	d106      	bne.n	8005b08 <StartReadCAN+0xe0>
					new_imu_data->gyro_rps.y = current_msg.data;
 8005afa:	edd5 7a00 	vldr	s15, [r5]
 8005afe:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005b02:	edc4 7a04 	vstr	s15, [r4, #16]
 8005b06:	e7d7      	b.n	8005ab8 <StartReadCAN+0x90>
				if (current_msg.id == DATA_ID_GYRO_Z) {
 8005b08:	2b06      	cmp	r3, #6
 8005b0a:	d1d5      	bne.n	8005ab8 <StartReadCAN+0x90>
				    currentBaroSeqNumber++;
 8005b0c:	f8d8 3000 	ldr.w	r3, [r8]
				    currentImuSeqNumber++;
 8005b10:	4a08      	ldr	r2, [pc, #32]	; (8005b34 <StartReadCAN+0x10c>)
					new_imu_data->gyro_rps.z = current_msg.data;
 8005b12:	edd5 7a00 	vldr	s15, [r5]
				    currentBaroSeqNumber++;
 8005b16:	3301      	adds	r3, #1
 8005b18:	f8c8 3000 	str.w	r3, [r8]
				    currentImuSeqNumber++;
 8005b1c:	6813      	ldr	r3, [r2, #0]
					new_imu_data->gyro_rps.z = current_msg.data;
 8005b1e:	eef8 7a67 	vcvt.f32.u32	s15, s15
				    currentImuSeqNumber++;
 8005b22:	3301      	adds	r3, #1
					new_imu_data->gyro_rps.z = current_msg.data;
 8005b24:	edc4 7a05 	vstr	s15, [r4, #20]
				    currentImuSeqNumber++;
 8005b28:	6013      	str	r3, [r2, #0]
 8005b2a:	e7c5      	b.n	8005ab8 <StartReadCAN+0x90>
 8005b2c:	20003f94 	.word	0x20003f94
 8005b30:	20003f80 	.word	0x20003f80
 8005b34:	20003f2c 	.word	0x20003f2c
 8005b38:	20000014 	.word	0x20000014
 8005b3c:	20003f28 	.word	0x20003f28

08005b40 <MX_FREERTOS_Init>:
void MX_FREERTOS_Init(void) {
 8005b40:	b570      	push	{r4, r5, r6, lr}
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8005b42:	4c14      	ldr	r4, [pc, #80]	; (8005b94 <MX_FREERTOS_Init+0x54>)
 8005b44:	4626      	mov	r6, r4
 8005b46:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
void MX_FREERTOS_Init(void) {
 8005b48:	b090      	sub	sp, #64	; 0x40
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8005b4a:	ad01      	add	r5, sp, #4
 8005b4c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005b4e:	6833      	ldr	r3, [r6, #0]
 8005b50:	602b      	str	r3, [r5, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8005b52:	2100      	movs	r1, #0
 8005b54:	a801      	add	r0, sp, #4
 8005b56:	f7fe f84c 	bl	8003bf2 <osThreadCreate>
 8005b5a:	4b0f      	ldr	r3, [pc, #60]	; (8005b98 <MX_FREERTOS_Init+0x58>)
  osThreadDef(readCAN, StartReadCAN, osPriorityNormal, 0, 128);
 8005b5c:	f104 0614 	add.w	r6, r4, #20
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8005b60:	6018      	str	r0, [r3, #0]
  osThreadDef(readCAN, StartReadCAN, osPriorityNormal, 0, 128);
 8005b62:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005b64:	ad06      	add	r5, sp, #24
 8005b66:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005b68:	6833      	ldr	r3, [r6, #0]
 8005b6a:	602b      	str	r3, [r5, #0]
  readCANHandle = osThreadCreate(osThread(readCAN), NULL);
 8005b6c:	2100      	movs	r1, #0
 8005b6e:	a806      	add	r0, sp, #24
 8005b70:	f7fe f83f 	bl	8003bf2 <osThreadCreate>
 8005b74:	4b09      	ldr	r3, [pc, #36]	; (8005b9c <MX_FREERTOS_Init+0x5c>)
  osThreadDef(state_machine, TK_state_machine, osPriorityHigh, 0, 1024);
 8005b76:	3428      	adds	r4, #40	; 0x28
  readCANHandle = osThreadCreate(osThread(readCAN), NULL);
 8005b78:	6018      	str	r0, [r3, #0]
  osThreadDef(state_machine, TK_state_machine, osPriorityHigh, 0, 1024);
 8005b7a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005b7c:	ad0b      	add	r5, sp, #44	; 0x2c
 8005b7e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005b80:	6823      	ldr	r3, [r4, #0]
 8005b82:	602b      	str	r3, [r5, #0]
  state_machineHandle = osThreadCreate(osThread(state_machine), NULL);
 8005b84:	2100      	movs	r1, #0
 8005b86:	a80b      	add	r0, sp, #44	; 0x2c
 8005b88:	f7fe f833 	bl	8003bf2 <osThreadCreate>
 8005b8c:	4b04      	ldr	r3, [pc, #16]	; (8005ba0 <MX_FREERTOS_Init+0x60>)
 8005b8e:	6018      	str	r0, [r3, #0]
}
 8005b90:	b010      	add	sp, #64	; 0x40
 8005b92:	bd70      	pop	{r4, r5, r6, pc}
 8005b94:	08006ee8 	.word	0x08006ee8
 8005b98:	20004444 	.word	0x20004444
 8005b9c:	20004448 	.word	0x20004448
 8005ba0:	2000444c 	.word	0x2000444c

08005ba4 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8005ba4:	b086      	sub	sp, #24

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005ba6:	4b1b      	ldr	r3, [pc, #108]	; (8005c14 <MX_GPIO_Init+0x70>)
 8005ba8:	2200      	movs	r2, #0
 8005baa:	9201      	str	r2, [sp, #4]
 8005bac:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bae:	f041 0104 	orr.w	r1, r1, #4
 8005bb2:	6319      	str	r1, [r3, #48]	; 0x30
 8005bb4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bb6:	f001 0104 	and.w	r1, r1, #4
 8005bba:	9101      	str	r1, [sp, #4]
 8005bbc:	9901      	ldr	r1, [sp, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005bbe:	9202      	str	r2, [sp, #8]
 8005bc0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bc2:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8005bc6:	6319      	str	r1, [r3, #48]	; 0x30
 8005bc8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bca:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8005bce:	9102      	str	r1, [sp, #8]
 8005bd0:	9902      	ldr	r1, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005bd2:	9203      	str	r2, [sp, #12]
 8005bd4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bd6:	f041 0101 	orr.w	r1, r1, #1
 8005bda:	6319      	str	r1, [r3, #48]	; 0x30
 8005bdc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bde:	f001 0101 	and.w	r1, r1, #1
 8005be2:	9103      	str	r1, [sp, #12]
 8005be4:	9903      	ldr	r1, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005be6:	9204      	str	r2, [sp, #16]
 8005be8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bea:	f041 0102 	orr.w	r1, r1, #2
 8005bee:	6319      	str	r1, [r3, #48]	; 0x30
 8005bf0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005bf2:	f001 0102 	and.w	r1, r1, #2
 8005bf6:	9104      	str	r1, [sp, #16]
 8005bf8:	9904      	ldr	r1, [sp, #16]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005bfa:	9205      	str	r2, [sp, #20]
 8005bfc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005bfe:	f042 0208 	orr.w	r2, r2, #8
 8005c02:	631a      	str	r2, [r3, #48]	; 0x30
 8005c04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005c06:	f003 0308 	and.w	r3, r3, #8
 8005c0a:	9305      	str	r3, [sp, #20]
 8005c0c:	9b05      	ldr	r3, [sp, #20]

}
 8005c0e:	b006      	add	sp, #24
 8005c10:	4770      	bx	lr
 8005c12:	bf00      	nop
 8005c14:	40023800 	.word	0x40023800

08005c18 <MX_I2C3_Init>:
I2C_HandleTypeDef hi2c3;
DMA_HandleTypeDef hdma_i2c3_rx;

/* I2C3 init function */
void MX_I2C3_Init(void)
{
 8005c18:	b508      	push	{r3, lr}

  hi2c3.Instance = I2C3;
 8005c1a:	480c      	ldr	r0, [pc, #48]	; (8005c4c <MX_I2C3_Init+0x34>)
  hi2c3.Init.ClockSpeed = 100000;
 8005c1c:	4b0c      	ldr	r3, [pc, #48]	; (8005c50 <MX_I2C3_Init+0x38>)
 8005c1e:	f8df e034 	ldr.w	lr, [pc, #52]	; 8005c54 <MX_I2C3_Init+0x3c>
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005c22:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  hi2c3.Init.ClockSpeed = 100000;
 8005c26:	e880 4008 	stmia.w	r0, {r3, lr}
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
 8005c2a:	2300      	movs	r3, #0
 8005c2c:	6083      	str	r3, [r0, #8]
  hi2c3.Init.OwnAddress1 = 0;
 8005c2e:	60c3      	str	r3, [r0, #12]
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005c30:	6102      	str	r2, [r0, #16]
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005c32:	6143      	str	r3, [r0, #20]
  hi2c3.Init.OwnAddress2 = 0;
 8005c34:	6183      	str	r3, [r0, #24]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005c36:	61c3      	str	r3, [r0, #28]
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005c38:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 8005c3a:	f7fb f9c5 	bl	8000fc8 <HAL_I2C_Init>
 8005c3e:	b118      	cbz	r0, 8005c48 <MX_I2C3_Init+0x30>
  {
    Error_Handler();
  }

}
 8005c40:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8005c44:	f000 b939 	b.w	8005eba <Error_Handler>
 8005c48:	bd08      	pop	{r3, pc}
 8005c4a:	bf00      	nop
 8005c4c:	20004450 	.word	0x20004450
 8005c50:	40005c00 	.word	0x40005c00
 8005c54:	000186a0 	.word	0x000186a0

08005c58 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8005c58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c5c:	4606      	mov	r6, r0
 8005c5e:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005c60:	2214      	movs	r2, #20
 8005c62:	2100      	movs	r1, #0
 8005c64:	a803      	add	r0, sp, #12
 8005c66:	f001 f92a 	bl	8006ebe <memset>
  if(i2cHandle->Instance==I2C3)
 8005c6a:	6832      	ldr	r2, [r6, #0]
 8005c6c:	4b2f      	ldr	r3, [pc, #188]	; (8005d2c <HAL_I2C_MspInit+0xd4>)
 8005c6e:	429a      	cmp	r2, r3
 8005c70:	d159      	bne.n	8005d26 <HAL_I2C_MspInit+0xce>
  {
  /* USER CODE BEGIN I2C3_MspInit 0 */

  /* USER CODE END I2C3_MspInit 0 */
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005c72:	2500      	movs	r5, #0
 8005c74:	4c2e      	ldr	r4, [pc, #184]	; (8005d30 <HAL_I2C_MspInit+0xd8>)
 8005c76:	9500      	str	r5, [sp, #0]
 8005c78:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005c7a:	482e      	ldr	r0, [pc, #184]	; (8005d34 <HAL_I2C_MspInit+0xdc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005c7c:	f043 0301 	orr.w	r3, r3, #1
 8005c80:	6323      	str	r3, [r4, #48]	; 0x30
 8005c82:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c84:	f003 0301 	and.w	r3, r3, #1
 8005c88:	9300      	str	r3, [sp, #0]
 8005c8a:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005c8c:	9501      	str	r5, [sp, #4]
 8005c8e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c90:	f043 0302 	orr.w	r3, r3, #2
 8005c94:	6323      	str	r3, [r4, #48]	; 0x30
 8005c96:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c98:	f003 0302 	and.w	r3, r3, #2
 8005c9c:	9301      	str	r3, [sp, #4]
 8005c9e:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005ca0:	f04f 0a12 	mov.w	sl, #18
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 8005ca4:	f44f 7380 	mov.w	r3, #256	; 0x100
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ca8:	f04f 0901 	mov.w	r9, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005cac:	f04f 0803 	mov.w	r8, #3
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8005cb0:	2704      	movs	r7, #4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005cb2:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 8005cb4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005cb6:	f8cd a010 	str.w	sl, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005cba:	f8cd 9014 	str.w	r9, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005cbe:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8005cc2:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005cc4:	f7fb f8a6 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8005cc8:	2310      	movs	r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005cca:	481b      	ldr	r0, [pc, #108]	; (8005d38 <HAL_I2C_MspInit+0xe0>)
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8005ccc:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005cce:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005cd0:	f8cd a010 	str.w	sl, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005cd4:	f8cd 9014 	str.w	r9, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005cd8:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8005cdc:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005cde:	f7fb f899 	bl	8000e14 <HAL_GPIO_Init>

    /* I2C3 clock enable */
    __HAL_RCC_I2C3_CLK_ENABLE();
 8005ce2:	9502      	str	r5, [sp, #8]
 8005ce4:	6c23      	ldr	r3, [r4, #64]	; 0x40
  
    /* I2C3 DMA Init */
    /* I2C3_RX Init */
    hdma_i2c3_rx.Instance = DMA1_Stream2;
    hdma_i2c3_rx.Init.Channel = DMA_CHANNEL_3;
 8005ce6:	4a15      	ldr	r2, [pc, #84]	; (8005d3c <HAL_I2C_MspInit+0xe4>)
    __HAL_RCC_I2C3_CLK_ENABLE();
 8005ce8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8005cec:	6423      	str	r3, [r4, #64]	; 0x40
 8005cee:	6c23      	ldr	r3, [r4, #64]	; 0x40
    hdma_i2c3_rx.Instance = DMA1_Stream2;
 8005cf0:	4c13      	ldr	r4, [pc, #76]	; (8005d40 <HAL_I2C_MspInit+0xe8>)
    __HAL_RCC_I2C3_CLK_ENABLE();
 8005cf2:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8005cf6:	9302      	str	r3, [sp, #8]
 8005cf8:	9b02      	ldr	r3, [sp, #8]
    hdma_i2c3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8005cfa:	60a5      	str	r5, [r4, #8]
    hdma_i2c3_rx.Init.Channel = DMA_CHANNEL_3;
 8005cfc:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 8005d00:	e884 000c 	stmia.w	r4, {r2, r3}
    hdma_i2c3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_i2c3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_i2c3_rx.Init.Mode = DMA_NORMAL;
    hdma_i2c3_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_i2c3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_i2c3_rx) != HAL_OK)
 8005d04:	4620      	mov	r0, r4
    hdma_i2c3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8005d06:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_i2c3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8005d0a:	60e5      	str	r5, [r4, #12]
    hdma_i2c3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8005d0c:	6123      	str	r3, [r4, #16]
    hdma_i2c3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8005d0e:	6165      	str	r5, [r4, #20]
    hdma_i2c3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8005d10:	61a5      	str	r5, [r4, #24]
    hdma_i2c3_rx.Init.Mode = DMA_NORMAL;
 8005d12:	61e5      	str	r5, [r4, #28]
    hdma_i2c3_rx.Init.Priority = DMA_PRIORITY_LOW;
 8005d14:	6225      	str	r5, [r4, #32]
    hdma_i2c3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8005d16:	6265      	str	r5, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_i2c3_rx) != HAL_OK)
 8005d18:	f7fa fef4 	bl	8000b04 <HAL_DMA_Init>
 8005d1c:	b108      	cbz	r0, 8005d22 <HAL_I2C_MspInit+0xca>
    {
      Error_Handler();
 8005d1e:	f000 f8cc 	bl	8005eba <Error_Handler>
    }

    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c3_rx);
 8005d22:	63b4      	str	r4, [r6, #56]	; 0x38
 8005d24:	63a6      	str	r6, [r4, #56]	; 0x38

  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }
}
 8005d26:	b008      	add	sp, #32
 8005d28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005d2c:	40005c00 	.word	0x40005c00
 8005d30:	40023800 	.word	0x40023800
 8005d34:	40020000 	.word	0x40020000
 8005d38:	40020400 	.word	0x40020400
 8005d3c:	40026040 	.word	0x40026040
 8005d40:	200044a4 	.word	0x200044a4

08005d44 <led_set_rgb>:
  WRITE_REG(TIMx->CCR1, CompareValue);
 8005d44:	4b02      	ldr	r3, [pc, #8]	; (8005d50 <led_set_rgb+0xc>)
 8005d46:	6358      	str	r0, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8005d48:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8005d4a:	63da      	str	r2, [r3, #60]	; 0x3c
 8005d4c:	4770      	bx	lr
 8005d4e:	bf00      	nop
 8005d50:	40010400 	.word	0x40010400

08005d54 <led_init>:
  SET_BIT(TIMx->CCER, Channels);
 8005d54:	4b12      	ldr	r3, [pc, #72]	; (8005da0 <led_init+0x4c>)
 8005d56:	6a1a      	ldr	r2, [r3, #32]
 8005d58:	f042 0204 	orr.w	r2, r2, #4
 8005d5c:	621a      	str	r2, [r3, #32]
 8005d5e:	6a1a      	ldr	r2, [r3, #32]
 8005d60:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005d64:	621a      	str	r2, [r3, #32]
 8005d66:	6a1a      	ldr	r2, [r3, #32]
 8005d68:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005d6c:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
 8005d6e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005d70:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005d74:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8005d76:	681a      	ldr	r2, [r3, #0]
 8005d78:	f042 0201 	orr.w	r2, r2, #1
 8005d7c:	601a      	str	r2, [r3, #0]
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 8005d7e:	4a09      	ldr	r2, [pc, #36]	; (8005da4 <led_init+0x50>)
 8005d80:	2180      	movs	r1, #128	; 0x80
 8005d82:	6191      	str	r1, [r2, #24]
 8005d84:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8005d88:	f8c2 1418 	str.w	r1, [r2, #1048]	; 0x418
 8005d8c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8005d90:	f8c2 1418 	str.w	r1, [r2, #1048]	; 0x418
  WRITE_REG(TIMx->CCR1, CompareValue);
 8005d94:	2200      	movs	r2, #0
 8005d96:	635a      	str	r2, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8005d98:	639a      	str	r2, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8005d9a:	63da      	str	r2, [r3, #60]	; 0x3c
 8005d9c:	4770      	bx	lr
 8005d9e:	bf00      	nop
 8005da0:	40010400 	.word	0x40010400
 8005da4:	40020000 	.word	0x40020000

08005da8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8005da8:	b530      	push	{r4, r5, lr}
 8005daa:	b0ad      	sub	sp, #180	; 0xb4
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005dac:	2234      	movs	r2, #52	; 0x34
 8005dae:	2100      	movs	r1, #0
 8005db0:	a808      	add	r0, sp, #32
 8005db2:	f001 f884 	bl	8006ebe <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005db6:	2214      	movs	r2, #20
 8005db8:	2100      	movs	r1, #0
 8005dba:	a803      	add	r0, sp, #12
 8005dbc:	f001 f87f 	bl	8006ebe <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8005dc0:	2100      	movs	r1, #0
 8005dc2:	225c      	movs	r2, #92	; 0x5c
 8005dc4:	a815      	add	r0, sp, #84	; 0x54
 8005dc6:	f001 f87a 	bl	8006ebe <memset>

  /**Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8005dca:	2400      	movs	r4, #0
 8005dcc:	4b20      	ldr	r3, [pc, #128]	; (8005e50 <SystemClock_Config+0xa8>)
 8005dce:	9401      	str	r4, [sp, #4]
 8005dd0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005dd2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005dd6:	641a      	str	r2, [r3, #64]	; 0x40
 8005dd8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8005dda:	4a1e      	ldr	r2, [pc, #120]	; (8005e54 <SystemClock_Config+0xac>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8005ddc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005de0:	9301      	str	r3, [sp, #4]
 8005de2:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8005de4:	9402      	str	r4, [sp, #8]
 8005de6:	6813      	ldr	r3, [r2, #0]
 8005de8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8005dec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005df0:	6013      	str	r3, [r2, #0]
 8005df2:	6813      	ldr	r3, [r2, #0]
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8005df4:	940f      	str	r4, [sp, #60]	; 0x3c
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8005df6:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8005dfa:	9302      	str	r3, [sp, #8]
 8005dfc:	9b02      	ldr	r3, [sp, #8]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8005dfe:	2301      	movs	r3, #1
 8005e00:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8005e02:	2310      	movs	r3, #16
 8005e04:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLM = 8;
 8005e06:	2308      	movs	r3, #8
 8005e08:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 72;
 8005e0a:	2348      	movs	r3, #72	; 0x48
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8005e0c:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL.PLLN = 72;
 8005e0e:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005e10:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLQ = 3;
 8005e12:	2303      	movs	r3, #3
 8005e14:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8005e16:	9508      	str	r5, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005e18:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8005e1a:	9512      	str	r5, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = 2;
 8005e1c:	9514      	str	r5, [sp, #80]	; 0x50
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005e1e:	f7fb fccd 	bl	80017bc <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /**Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8005e22:	230f      	movs	r3, #15
 8005e24:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8005e26:	4629      	mov	r1, r5
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8005e28:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8005e2c:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8005e2e:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8005e30:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8005e32:	9405      	str	r4, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8005e34:	9407      	str	r4, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8005e36:	f7fb f9b7 	bl	80011a8 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDIO|RCC_PERIPHCLK_CLK48;
 8005e3a:	f44f 7340 	mov.w	r3, #768	; 0x300
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48CLKSOURCE_PLLQ;
  PeriphClkInitStruct.SdioClockSelection = RCC_SDIOCLKSOURCE_CLK48;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8005e3e:	a815      	add	r0, sp, #84	; 0x54
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDIO|RCC_PERIPHCLK_CLK48;
 8005e40:	9315      	str	r3, [sp, #84]	; 0x54
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48CLKSOURCE_PLLQ;
 8005e42:	942a      	str	r4, [sp, #168]	; 0xa8
  PeriphClkInitStruct.SdioClockSelection = RCC_SDIOCLKSOURCE_CLK48;
 8005e44:	9426      	str	r4, [sp, #152]	; 0x98
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8005e46:	f7fb fa69 	bl	800131c <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
}
 8005e4a:	b02d      	add	sp, #180	; 0xb4
 8005e4c:	bd30      	pop	{r4, r5, pc}
 8005e4e:	bf00      	nop
 8005e50:	40023800 	.word	0x40023800
 8005e54:	40007000 	.word	0x40007000

08005e58 <main>:
{
 8005e58:	b508      	push	{r3, lr}
  HAL_Init();
 8005e5a:	f7fa fb85 	bl	8000568 <HAL_Init>
  SystemClock_Config();
 8005e5e:	f7ff ffa3 	bl	8005da8 <SystemClock_Config>
  MX_GPIO_Init();
 8005e62:	f7ff fe9f 	bl	8005ba4 <MX_GPIO_Init>
  MX_DMA_Init();
 8005e66:	f7ff fd85 	bl	8005974 <MX_DMA_Init>
  MX_ADC1_Init();
 8005e6a:	f7ff fbf3 	bl	8005654 <MX_ADC1_Init>
  MX_ADC2_Init();
 8005e6e:	f7ff fc6f 	bl	8005750 <MX_ADC2_Init>
  MX_I2C3_Init();
 8005e72:	f7ff fed1 	bl	8005c18 <MX_I2C3_Init>
  MX_QUADSPI_Init();
 8005e76:	f000 f821 	bl	8005ebc <MX_QUADSPI_Init>
  MX_SDIO_SD_Init();
 8005e7a:	f000 f957 	bl	800612c <MX_SDIO_SD_Init>
  MX_SPI2_Init();
 8005e7e:	f000 fa2d 	bl	80062dc <MX_SPI2_Init>
  MX_TIM1_Init();
 8005e82:	f000 fd33 	bl	80068ec <MX_TIM1_Init>
  MX_TIM2_Init();
 8005e86:	f000 fd95 	bl	80069b4 <MX_TIM2_Init>
  MX_TIM3_Init();
 8005e8a:	f000 fb11 	bl	80064b0 <MX_TIM3_Init>
  MX_TIM4_Init();
 8005e8e:	f000 fde3 	bl	8006a58 <MX_TIM4_Init>
  MX_TIM5_Init();
 8005e92:	f000 fe2d 	bl	8006af0 <MX_TIM5_Init>
  MX_TIM8_Init();
 8005e96:	f000 fb57 	bl	8006548 <MX_TIM8_Init>
  MX_USART1_UART_Init();
 8005e9a:	f000 fe7d 	bl	8006b98 <MX_USART1_UART_Init>
  MX_USART3_UART_Init();
 8005e9e:	f000 fe97 	bl	8006bd0 <MX_USART3_UART_Init>
  MX_USART6_UART_Init();
 8005ea2:	f000 feb1 	bl	8006c08 <MX_USART6_UART_Init>
  CAN_Config(ID_MASTER);
 8005ea6:	2000      	movs	r0, #0
 8005ea8:	f7ff f986 	bl	80051b8 <CAN_Config>
  led_init();
 8005eac:	f7ff ff52 	bl	8005d54 <led_init>
  MX_FREERTOS_Init();
 8005eb0:	f7ff fe46 	bl	8005b40 <MX_FREERTOS_Init>
  osKernelStart();
 8005eb4:	f7fd fe89 	bl	8003bca <osKernelStart>
 8005eb8:	e7fe      	b.n	8005eb8 <main+0x60>

08005eba <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8005eba:	4770      	bx	lr

08005ebc <MX_QUADSPI_Init>:

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{

  hqspi.Instance = QUADSPI;
 8005ebc:	480b      	ldr	r0, [pc, #44]	; (8005eec <MX_QUADSPI_Init+0x30>)
  hqspi.Init.ClockPrescaler = 255;
 8005ebe:	4a0c      	ldr	r2, [pc, #48]	; (8005ef0 <MX_QUADSPI_Init+0x34>)
{
 8005ec0:	b508      	push	{r3, lr}
  hqspi.Init.ClockPrescaler = 255;
 8005ec2:	23ff      	movs	r3, #255	; 0xff
 8005ec4:	e880 000c 	stmia.w	r0, {r2, r3}
  hqspi.Init.FifoThreshold = 1;
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 8005ec8:	2300      	movs	r3, #0
  hqspi.Init.FifoThreshold = 1;
 8005eca:	2201      	movs	r2, #1
 8005ecc:	6082      	str	r2, [r0, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 8005ece:	60c3      	str	r3, [r0, #12]
  hqspi.Init.FlashSize = 1;
 8005ed0:	6102      	str	r2, [r0, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
 8005ed2:	6143      	str	r3, [r0, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
 8005ed4:	6183      	str	r3, [r0, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
 8005ed6:	61c3      	str	r3, [r0, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
 8005ed8:	6203      	str	r3, [r0, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 8005eda:	f7fb f909 	bl	80010f0 <HAL_QSPI_Init>
 8005ede:	b118      	cbz	r0, 8005ee8 <MX_QUADSPI_Init+0x2c>
  {
    Error_Handler();
  }

}
 8005ee0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8005ee4:	f7ff bfe9 	b.w	8005eba <Error_Handler>
 8005ee8:	bd08      	pop	{r3, pc}
 8005eea:	bf00      	nop
 8005eec:	20004504 	.word	0x20004504
 8005ef0:	a0001000 	.word	0xa0001000

08005ef4 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
 8005ef4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005ef6:	4604      	mov	r4, r0
 8005ef8:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005efa:	2214      	movs	r2, #20
 8005efc:	2100      	movs	r1, #0
 8005efe:	a803      	add	r0, sp, #12
 8005f00:	f000 ffdd 	bl	8006ebe <memset>
  if(qspiHandle->Instance==QUADSPI)
 8005f04:	6822      	ldr	r2, [r4, #0]
 8005f06:	4b23      	ldr	r3, [pc, #140]	; (8005f94 <HAL_QSPI_MspInit+0xa0>)
 8005f08:	429a      	cmp	r2, r3
 8005f0a:	d141      	bne.n	8005f90 <HAL_QSPI_MspInit+0x9c>
  {
  /* USER CODE BEGIN QUADSPI_MspInit 0 */

  /* USER CODE END QUADSPI_MspInit 0 */
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
 8005f0c:	4b22      	ldr	r3, [pc, #136]	; (8005f98 <HAL_QSPI_MspInit+0xa4>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_QSPI;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f0e:	4823      	ldr	r0, [pc, #140]	; (8005f9c <HAL_QSPI_MspInit+0xa8>)
    __HAL_RCC_QSPI_CLK_ENABLE();
 8005f10:	2400      	movs	r4, #0
 8005f12:	9400      	str	r4, [sp, #0]
 8005f14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005f16:	f042 0202 	orr.w	r2, r2, #2
 8005f1a:	639a      	str	r2, [r3, #56]	; 0x38
 8005f1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005f1e:	f002 0202 	and.w	r2, r2, #2
 8005f22:	9200      	str	r2, [sp, #0]
 8005f24:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005f26:	9401      	str	r4, [sp, #4]
 8005f28:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005f2a:	f042 0202 	orr.w	r2, r2, #2
 8005f2e:	631a      	str	r2, [r3, #48]	; 0x30
 8005f30:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005f32:	f002 0202 	and.w	r2, r2, #2
 8005f36:	9201      	str	r2, [sp, #4]
 8005f38:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8005f3a:	9402      	str	r4, [sp, #8]
 8005f3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005f3e:	f042 0204 	orr.w	r2, r2, #4
 8005f42:	631a      	str	r2, [r3, #48]	; 0x30
 8005f44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f46:	f003 0304 	and.w	r3, r3, #4
 8005f4a:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f4c:	2602      	movs	r6, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005f4e:	2503      	movs	r5, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8005f50:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f52:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8005f54:	2304      	movs	r3, #4
    GPIO_InitStruct.Alternate = GPIO_AF9_QSPI;
 8005f56:	2709      	movs	r7, #9
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f58:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8005f5a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005f5c:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_QSPI;
 8005f5e:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f60:	f7fa ff58 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8005f64:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_QSPI;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005f68:	a903      	add	r1, sp, #12
 8005f6a:	480d      	ldr	r0, [pc, #52]	; (8005fa0 <HAL_QSPI_MspInit+0xac>)
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8005f6c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f6e:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005f70:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005f72:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_QSPI;
 8005f74:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005f76:	f7fa ff4d 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8005f7a:	2340      	movs	r3, #64	; 0x40
 8005f7c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_QSPI;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f7e:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF10_QSPI;
 8005f80:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f82:	4806      	ldr	r0, [pc, #24]	; (8005f9c <HAL_QSPI_MspInit+0xa8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f84:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005f86:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005f88:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_QSPI;
 8005f8a:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f8c:	f7fa ff42 	bl	8000e14 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 8005f90:	b009      	add	sp, #36	; 0x24
 8005f92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005f94:	a0001000 	.word	0xa0001000
 8005f98:	40023800 	.word	0x40023800
 8005f9c:	40020400 	.word	0x40020400
 8005fa0:	40020800 	.word	0x40020800

08005fa4 <SD_CheckStatus.isra.0>:
/* USER CODE BEGIN beforeFunctionSection */
/* can be used to modify / undefine following code or add new code */
/* USER CODE END beforeFunctionSection */

/* Private functions ---------------------------------------------------------*/
static DSTATUS SD_CheckStatus(BYTE lun)
 8005fa4:	b510      	push	{r4, lr}
{
  Stat = STA_NOINIT;
 8005fa6:	4c06      	ldr	r4, [pc, #24]	; (8005fc0 <SD_CheckStatus.isra.0+0x1c>)
 8005fa8:	2301      	movs	r3, #1
 8005faa:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetCardState() == MSD_OK)
 8005fac:	f7ff fc76 	bl	800589c <BSP_SD_GetCardState>
 8005fb0:	4623      	mov	r3, r4
 8005fb2:	b918      	cbnz	r0, 8005fbc <SD_CheckStatus.isra.0+0x18>
  {
    Stat &= ~STA_NOINIT;
 8005fb4:	7822      	ldrb	r2, [r4, #0]
 8005fb6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8005fba:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 8005fbc:	7818      	ldrb	r0, [r3, #0]
}
 8005fbe:	bd10      	pop	{r4, pc}
 8005fc0:	2000000c 	.word	0x2000000c

08005fc4 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8005fc4:	b513      	push	{r0, r1, r4, lr}
  Stat = STA_NOINIT;
 8005fc6:	4c0e      	ldr	r4, [pc, #56]	; (8006000 <SD_initialize+0x3c>)
 8005fc8:	2301      	movs	r3, #1
 8005fca:	7023      	strb	r3, [r4, #0]
  /*
   * check that the kernel has been started before continuing
   * as the osMessage API will fail otherwise
   */
  if(osKernelRunning())
 8005fcc:	f7fd fe02 	bl	8003bd4 <osKernelRunning>
 8005fd0:	b198      	cbz	r0, 8005ffa <SD_initialize+0x36>
  {
#if !defined(DISABLE_SD_INIT)

    if(BSP_SD_Init() == MSD_OK)
 8005fd2:	f7ff fc2d 	bl	8005830 <BSP_SD_Init>
 8005fd6:	b910      	cbnz	r0, 8005fde <SD_initialize+0x1a>
    {
      Stat = SD_CheckStatus(lun);
 8005fd8:	f7ff ffe4 	bl	8005fa4 <SD_CheckStatus.isra.0>
 8005fdc:	7020      	strb	r0, [r4, #0]

    /*
     * if the SD is correctly initialized, create the operation queue
     */

    if (Stat != STA_NOINIT)
 8005fde:	7823      	ldrb	r3, [r4, #0]
 8005fe0:	2b01      	cmp	r3, #1
 8005fe2:	d00a      	beq.n	8005ffa <SD_initialize+0x36>
    {
      osMessageQDef(SD_Queue, QUEUE_SIZE, uint16_t);
 8005fe4:	4a07      	ldr	r2, [pc, #28]	; (8006004 <SD_initialize+0x40>)
 8005fe6:	e892 0003 	ldmia.w	r2, {r0, r1}
 8005fea:	e88d 0003 	stmia.w	sp, {r0, r1}
      SDQueueID = osMessageCreate (osMessageQ(SD_Queue), NULL);
 8005fee:	2100      	movs	r1, #0
 8005ff0:	4668      	mov	r0, sp
 8005ff2:	f7fd fe1e 	bl	8003c32 <osMessageCreate>
 8005ff6:	4b04      	ldr	r3, [pc, #16]	; (8006008 <SD_initialize+0x44>)
 8005ff8:	6018      	str	r0, [r3, #0]
    }
  }
  return Stat;
 8005ffa:	7820      	ldrb	r0, [r4, #0]
}
 8005ffc:	b002      	add	sp, #8
 8005ffe:	bd10      	pop	{r4, pc}
 8006000:	2000000c 	.word	0x2000000c
 8006004:	08006f24 	.word	0x08006f24
 8006008:	20003f30 	.word	0x20003f30

0800600c <SD_status>:
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
  return SD_CheckStatus(lun);
 800600c:	f7ff bfca 	b.w	8005fa4 <SD_CheckStatus.isra.0>

08006010 <SD_read.part.1>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
 8006010:	b510      	push	{r4, lr}

    if (event.status == osEventMessage)
    {
      if (event.value.v == WRITE_CPLT_MSG)
      {
        timer = osKernelSysTick() + SD_TIMEOUT;
 8006012:	f7fd fde7 	bl	8003be4 <osKernelSysTick>
 8006016:	f500 44ea 	add.w	r4, r0, #29952	; 0x7500
 800601a:	3430      	adds	r4, #48	; 0x30
        /* block until SDIO IP is ready or a timeout occur */
        while(timer > osKernelSysTick())
 800601c:	f7fd fde2 	bl	8003be4 <osKernelSysTick>
 8006020:	4284      	cmp	r4, r0
 8006022:	d801      	bhi.n	8006028 <SD_read.part.1+0x18>
  DRESULT res = RES_ERROR;
 8006024:	2001      	movs	r0, #1
 8006026:	e003      	b.n	8006030 <SD_read.part.1+0x20>
        {
          if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8006028:	f7ff fc38 	bl	800589c <BSP_SD_GetCardState>
 800602c:	2800      	cmp	r0, #0
 800602e:	d1f5      	bne.n	800601c <SD_read.part.1+0xc>
      }
    }
  }

  return res;
}
 8006030:	bd10      	pop	{r4, pc}
	...

08006034 <SD_read>:
{
 8006034:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8006036:	4608      	mov	r0, r1
 8006038:	4611      	mov	r1, r2
  if(BSP_SD_ReadBlocks_DMA((uint32_t*)buff,
 800603a:	461a      	mov	r2, r3
 800603c:	f7ff fc12 	bl	8005864 <BSP_SD_ReadBlocks_DMA>
 8006040:	b988      	cbnz	r0, 8006066 <SD_read+0x32>
    event = osMessageGet(SDQueueID, SD_TIMEOUT);
 8006042:	4b0b      	ldr	r3, [pc, #44]	; (8006070 <SD_read+0x3c>)
 8006044:	f247 5230 	movw	r2, #30000	; 0x7530
 8006048:	6819      	ldr	r1, [r3, #0]
 800604a:	a801      	add	r0, sp, #4
 800604c:	f7fd fe1e 	bl	8003c8c <osMessageGet>
    if (event.status == osEventMessage)
 8006050:	9b01      	ldr	r3, [sp, #4]
 8006052:	2b10      	cmp	r3, #16
 8006054:	d107      	bne.n	8006066 <SD_read+0x32>
      if (event.value.v == READ_CPLT_MSG)
 8006056:	9b02      	ldr	r3, [sp, #8]
 8006058:	2b01      	cmp	r3, #1
 800605a:	d104      	bne.n	8006066 <SD_read+0x32>
}
 800605c:	b005      	add	sp, #20
 800605e:	f85d eb04 	ldr.w	lr, [sp], #4
 8006062:	f7ff bfd5 	b.w	8006010 <SD_read.part.1>
 8006066:	2001      	movs	r0, #1
 8006068:	b005      	add	sp, #20
 800606a:	f85d fb04 	ldr.w	pc, [sp], #4
 800606e:	bf00      	nop
 8006070:	20003f30 	.word	0x20003f30

08006074 <SD_write>:
{
 8006074:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8006076:	4608      	mov	r0, r1
 8006078:	4611      	mov	r1, r2
  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
 800607a:	461a      	mov	r2, r3
 800607c:	f7ff fc00 	bl	8005880 <BSP_SD_WriteBlocks_DMA>
 8006080:	b988      	cbnz	r0, 80060a6 <SD_write+0x32>
    event = osMessageGet(SDQueueID, SD_TIMEOUT);
 8006082:	4b0b      	ldr	r3, [pc, #44]	; (80060b0 <SD_write+0x3c>)
 8006084:	f247 5230 	movw	r2, #30000	; 0x7530
 8006088:	6819      	ldr	r1, [r3, #0]
 800608a:	a801      	add	r0, sp, #4
 800608c:	f7fd fdfe 	bl	8003c8c <osMessageGet>
    if (event.status == osEventMessage)
 8006090:	9b01      	ldr	r3, [sp, #4]
 8006092:	2b10      	cmp	r3, #16
 8006094:	d107      	bne.n	80060a6 <SD_write+0x32>
      if (event.value.v == WRITE_CPLT_MSG)
 8006096:	9b02      	ldr	r3, [sp, #8]
 8006098:	2b02      	cmp	r3, #2
 800609a:	d104      	bne.n	80060a6 <SD_write+0x32>
}
 800609c:	b005      	add	sp, #20
 800609e:	f85d eb04 	ldr.w	lr, [sp], #4
 80060a2:	f7ff bfb5 	b.w	8006010 <SD_read.part.1>
 80060a6:	2001      	movs	r0, #1
 80060a8:	b005      	add	sp, #20
 80060aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80060ae:	bf00      	nop
 80060b0:	20003f30 	.word	0x20003f30

080060b4 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 80060b4:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80060b6:	4b12      	ldr	r3, [pc, #72]	; (8006100 <SD_ioctl+0x4c>)
 80060b8:	781b      	ldrb	r3, [r3, #0]
 80060ba:	07db      	lsls	r3, r3, #31
{
 80060bc:	b088      	sub	sp, #32
 80060be:	4614      	mov	r4, r2
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80060c0:	d41b      	bmi.n	80060fa <SD_ioctl+0x46>

  switch (cmd)
 80060c2:	2903      	cmp	r1, #3
 80060c4:	d803      	bhi.n	80060ce <SD_ioctl+0x1a>
 80060c6:	e8df f001 	tbb	[pc, r1]
 80060ca:	0510      	.short	0x0510
 80060cc:	120b      	.short	0x120b
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
    res = RES_OK;
    break;

  default:
    res = RES_PARERR;
 80060ce:	2004      	movs	r0, #4
  }

  return res;
}
 80060d0:	b008      	add	sp, #32
 80060d2:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80060d4:	4668      	mov	r0, sp
 80060d6:	f7ff fbeb 	bl	80058b0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80060da:	9b06      	ldr	r3, [sp, #24]
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 80060dc:	6023      	str	r3, [r4, #0]
 80060de:	e004      	b.n	80060ea <SD_ioctl+0x36>
    BSP_SD_GetCardInfo(&CardInfo);
 80060e0:	4668      	mov	r0, sp
 80060e2:	f7ff fbe5 	bl	80058b0 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 80060e6:	9b07      	ldr	r3, [sp, #28]
 80060e8:	8023      	strh	r3, [r4, #0]
    res = RES_OK;
 80060ea:	2000      	movs	r0, #0
 80060ec:	e7f0      	b.n	80060d0 <SD_ioctl+0x1c>
    BSP_SD_GetCardInfo(&CardInfo);
 80060ee:	4668      	mov	r0, sp
 80060f0:	f7ff fbde 	bl	80058b0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 80060f4:	9b07      	ldr	r3, [sp, #28]
 80060f6:	0a5b      	lsrs	r3, r3, #9
 80060f8:	e7f0      	b.n	80060dc <SD_ioctl+0x28>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80060fa:	2003      	movs	r0, #3
 80060fc:	e7e8      	b.n	80060d0 <SD_ioctl+0x1c>
 80060fe:	bf00      	nop
 8006100:	2000000c 	.word	0x2000000c

08006104 <BSP_SD_WriteCpltCallback>:
{
  /*
   * No need to add an "osKernelRunning()" check here, as the SD_initialize()
   * is always called before any SD_Read()/SD_Write() call
   */
  osMessagePut(SDQueueID, WRITE_CPLT_MSG, osWaitForever);
 8006104:	4b03      	ldr	r3, [pc, #12]	; (8006114 <BSP_SD_WriteCpltCallback+0x10>)
 8006106:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800610a:	2102      	movs	r1, #2
 800610c:	6818      	ldr	r0, [r3, #0]
 800610e:	f7fd bd95 	b.w	8003c3c <osMessagePut>
 8006112:	bf00      	nop
 8006114:	20003f30 	.word	0x20003f30

08006118 <BSP_SD_ReadCpltCallback>:
{
  /*
   * No need to add an "osKernelRunning()" check here, as the SD_initialize()
   * is always called before any SD_Read()/SD_Write() call
   */
  osMessagePut(SDQueueID, READ_CPLT_MSG, osWaitForever);
 8006118:	4b03      	ldr	r3, [pc, #12]	; (8006128 <BSP_SD_ReadCpltCallback+0x10>)
 800611a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800611e:	2101      	movs	r1, #1
 8006120:	6818      	ldr	r0, [r3, #0]
 8006122:	f7fd bd8b 	b.w	8003c3c <osMessagePut>
 8006126:	bf00      	nop
 8006128:	20003f30 	.word	0x20003f30

0800612c <MX_SDIO_SD_Init>:
/* SDIO init function */

void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
 800612c:	4b05      	ldr	r3, [pc, #20]	; (8006144 <MX_SDIO_SD_Init+0x18>)
 800612e:	4a06      	ldr	r2, [pc, #24]	; (8006148 <MX_SDIO_SD_Init+0x1c>)
 8006130:	601a      	str	r2, [r3, #0]
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 8006132:	2200      	movs	r2, #0
 8006134:	605a      	str	r2, [r3, #4]
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 8006136:	609a      	str	r2, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8006138:	60da      	str	r2, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 800613a:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 800613c:	615a      	str	r2, [r3, #20]
  hsd.Init.ClockDiv = 0;
 800613e:	619a      	str	r2, [r3, #24]
 8006140:	4770      	bx	lr
 8006142:	bf00      	nop
 8006144:	20004610 	.word	0x20004610
 8006148:	40012c00 	.word	0x40012c00

0800614c <HAL_SD_MspInit>:

}

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 800614c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006150:	2214      	movs	r2, #20
{
 8006152:	b08b      	sub	sp, #44	; 0x2c
 8006154:	4606      	mov	r6, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006156:	2100      	movs	r1, #0
 8006158:	eb0d 0002 	add.w	r0, sp, r2
 800615c:	f000 feaf 	bl	8006ebe <memset>
  if(sdHandle->Instance==SDIO)
 8006160:	6832      	ldr	r2, [r6, #0]
 8006162:	4b56      	ldr	r3, [pc, #344]	; (80062bc <HAL_SD_MspInit+0x170>)
 8006164:	429a      	cmp	r2, r3
 8006166:	f040 80a5 	bne.w	80062b4 <HAL_SD_MspInit+0x168>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* SDIO clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 800616a:	f503 3386 	add.w	r3, r3, #68608	; 0x10c00
 800616e:	2500      	movs	r5, #0
 8006170:	9501      	str	r5, [sp, #4]
 8006172:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006174:	4852      	ldr	r0, [pc, #328]	; (80062c0 <HAL_SD_MspInit+0x174>)
    __HAL_RCC_SDIO_CLK_ENABLE();
 8006176:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800617a:	645a      	str	r2, [r3, #68]	; 0x44
 800617c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800617e:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8006182:	9201      	str	r2, [sp, #4]
 8006184:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006186:	9502      	str	r5, [sp, #8]
 8006188:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800618a:	f042 0202 	orr.w	r2, r2, #2
 800618e:	631a      	str	r2, [r3, #48]	; 0x30
 8006190:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006192:	f002 0202 	and.w	r2, r2, #2
 8006196:	9202      	str	r2, [sp, #8]
 8006198:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800619a:	9503      	str	r5, [sp, #12]
 800619c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800619e:	f042 0204 	orr.w	r2, r2, #4
 80061a2:	631a      	str	r2, [r3, #48]	; 0x30
 80061a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80061a6:	f002 0204 	and.w	r2, r2, #4
 80061aa:	9203      	str	r2, [sp, #12]
 80061ac:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80061ae:	9504      	str	r5, [sp, #16]
 80061b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80061b2:	f042 0208 	orr.w	r2, r2, #8
 80061b6:	631a      	str	r2, [r3, #48]	; 0x30
 80061b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80061ba:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 80061be:	2703      	movs	r7, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80061c0:	240c      	movs	r4, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80061c2:	f04f 0802 	mov.w	r8, #2
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80061c6:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80061c8:	a905      	add	r1, sp, #20
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80061ca:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80061cc:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 80061ce:	9705      	str	r7, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80061d0:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80061d4:	9708      	str	r7, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80061d6:	f7fa fe1d 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 80061da:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80061de:	a905      	add	r1, sp, #20
 80061e0:	4838      	ldr	r0, [pc, #224]	; (80062c4 <HAL_SD_MspInit+0x178>)
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 80061e2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80061e4:	9409      	str	r4, [sp, #36]	; 0x24

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80061e6:	f04f 0904 	mov.w	r9, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80061ea:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80061ee:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80061f0:	9708      	str	r7, [sp, #32]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80061f2:	f7fa fe0f 	bl	8000e14 <HAL_GPIO_Init>
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80061f6:	4834      	ldr	r0, [pc, #208]	; (80062c8 <HAL_SD_MspInit+0x17c>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80061f8:	9409      	str	r4, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80061fa:	a905      	add	r1, sp, #20

    /* SDIO DMA Init */
    /* SDIO_RX Init */
    hdma_sdio_rx.Instance = DMA2_Stream6;
 80061fc:	4c33      	ldr	r4, [pc, #204]	; (80062cc <HAL_SD_MspInit+0x180>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80061fe:	f8cd 9014 	str.w	r9, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006202:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006206:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006208:	9708      	str	r7, [sp, #32]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800620a:	f7fa fe03 	bl	8000e14 <HAL_GPIO_Init>
    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
 800620e:	4b30      	ldr	r3, [pc, #192]	; (80062d0 <HAL_SD_MspInit+0x184>)
    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8006210:	60a5      	str	r5, [r4, #8]
    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
 8006212:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
 8006216:	e884 4008 	stmia.w	r4, {r3, lr}
    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
 800621a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800621e:	6123      	str	r3, [r4, #16]
    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8006220:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006224:	6163      	str	r3, [r4, #20]
    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8006226:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800622a:	61a3      	str	r3, [r4, #24]
    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
 800622c:	2320      	movs	r3, #32
 800622e:	61e3      	str	r3, [r4, #28]
    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
 8006230:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8006234:	62e3      	str	r3, [r4, #44]	; 0x2c
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
    if (HAL_DMA_Init(&hdma_sdio_rx) != HAL_OK)
 8006236:	4620      	mov	r0, r4
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 8006238:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 800623c:	60e5      	str	r5, [r4, #12]
    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_LOW;
 800623e:	6225      	str	r5, [r4, #32]
    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8006240:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8006244:	62a7      	str	r7, [r4, #40]	; 0x28
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 8006246:	6323      	str	r3, [r4, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_sdio_rx) != HAL_OK)
 8006248:	f7fa fc5c 	bl	8000b04 <HAL_DMA_Init>
 800624c:	b108      	cbz	r0, 8006252 <HAL_SD_MspInit+0x106>
    {
      Error_Handler();
 800624e:	f7ff fe34 	bl	8005eba <Error_Handler>
    __HAL_LINKDMA(sdHandle,hdmarx,hdma_sdio_rx);

    /* SDIO_TX Init */
    hdma_sdio_tx.Instance = DMA2_Stream3;
    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006252:	4b20      	ldr	r3, [pc, #128]	; (80062d4 <HAL_SD_MspInit+0x188>)
    __HAL_LINKDMA(sdHandle,hdmarx,hdma_sdio_rx);
 8006254:	63f4      	str	r4, [r6, #60]	; 0x3c
 8006256:	63a6      	str	r6, [r4, #56]	; 0x38
    hdma_sdio_tx.Instance = DMA2_Stream3;
 8006258:	4c1f      	ldr	r4, [pc, #124]	; (80062d8 <HAL_SD_MspInit+0x18c>)
    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800625a:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
 800625e:	2740      	movs	r7, #64	; 0x40
 8006260:	e884 00a8 	stmia.w	r4, {r3, r5, r7}
    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8006264:	2300      	movs	r3, #0
    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006266:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800626a:	60e3      	str	r3, [r4, #12]
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_LOW;
 800626c:	6223      	str	r3, [r4, #32]
    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 800626e:	2304      	movs	r3, #4
    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006270:	6122      	str	r2, [r4, #16]
    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8006272:	6263      	str	r3, [r4, #36]	; 0x24
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8006274:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8006278:	2303      	movs	r3, #3
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800627a:	6162      	str	r2, [r4, #20]
    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 800627c:	62a3      	str	r3, [r4, #40]	; 0x28
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 800627e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
 8006282:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8006286:	61a2      	str	r2, [r4, #24]
    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
 8006288:	62e3      	str	r3, [r4, #44]	; 0x2c
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
 800628a:	2220      	movs	r2, #32
    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 800628c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    if (HAL_DMA_Init(&hdma_sdio_tx) != HAL_OK)
 8006290:	4620      	mov	r0, r4
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
 8006292:	61e2      	str	r2, [r4, #28]
    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 8006294:	6323      	str	r3, [r4, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_sdio_tx) != HAL_OK)
 8006296:	f7fa fc35 	bl	8000b04 <HAL_DMA_Init>
 800629a:	b108      	cbz	r0, 80062a0 <HAL_SD_MspInit+0x154>
    {
      Error_Handler();
 800629c:	f7ff fe0d 	bl	8005eba <Error_Handler>
    }

    __HAL_LINKDMA(sdHandle,hdmatx,hdma_sdio_tx);

    /* SDIO interrupt Init */
    HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
 80062a0:	2031      	movs	r0, #49	; 0x31
    __HAL_LINKDMA(sdHandle,hdmatx,hdma_sdio_tx);
 80062a2:	6434      	str	r4, [r6, #64]	; 0x40
    HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
 80062a4:	2200      	movs	r2, #0
 80062a6:	2105      	movs	r1, #5
    __HAL_LINKDMA(sdHandle,hdmatx,hdma_sdio_tx);
 80062a8:	63a6      	str	r6, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
 80062aa:	f7fa fbbf 	bl	8000a2c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDIO_IRQn);
 80062ae:	2031      	movs	r0, #49	; 0x31
 80062b0:	f7fa fbf0 	bl	8000a94 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }
}
 80062b4:	b00b      	add	sp, #44	; 0x2c
 80062b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80062ba:	bf00      	nop
 80062bc:	40012c00 	.word	0x40012c00
 80062c0:	40020400 	.word	0x40020400
 80062c4:	40020800 	.word	0x40020800
 80062c8:	40020c00 	.word	0x40020c00
 80062cc:	20004550 	.word	0x20004550
 80062d0:	400264a0 	.word	0x400264a0
 80062d4:	40026458 	.word	0x40026458
 80062d8:	200045b0 	.word	0x200045b0

080062dc <MX_SPI2_Init>:

SPI_HandleTypeDef hspi2;

/* SPI2 init function */
void MX_SPI2_Init(void)
{
 80062dc:	b508      	push	{r3, lr}

  hspi2.Instance = SPI2;
 80062de:	480e      	ldr	r0, [pc, #56]	; (8006318 <MX_SPI2_Init+0x3c>)
  hspi2.Init.Mode = SPI_MODE_MASTER;
 80062e0:	4b0e      	ldr	r3, [pc, #56]	; (800631c <MX_SPI2_Init+0x40>)
 80062e2:	f44f 7e82 	mov.w	lr, #260	; 0x104
 80062e6:	e880 4008 	stmia.w	r0, {r3, lr}
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 80062ea:	2300      	movs	r3, #0
 80062ec:	6083      	str	r3, [r0, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 80062ee:	60c3      	str	r3, [r0, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 80062f0:	6103      	str	r3, [r0, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 80062f2:	6143      	str	r3, [r0, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 80062f4:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80062f8:	61c3      	str	r3, [r0, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80062fa:	6203      	str	r3, [r0, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 80062fc:	6243      	str	r3, [r0, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80062fe:	6283      	str	r3, [r0, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 8006300:	230a      	movs	r3, #10
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8006302:	6182      	str	r2, [r0, #24]
  hspi2.Init.CRCPolynomial = 10;
 8006304:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8006306:	f7fc f957 	bl	80025b8 <HAL_SPI_Init>
 800630a:	b118      	cbz	r0, 8006314 <MX_SPI2_Init+0x38>
  {
    Error_Handler();
  }

}
 800630c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8006310:	f7ff bdd3 	b.w	8005eba <Error_Handler>
 8006314:	bd08      	pop	{r3, pc}
 8006316:	bf00      	nop
 8006318:	20004694 	.word	0x20004694
 800631c:	40003800 	.word	0x40003800

08006320 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8006320:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006322:	4604      	mov	r4, r0
 8006324:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006326:	2214      	movs	r2, #20
 8006328:	2100      	movs	r1, #0
 800632a:	a803      	add	r0, sp, #12
 800632c:	f000 fdc7 	bl	8006ebe <memset>
  if(spiHandle->Instance==SPI2)
 8006330:	6822      	ldr	r2, [r4, #0]
 8006332:	4b1f      	ldr	r3, [pc, #124]	; (80063b0 <HAL_SPI_MspInit+0x90>)
 8006334:	429a      	cmp	r2, r3
 8006336:	d138      	bne.n	80063aa <HAL_SPI_MspInit+0x8a>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* SPI2 clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 8006338:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 800633c:	2400      	movs	r4, #0
 800633e:	9400      	str	r4, [sp, #0]
 8006340:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006342:	481c      	ldr	r0, [pc, #112]	; (80063b4 <HAL_SPI_MspInit+0x94>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 8006344:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8006348:	641a      	str	r2, [r3, #64]	; 0x40
 800634a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800634c:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8006350:	9200      	str	r2, [sp, #0]
 8006352:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006354:	9401      	str	r4, [sp, #4]
 8006356:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006358:	f042 0204 	orr.w	r2, r2, #4
 800635c:	631a      	str	r2, [r3, #48]	; 0x30
 800635e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006360:	f002 0204 	and.w	r2, r2, #4
 8006364:	9201      	str	r2, [sp, #4]
 8006366:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006368:	9402      	str	r4, [sp, #8]
 800636a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800636c:	f042 0202 	orr.w	r2, r2, #2
 8006370:	631a      	str	r2, [r3, #48]	; 0x30
 8006372:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006374:	f003 0302 	and.w	r3, r3, #2
 8006378:	9302      	str	r3, [sp, #8]
 800637a:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 800637c:	230c      	movs	r3, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800637e:	eb0d 0103 	add.w	r1, sp, r3
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006382:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006384:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8006386:	2505      	movs	r5, #5
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8006388:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800638a:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800638c:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800638e:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006390:	f7fa fd40 	bl	8000e14 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13;
 8006394:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006398:	a903      	add	r1, sp, #12
 800639a:	4807      	ldr	r0, [pc, #28]	; (80063b8 <HAL_SPI_MspInit+0x98>)
    GPIO_InitStruct.Pin = GPIO_PIN_13;
 800639c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800639e:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80063a0:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80063a2:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80063a4:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80063a6:	f7fa fd35 	bl	8000e14 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 80063aa:	b009      	add	sp, #36	; 0x24
 80063ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80063ae:	bf00      	nop
 80063b0:	40003800 	.word	0x40003800
 80063b4:	40020800 	.word	0x40020800
 80063b8:	40020400 	.word	0x40020400

080063bc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80063bc:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80063be:	4b0f      	ldr	r3, [pc, #60]	; (80063fc <HAL_MspInit+0x40>)
 80063c0:	2200      	movs	r2, #0
 80063c2:	9200      	str	r2, [sp, #0]
 80063c4:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80063c6:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 80063ca:	6459      	str	r1, [r3, #68]	; 0x44
 80063cc:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80063ce:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 80063d2:	9100      	str	r1, [sp, #0]
 80063d4:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80063d6:	9201      	str	r2, [sp, #4]
 80063d8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80063da:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80063de:	6419      	str	r1, [r3, #64]	; 0x40
 80063e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80063e2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80063e6:	9301      	str	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80063e8:	210f      	movs	r1, #15
 80063ea:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 80063ee:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80063f0:	f7fa fb1c 	bl	8000a2c <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80063f4:	b003      	add	sp, #12
 80063f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80063fa:	bf00      	nop
 80063fc:	40023800 	.word	0x40023800

08006400 <NMI_Handler>:
 8006400:	4770      	bx	lr

08006402 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8006402:	e7fe      	b.n	8006402 <HardFault_Handler>

08006404 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8006404:	e7fe      	b.n	8006404 <MemManage_Handler>

08006406 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8006406:	e7fe      	b.n	8006406 <BusFault_Handler>

08006408 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8006408:	e7fe      	b.n	8006408 <UsageFault_Handler>

0800640a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800640a:	4770      	bx	lr

0800640c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800640c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800640e:	f7fa f8c5 	bl	800059c <HAL_IncTick>
  osSystickHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8006412:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osSystickHandler();
 8006416:	f7fd bc73 	b.w	8003d00 <osSystickHandler>
	...

0800641c <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_rx);
 800641c:	4801      	ldr	r0, [pc, #4]	; (8006424 <DMA1_Stream1_IRQHandler+0x8>)
 800641e:	f7fa bc3f 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 8006422:	bf00      	nop
 8006424:	20004818 	.word	0x20004818

08006428 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */

  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c3_rx);
 8006428:	4801      	ldr	r0, [pc, #4]	; (8006430 <DMA1_Stream2_IRQHandler+0x8>)
 800642a:	f7fa bc39 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 800642e:	bf00      	nop
 8006430:	200044a4 	.word	0x200044a4

08006434 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream4_IRQn 0 */

  /* USER CODE END DMA1_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_tx);
 8006434:	4801      	ldr	r0, [pc, #4]	; (800643c <DMA1_Stream4_IRQHandler+0x8>)
 8006436:	f7fa bc33 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 800643a:	bf00      	nop
 800643c:	200048b8 	.word	0x200048b8

08006440 <SDIO_IRQHandler>:
void SDIO_IRQHandler(void)
{
  /* USER CODE BEGIN SDIO_IRQn 0 */

  /* USER CODE END SDIO_IRQn 0 */
  HAL_SD_IRQHandler(&hsd);
 8006440:	4801      	ldr	r0, [pc, #4]	; (8006448 <SDIO_IRQHandler+0x8>)
 8006442:	f7fb bfe5 	b.w	8002410 <HAL_SD_IRQHandler>
 8006446:	bf00      	nop
 8006448:	20004610 	.word	0x20004610

0800644c <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_tx);
 800644c:	4801      	ldr	r0, [pc, #4]	; (8006454 <DMA2_Stream3_IRQHandler+0x8>)
 800644e:	f7fa bc27 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 8006452:	bf00      	nop
 8006454:	200045b0 	.word	0x200045b0

08006458 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_rx);
 8006458:	4801      	ldr	r0, [pc, #4]	; (8006460 <DMA2_Stream6_IRQHandler+0x8>)
 800645a:	f7fa bc21 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 800645e:	bf00      	nop
 8006460:	20004550 	.word	0x20004550

08006464 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006464:	490f      	ldr	r1, [pc, #60]	; (80064a4 <SystemInit+0x40>)
 8006466:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800646a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800646e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8006472:	4b0d      	ldr	r3, [pc, #52]	; (80064a8 <SystemInit+0x44>)
 8006474:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8006476:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8006478:	f042 0201 	orr.w	r2, r2, #1
 800647c:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 800647e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006480:	681a      	ldr	r2, [r3, #0]
 8006482:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8006486:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800648a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800648c:	4a07      	ldr	r2, [pc, #28]	; (80064ac <SystemInit+0x48>)
 800648e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8006490:	681a      	ldr	r2, [r3, #0]
 8006492:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006496:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8006498:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800649a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800649e:	608b      	str	r3, [r1, #8]
 80064a0:	4770      	bx	lr
 80064a2:	bf00      	nop
 80064a4:	e000ed00 	.word	0xe000ed00
 80064a8:	40023800 	.word	0x40023800
 80064ac:	24003010 	.word	0x24003010

080064b0 <MX_TIM3_Init>:
  HAL_TIM_MspPostInit(&htim2);

}
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 80064b0:	b510      	push	{r4, lr}
 80064b2:	b08c      	sub	sp, #48	; 0x30
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80064b4:	2400      	movs	r4, #0
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 80064b6:	2214      	movs	r2, #20
 80064b8:	2100      	movs	r1, #0
 80064ba:	a807      	add	r0, sp, #28
 80064bc:	f000 fcff 	bl	8006ebe <memset>
  TIM_IC_InitTypeDef sConfigIC = {0};
 80064c0:	2210      	movs	r2, #16
 80064c2:	4621      	mov	r1, r4
 80064c4:	a803      	add	r0, sp, #12
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80064c6:	9401      	str	r4, [sp, #4]
 80064c8:	9402      	str	r4, [sp, #8]
  TIM_IC_InitTypeDef sConfigIC = {0};
 80064ca:	f000 fcf8 	bl	8006ebe <memset>

  htim3.Instance = TIM3;
 80064ce:	481c      	ldr	r0, [pc, #112]	; (8006540 <MX_TIM3_Init+0x90>)
 80064d0:	4b1c      	ldr	r3, [pc, #112]	; (8006544 <MX_TIM3_Init+0x94>)
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80064d2:	6084      	str	r4, [r0, #8]
  htim3.Init.Prescaler = 0;
 80064d4:	e880 0018 	stmia.w	r0, {r3, r4}
  htim3.Init.Period = 0;
 80064d8:	60c4      	str	r4, [r0, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80064da:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 80064dc:	f7fc fac2 	bl	8002a64 <HAL_TIM_Base_Init>
 80064e0:	b108      	cbz	r0, 80064e6 <MX_TIM3_Init+0x36>
  {
    Error_Handler();
 80064e2:	f7ff fcea 	bl	8005eba <Error_Handler>
  }
  if (HAL_TIM_IC_Init(&htim3) != HAL_OK)
 80064e6:	4816      	ldr	r0, [pc, #88]	; (8006540 <MX_TIM3_Init+0x90>)
 80064e8:	f7fc faf0 	bl	8002acc <HAL_TIM_IC_Init>
 80064ec:	b108      	cbz	r0, 80064f2 <MX_TIM3_Init+0x42>
  {
    Error_Handler();
 80064ee:	f7ff fce4 	bl	8005eba <Error_Handler>
  }
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
 80064f2:	2307      	movs	r3, #7
  sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
  sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING;
 80064f4:	2400      	movs	r4, #0
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
 80064f6:	9307      	str	r3, [sp, #28]
  sSlaveConfig.TriggerFilter = 0;
  if (HAL_TIM_SlaveConfigSynchronization(&htim3, &sSlaveConfig) != HAL_OK)
 80064f8:	a907      	add	r1, sp, #28
  sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
 80064fa:	2350      	movs	r3, #80	; 0x50
  if (HAL_TIM_SlaveConfigSynchronization(&htim3, &sSlaveConfig) != HAL_OK)
 80064fc:	4810      	ldr	r0, [pc, #64]	; (8006540 <MX_TIM3_Init+0x90>)
  sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
 80064fe:	9308      	str	r3, [sp, #32]
  sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING;
 8006500:	9409      	str	r4, [sp, #36]	; 0x24
  sSlaveConfig.TriggerFilter = 0;
 8006502:	940b      	str	r4, [sp, #44]	; 0x2c
  if (HAL_TIM_SlaveConfigSynchronization(&htim3, &sSlaveConfig) != HAL_OK)
 8006504:	f7fc fa2a 	bl	800295c <HAL_TIM_SlaveConfigSynchronization>
 8006508:	b108      	cbz	r0, 800650e <MX_TIM3_Init+0x5e>
  {
    Error_Handler();
 800650a:	f7ff fcd6 	bl	8005eba <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 800650e:	a901      	add	r1, sp, #4
 8006510:	480b      	ldr	r0, [pc, #44]	; (8006540 <MX_TIM3_Init+0x90>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006512:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006514:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8006516:	f7fc fc13 	bl	8002d40 <HAL_TIMEx_MasterConfigSynchronization>
 800651a:	b108      	cbz	r0, 8006520 <MX_TIM3_Init+0x70>
  {
    Error_Handler();
 800651c:	f7ff fccd 	bl	8005eba <Error_Handler>
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 8006520:	2201      	movs	r2, #1
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 8006522:	2300      	movs	r3, #0
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 8006524:	9204      	str	r2, [sp, #16]
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim3, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
 8006526:	a903      	add	r1, sp, #12
 8006528:	2204      	movs	r2, #4
 800652a:	4805      	ldr	r0, [pc, #20]	; (8006540 <MX_TIM3_Init+0x90>)
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 800652c:	9303      	str	r3, [sp, #12]
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
 800652e:	9305      	str	r3, [sp, #20]
  sConfigIC.ICFilter = 0;
 8006530:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_IC_ConfigChannel(&htim3, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
 8006532:	f7fc fb1f 	bl	8002b74 <HAL_TIM_IC_ConfigChannel>
 8006536:	b108      	cbz	r0, 800653c <MX_TIM3_Init+0x8c>
  {
    Error_Handler();
 8006538:	f7ff fcbf 	bl	8005eba <Error_Handler>
  }

}
 800653c:	b00c      	add	sp, #48	; 0x30
 800653e:	bd10      	pop	{r4, pc}
 8006540:	20004764 	.word	0x20004764
 8006544:	40000400 	.word	0x40000400

08006548 <MX_TIM8_Init>:
  HAL_TIM_MspPostInit(&htim5);

}
/* TIM8 init function */
void MX_TIM8_Init(void)
{
 8006548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800654c:	b09c      	sub	sp, #112	; 0x70
  LL_TIM_InitTypeDef TIM_InitStruct = {0};
 800654e:	2214      	movs	r2, #20
 8006550:	2100      	movs	r1, #0
 8006552:	a803      	add	r0, sp, #12
 8006554:	f000 fcb3 	bl	8006ebe <memset>
  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
  LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
 8006558:	2418      	movs	r4, #24
  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
 800655a:	2220      	movs	r2, #32
 800655c:	2100      	movs	r1, #0
 800655e:	a814      	add	r0, sp, #80	; 0x50
  SET_BIT(RCC->APB2ENR, Periphs);
 8006560:	4e50      	ldr	r6, [pc, #320]	; (80066a4 <MX_TIM8_Init+0x15c>)
  TIM_InitStruct.Prescaler = 1;
  TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
  TIM_InitStruct.Autoreload = LED_TIM_ARR;
  TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
  TIM_InitStruct.RepetitionCounter = 0;
  LL_TIM_Init(TIM8, &TIM_InitStruct);
 8006562:	4d51      	ldr	r5, [pc, #324]	; (80066a8 <MX_TIM8_Init+0x160>)
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8006564:	4f51      	ldr	r7, [pc, #324]	; (80066ac <MX_TIM8_Init+0x164>)
  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
 8006566:	f000 fcaa 	bl	8006ebe <memset>
  LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
 800656a:	4622      	mov	r2, r4
 800656c:	2100      	movs	r1, #0
 800656e:	a808      	add	r0, sp, #32
 8006570:	f000 fca5 	bl	8006ebe <memset>
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006574:	4622      	mov	r2, r4
 8006576:	2100      	movs	r1, #0
 8006578:	a80e      	add	r0, sp, #56	; 0x38
 800657a:	f000 fca0 	bl	8006ebe <memset>
 800657e:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8006580:	f043 0302 	orr.w	r3, r3, #2
 8006584:	6473      	str	r3, [r6, #68]	; 0x44
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8006586:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8006588:	f003 0302 	and.w	r3, r3, #2
 800658c:	9302      	str	r3, [sp, #8]
  TIM_InitStruct.Prescaler = 1;
 800658e:	f04f 0801 	mov.w	r8, #1
  (void)tmpreg;
 8006592:	9b02      	ldr	r3, [sp, #8]
 8006594:	f8ad 800c 	strh.w	r8, [sp, #12]
  TIM_InitStruct.Autoreload = LED_TIM_ARR;
 8006598:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  LL_TIM_Init(TIM8, &TIM_InitStruct);
 800659c:	a903      	add	r1, sp, #12
 800659e:	4628      	mov	r0, r5
  TIM_InitStruct.Autoreload = LED_TIM_ARR;
 80065a0:	9305      	str	r3, [sp, #20]
  LL_TIM_Init(TIM8, &TIM_InitStruct);
 80065a2:	f7fd f997 	bl	80038d4 <LL_TIM_Init>
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
 80065a6:	68ab      	ldr	r3, [r5, #8]
 80065a8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80065ac:	f023 0307 	bic.w	r3, r3, #7
 80065b0:	60ab      	str	r3, [r5, #8]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 80065b2:	69ab      	ldr	r3, [r5, #24]
 80065b4:	f043 0308 	orr.w	r3, r3, #8
  LL_TIM_SetClockSource(TIM8, LL_TIM_CLOCKSOURCE_INTERNAL);
  LL_TIM_OC_EnablePreload(TIM8, LL_TIM_CHANNEL_CH1);
  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 80065b8:	2400      	movs	r4, #0
 80065ba:	61ab      	str	r3, [r5, #24]
  TIM_OC_InitStruct.CompareValue = 0;
  TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
  TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
  TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
  TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
 80065bc:	aa14      	add	r2, sp, #80	; 0x50
  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
 80065be:	2370      	movs	r3, #112	; 0x70
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
 80065c0:	4641      	mov	r1, r8
 80065c2:	4628      	mov	r0, r5
  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
 80065c4:	9314      	str	r3, [sp, #80]	; 0x50
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 80065c6:	9415      	str	r4, [sp, #84]	; 0x54
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
 80065c8:	9416      	str	r4, [sp, #88]	; 0x58
  TIM_OC_InitStruct.CompareValue = 0;
 80065ca:	9417      	str	r4, [sp, #92]	; 0x5c
  TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
 80065cc:	9418      	str	r4, [sp, #96]	; 0x60
  TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
 80065ce:	9419      	str	r4, [sp, #100]	; 0x64
  TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
 80065d0:	941a      	str	r4, [sp, #104]	; 0x68
  TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
 80065d2:	941b      	str	r4, [sp, #108]	; 0x6c
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
 80065d4:	f7fd f9e2 	bl	800399c <LL_TIM_OC_Init>
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
 80065d8:	69ab      	ldr	r3, [r5, #24]
 80065da:	f023 0304 	bic.w	r3, r3, #4
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 80065de:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80065e2:	61ab      	str	r3, [r5, #24]
  LL_TIM_OC_DisableFast(TIM8, LL_TIM_CHANNEL_CH1);
  LL_TIM_OC_EnablePreload(TIM8, LL_TIM_CHANNEL_CH2);
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH2, &TIM_OC_InitStruct);
 80065e4:	aa14      	add	r2, sp, #80	; 0x50
 80065e6:	2110      	movs	r1, #16
 80065e8:	4628      	mov	r0, r5
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 80065ea:	9415      	str	r4, [sp, #84]	; 0x54
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
 80065ec:	9416      	str	r4, [sp, #88]	; 0x58
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH2, &TIM_OC_InitStruct);
 80065ee:	f7fd f9d5 	bl	800399c <LL_TIM_OC_Init>
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
 80065f2:	69ab      	ldr	r3, [r5, #24]
 80065f4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80065f8:	61ab      	str	r3, [r5, #24]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 80065fa:	687b      	ldr	r3, [r7, #4]
  LL_TIM_OC_DisableFast(TIM8, LL_TIM_CHANNEL_CH2);
  LL_TIM_OC_EnablePreload(TIM8, LL_TIM_CHANNEL_CH3);
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 80065fc:	9415      	str	r4, [sp, #84]	; 0x54
 80065fe:	f043 0308 	orr.w	r3, r3, #8
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
 8006602:	aa14      	add	r2, sp, #80	; 0x50
 8006604:	607b      	str	r3, [r7, #4]
 8006606:	f44f 7180 	mov.w	r1, #256	; 0x100
 800660a:	4628      	mov	r0, r5
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
 800660c:	9416      	str	r4, [sp, #88]	; 0x58
  LL_TIM_OC_Init(TIM8, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
 800660e:	f7fd f9c5 	bl	800399c <LL_TIM_OC_Init>
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
 8006612:	687b      	ldr	r3, [r7, #4]
 8006614:	f023 0304 	bic.w	r3, r3, #4
 8006618:	607b      	str	r3, [r7, #4]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800661a:	686b      	ldr	r3, [r5, #4]
 800661c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006620:	606b      	str	r3, [r5, #4]
  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
 8006622:	68ab      	ldr	r3, [r5, #8]
 8006624:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006628:	60ab      	str	r3, [r5, #8]
  TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
  TIM_BDTRInitStruct.DeadTime = 0;
  TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
  TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
  TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
  LL_TIM_BDTR_Init(TIM8, &TIM_BDTRInitStruct);
 800662a:	a908      	add	r1, sp, #32
  TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
 800662c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  LL_TIM_BDTR_Init(TIM8, &TIM_BDTRInitStruct);
 8006630:	4628      	mov	r0, r5
  TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
 8006632:	930c      	str	r3, [sp, #48]	; 0x30
  TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
 8006634:	9408      	str	r4, [sp, #32]
  TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
 8006636:	9409      	str	r4, [sp, #36]	; 0x24
  TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
 8006638:	940a      	str	r4, [sp, #40]	; 0x28
  TIM_BDTRInitStruct.DeadTime = 0;
 800663a:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
  TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
 800663e:	f8ad 402e 	strh.w	r4, [sp, #46]	; 0x2e
  TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
 8006642:	940d      	str	r4, [sp, #52]	; 0x34
  LL_TIM_BDTR_Init(TIM8, &TIM_BDTRInitStruct);
 8006644:	f7fd fa82 	bl	8003b4c <LL_TIM_BDTR_Init>
  SET_BIT(RCC->AHB1ENR, Periphs);
 8006648:	6b33      	ldr	r3, [r6, #48]	; 0x30
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_3;
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800664a:	4819      	ldr	r0, [pc, #100]	; (80066b0 <MX_TIM8_Init+0x168>)
 800664c:	ea43 0308 	orr.w	r3, r3, r8
 8006650:	6333      	str	r3, [r6, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8006652:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8006654:	ea03 0308 	and.w	r3, r3, r8
 8006658:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800665a:	9b01      	ldr	r3, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 800665c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800665e:	f043 0302 	orr.w	r3, r3, #2
 8006662:	6333      	str	r3, [r6, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8006664:	6b33      	ldr	r3, [r6, #48]	; 0x30
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8006666:	9410      	str	r4, [sp, #64]	; 0x40
 8006668:	f003 0302 	and.w	r3, r3, #2
 800666c:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800666e:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8006670:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Pin = LL_GPIO_PIN_7;
 8006672:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8006674:	2602      	movs	r6, #2
  GPIO_InitStruct.Alternate = LL_GPIO_AF_3;
 8006676:	2503      	movs	r5, #3
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006678:	a90e      	add	r1, sp, #56	; 0x38
  GPIO_InitStruct.Pin = LL_GPIO_PIN_7;
 800667a:	930e      	str	r3, [sp, #56]	; 0x38
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 800667c:	960f      	str	r6, [sp, #60]	; 0x3c
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800667e:	9412      	str	r4, [sp, #72]	; 0x48
  GPIO_InitStruct.Alternate = LL_GPIO_AF_3;
 8006680:	9513      	str	r5, [sp, #76]	; 0x4c
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006682:	f7fc fd4d 	bl	8003120 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_14|LL_GPIO_PIN_15;
 8006686:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_3;
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800668a:	a90e      	add	r1, sp, #56	; 0x38
 800668c:	4809      	ldr	r0, [pc, #36]	; (80066b4 <MX_TIM8_Init+0x16c>)
  GPIO_InitStruct.Pin = LL_GPIO_PIN_14|LL_GPIO_PIN_15;
 800668e:	930e      	str	r3, [sp, #56]	; 0x38
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8006690:	960f      	str	r6, [sp, #60]	; 0x3c
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8006692:	9410      	str	r4, [sp, #64]	; 0x40
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8006694:	9411      	str	r4, [sp, #68]	; 0x44
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8006696:	9412      	str	r4, [sp, #72]	; 0x48
  GPIO_InitStruct.Alternate = LL_GPIO_AF_3;
 8006698:	9513      	str	r5, [sp, #76]	; 0x4c
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800669a:	f7fc fd41 	bl	8003120 <LL_GPIO_Init>

}
 800669e:	b01c      	add	sp, #112	; 0x70
 80066a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80066a4:	40023800 	.word	0x40023800
 80066a8:	40010400 	.word	0x40010400
 80066ac:	40010418 	.word	0x40010418
 80066b0:	40020000 	.word	0x40020000
 80066b4:	40020400 	.word	0x40020400

080066b8 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 80066b8:	b530      	push	{r4, r5, lr}
 80066ba:	4604      	mov	r4, r0
 80066bc:	b08d      	sub	sp, #52	; 0x34

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80066be:	2214      	movs	r2, #20
 80066c0:	2100      	movs	r1, #0
 80066c2:	a807      	add	r0, sp, #28
 80066c4:	f000 fbfb 	bl	8006ebe <memset>
  if(tim_baseHandle->Instance==TIM1)
 80066c8:	6823      	ldr	r3, [r4, #0]
 80066ca:	4a3c      	ldr	r2, [pc, #240]	; (80067bc <HAL_TIM_Base_MspInit+0x104>)
 80066cc:	4293      	cmp	r3, r2
 80066ce:	d10d      	bne.n	80066ec <HAL_TIM_Base_MspInit+0x34>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 80066d0:	2300      	movs	r3, #0
 80066d2:	9300      	str	r3, [sp, #0]
 80066d4:	4b3a      	ldr	r3, [pc, #232]	; (80067c0 <HAL_TIM_Base_MspInit+0x108>)
 80066d6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80066d8:	f042 0201 	orr.w	r2, r2, #1
 80066dc:	645a      	str	r2, [r3, #68]	; 0x44
 80066de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80066e0:	f003 0301 	and.w	r3, r3, #1
 80066e4:	9300      	str	r3, [sp, #0]
 80066e6:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_TIM5_CLK_ENABLE();
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}
 80066e8:	b00d      	add	sp, #52	; 0x34
 80066ea:	bd30      	pop	{r4, r5, pc}
  else if(tim_baseHandle->Instance==TIM2)
 80066ec:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80066f0:	d10c      	bne.n	800670c <HAL_TIM_Base_MspInit+0x54>
    __HAL_RCC_TIM2_CLK_ENABLE();
 80066f2:	2300      	movs	r3, #0
 80066f4:	9301      	str	r3, [sp, #4]
 80066f6:	4b32      	ldr	r3, [pc, #200]	; (80067c0 <HAL_TIM_Base_MspInit+0x108>)
 80066f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80066fa:	f042 0201 	orr.w	r2, r2, #1
 80066fe:	641a      	str	r2, [r3, #64]	; 0x40
 8006700:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006702:	f003 0301 	and.w	r3, r3, #1
 8006706:	9301      	str	r3, [sp, #4]
 8006708:	9b01      	ldr	r3, [sp, #4]
 800670a:	e7ed      	b.n	80066e8 <HAL_TIM_Base_MspInit+0x30>
  else if(tim_baseHandle->Instance==TIM3)
 800670c:	4a2d      	ldr	r2, [pc, #180]	; (80067c4 <HAL_TIM_Base_MspInit+0x10c>)
 800670e:	4293      	cmp	r3, r2
 8006710:	d133      	bne.n	800677a <HAL_TIM_Base_MspInit+0xc2>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8006712:	4b2b      	ldr	r3, [pc, #172]	; (80067c0 <HAL_TIM_Base_MspInit+0x108>)
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006714:	482c      	ldr	r0, [pc, #176]	; (80067c8 <HAL_TIM_Base_MspInit+0x110>)
    __HAL_RCC_TIM3_CLK_ENABLE();
 8006716:	2400      	movs	r4, #0
 8006718:	9402      	str	r4, [sp, #8]
 800671a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800671c:	f042 0202 	orr.w	r2, r2, #2
 8006720:	641a      	str	r2, [r3, #64]	; 0x40
 8006722:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006724:	f002 0202 	and.w	r2, r2, #2
 8006728:	9202      	str	r2, [sp, #8]
 800672a:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800672c:	9403      	str	r4, [sp, #12]
 800672e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006730:	f042 0201 	orr.w	r2, r2, #1
 8006734:	631a      	str	r2, [r3, #48]	; 0x30
 8006736:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006738:	f002 0201 	and.w	r2, r2, #1
 800673c:	9203      	str	r2, [sp, #12]
 800673e:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006740:	9404      	str	r4, [sp, #16]
 8006742:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006744:	f042 0202 	orr.w	r2, r2, #2
 8006748:	631a      	str	r2, [r3, #48]	; 0x30
 800674a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800674c:	f003 0302 	and.w	r3, r3, #2
 8006750:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006752:	2502      	movs	r5, #2
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006754:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006756:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8006758:	2340      	movs	r3, #64	; 0x40
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800675a:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 800675c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 800675e:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006760:	f7fa fb58 	bl	8000e14 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 8006764:	2320      	movs	r3, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006766:	a907      	add	r1, sp, #28
 8006768:	4818      	ldr	r0, [pc, #96]	; (80067cc <HAL_TIM_Base_MspInit+0x114>)
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 800676a:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800676c:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800676e:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8006770:	940a      	str	r4, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8006772:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006774:	f7fa fb4e 	bl	8000e14 <HAL_GPIO_Init>
 8006778:	e7b6      	b.n	80066e8 <HAL_TIM_Base_MspInit+0x30>
  else if(tim_baseHandle->Instance==TIM4)
 800677a:	4a15      	ldr	r2, [pc, #84]	; (80067d0 <HAL_TIM_Base_MspInit+0x118>)
 800677c:	4293      	cmp	r3, r2
 800677e:	d10c      	bne.n	800679a <HAL_TIM_Base_MspInit+0xe2>
    __HAL_RCC_TIM4_CLK_ENABLE();
 8006780:	2300      	movs	r3, #0
 8006782:	9305      	str	r3, [sp, #20]
 8006784:	4b0e      	ldr	r3, [pc, #56]	; (80067c0 <HAL_TIM_Base_MspInit+0x108>)
 8006786:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006788:	f042 0204 	orr.w	r2, r2, #4
 800678c:	641a      	str	r2, [r3, #64]	; 0x40
 800678e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006790:	f003 0304 	and.w	r3, r3, #4
 8006794:	9305      	str	r3, [sp, #20]
 8006796:	9b05      	ldr	r3, [sp, #20]
 8006798:	e7a6      	b.n	80066e8 <HAL_TIM_Base_MspInit+0x30>
  else if(tim_baseHandle->Instance==TIM5)
 800679a:	4a0e      	ldr	r2, [pc, #56]	; (80067d4 <HAL_TIM_Base_MspInit+0x11c>)
 800679c:	4293      	cmp	r3, r2
 800679e:	d1a3      	bne.n	80066e8 <HAL_TIM_Base_MspInit+0x30>
    __HAL_RCC_TIM5_CLK_ENABLE();
 80067a0:	2300      	movs	r3, #0
 80067a2:	9306      	str	r3, [sp, #24]
 80067a4:	4b06      	ldr	r3, [pc, #24]	; (80067c0 <HAL_TIM_Base_MspInit+0x108>)
 80067a6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80067a8:	f042 0208 	orr.w	r2, r2, #8
 80067ac:	641a      	str	r2, [r3, #64]	; 0x40
 80067ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80067b0:	f003 0308 	and.w	r3, r3, #8
 80067b4:	9306      	str	r3, [sp, #24]
 80067b6:	9b06      	ldr	r3, [sp, #24]
}
 80067b8:	e796      	b.n	80066e8 <HAL_TIM_Base_MspInit+0x30>
 80067ba:	bf00      	nop
 80067bc:	40010000 	.word	0x40010000
 80067c0:	40023800 	.word	0x40023800
 80067c4:	40000400 	.word	0x40000400
 80067c8:	40020000 	.word	0x40020000
 80067cc:	40020400 	.word	0x40020400
 80067d0:	40000800 	.word	0x40000800
 80067d4:	40000c00 	.word	0x40000c00

080067d8 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 80067d8:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80067da:	2214      	movs	r2, #20
{
 80067dc:	b08a      	sub	sp, #40	; 0x28
 80067de:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80067e0:	2100      	movs	r1, #0
 80067e2:	eb0d 0002 	add.w	r0, sp, r2
 80067e6:	f000 fb6a 	bl	8006ebe <memset>
  if(timHandle->Instance==TIM1)
 80067ea:	6823      	ldr	r3, [r4, #0]
 80067ec:	4a39      	ldr	r2, [pc, #228]	; (80068d4 <HAL_TIM_MspPostInit+0xfc>)
 80067ee:	4293      	cmp	r3, r2
 80067f0:	d115      	bne.n	800681e <HAL_TIM_MspPostInit+0x46>
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80067f2:	2300      	movs	r3, #0
 80067f4:	9300      	str	r3, [sp, #0]
 80067f6:	4b38      	ldr	r3, [pc, #224]	; (80068d8 <HAL_TIM_MspPostInit+0x100>)
 80067f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80067fa:	f042 0201 	orr.w	r2, r2, #1
 80067fe:	631a      	str	r2, [r3, #48]	; 0x30
 8006800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006802:	f003 0301 	and.w	r3, r3, #1
 8006806:	9300      	str	r3, [sp, #0]
 8006808:	9b00      	ldr	r3, [sp, #0]
    /**TIM1 GPIO Configuration    
    PA11     ------> TIM1_CH4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 800680a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800680e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006810:	2302      	movs	r3, #2
 8006812:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8006814:	2301      	movs	r3, #1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8006816:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006818:	a905      	add	r1, sp, #20
 800681a:	4830      	ldr	r0, [pc, #192]	; (80068dc <HAL_TIM_MspPostInit+0x104>)
 800681c:	e02d      	b.n	800687a <HAL_TIM_MspPostInit+0xa2>
  else if(timHandle->Instance==TIM2)
 800681e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006822:	d12e      	bne.n	8006882 <HAL_TIM_MspPostInit+0xaa>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006824:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8006828:	2400      	movs	r4, #0
 800682a:	9401      	str	r4, [sp, #4]
 800682c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800682e:	482b      	ldr	r0, [pc, #172]	; (80068dc <HAL_TIM_MspPostInit+0x104>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006830:	f042 0201 	orr.w	r2, r2, #1
 8006834:	631a      	str	r2, [r3, #48]	; 0x30
 8006836:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006838:	f002 0201 	and.w	r2, r2, #1
 800683c:	9201      	str	r2, [sp, #4]
 800683e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006840:	9402      	str	r4, [sp, #8]
 8006842:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006844:	f042 0202 	orr.w	r2, r2, #2
 8006848:	631a      	str	r2, [r3, #48]	; 0x30
 800684a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800684c:	f003 0302 	and.w	r3, r3, #2
 8006850:	9302      	str	r3, [sp, #8]
 8006852:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006854:	2602      	movs	r6, #2
    GPIO_InitStruct.Pin = GPIO_PIN_15;
 8006856:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800685a:	2501      	movs	r5, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800685c:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Pin = GPIO_PIN_15;
 800685e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006860:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8006862:	9509      	str	r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006864:	f7fa fad6 	bl	8000e14 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8006868:	f44f 7300 	mov.w	r3, #512	; 0x200
 800686c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800686e:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006870:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8006872:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8006874:	9509      	str	r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006876:	481a      	ldr	r0, [pc, #104]	; (80068e0 <HAL_TIM_MspPostInit+0x108>)
 8006878:	a905      	add	r1, sp, #20
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800687a:	f7fa facb 	bl	8000e14 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM5_MspPostInit 1 */

  /* USER CODE END TIM5_MspPostInit 1 */
  }

}
 800687e:	b00a      	add	sp, #40	; 0x28
 8006880:	bd70      	pop	{r4, r5, r6, pc}
  else if(timHandle->Instance==TIM4)
 8006882:	4a18      	ldr	r2, [pc, #96]	; (80068e4 <HAL_TIM_MspPostInit+0x10c>)
 8006884:	4293      	cmp	r3, r2
 8006886:	d111      	bne.n	80068ac <HAL_TIM_MspPostInit+0xd4>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006888:	2300      	movs	r3, #0
 800688a:	9303      	str	r3, [sp, #12]
 800688c:	4b12      	ldr	r3, [pc, #72]	; (80068d8 <HAL_TIM_MspPostInit+0x100>)
 800688e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006890:	f042 0202 	orr.w	r2, r2, #2
 8006894:	631a      	str	r2, [r3, #48]	; 0x30
 8006896:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006898:	f003 0302 	and.w	r3, r3, #2
 800689c:	9303      	str	r3, [sp, #12]
 800689e:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_7;
 80068a0:	2380      	movs	r3, #128	; 0x80
 80068a2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80068a4:	2302      	movs	r3, #2
 80068a6:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 80068a8:	9309      	str	r3, [sp, #36]	; 0x24
 80068aa:	e7e4      	b.n	8006876 <HAL_TIM_MspPostInit+0x9e>
  else if(timHandle->Instance==TIM5)
 80068ac:	4a0e      	ldr	r2, [pc, #56]	; (80068e8 <HAL_TIM_MspPostInit+0x110>)
 80068ae:	4293      	cmp	r3, r2
 80068b0:	d1e5      	bne.n	800687e <HAL_TIM_MspPostInit+0xa6>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80068b2:	2300      	movs	r3, #0
 80068b4:	9304      	str	r3, [sp, #16]
 80068b6:	4b08      	ldr	r3, [pc, #32]	; (80068d8 <HAL_TIM_MspPostInit+0x100>)
 80068b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80068ba:	f042 0201 	orr.w	r2, r2, #1
 80068be:	631a      	str	r2, [r3, #48]	; 0x30
 80068c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068c2:	f003 0301 	and.w	r3, r3, #1
 80068c6:	9304      	str	r3, [sp, #16]
 80068c8:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 80068ca:	2303      	movs	r3, #3
 80068cc:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80068ce:	2302      	movs	r3, #2
 80068d0:	9306      	str	r3, [sp, #24]
 80068d2:	e7a0      	b.n	8006816 <HAL_TIM_MspPostInit+0x3e>
 80068d4:	40010000 	.word	0x40010000
 80068d8:	40023800 	.word	0x40023800
 80068dc:	40020000 	.word	0x40020000
 80068e0:	40020400 	.word	0x40020400
 80068e4:	40000800 	.word	0x40000800
 80068e8:	40000c00 	.word	0x40000c00

080068ec <MX_TIM1_Init>:
{
 80068ec:	b510      	push	{r4, lr}
 80068ee:	b094      	sub	sp, #80	; 0x50
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80068f0:	2400      	movs	r4, #0
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 80068f2:	2210      	movs	r2, #16
 80068f4:	2100      	movs	r1, #0
 80068f6:	a802      	add	r0, sp, #8
 80068f8:	f000 fae1 	bl	8006ebe <memset>
  TIM_OC_InitTypeDef sConfigOC = {0};
 80068fc:	221c      	movs	r2, #28
 80068fe:	4621      	mov	r1, r4
 8006900:	a806      	add	r0, sp, #24
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006902:	9400      	str	r4, [sp, #0]
 8006904:	9401      	str	r4, [sp, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006906:	f000 fada 	bl	8006ebe <memset>
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 800690a:	221c      	movs	r2, #28
 800690c:	4621      	mov	r1, r4
 800690e:	a80d      	add	r0, sp, #52	; 0x34
 8006910:	f000 fad5 	bl	8006ebe <memset>
  htim1.Instance = TIM1;
 8006914:	4825      	ldr	r0, [pc, #148]	; (80069ac <MX_TIM1_Init+0xc0>)
 8006916:	4b26      	ldr	r3, [pc, #152]	; (80069b0 <MX_TIM1_Init+0xc4>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006918:	6084      	str	r4, [r0, #8]
  htim1.Init.Prescaler = 0;
 800691a:	e880 0018 	stmia.w	r0, {r3, r4}
  htim1.Init.Period = 0;
 800691e:	60c4      	str	r4, [r0, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8006920:	6104      	str	r4, [r0, #16]
  htim1.Init.RepetitionCounter = 0;
 8006922:	6144      	str	r4, [r0, #20]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8006924:	f7fc f89e 	bl	8002a64 <HAL_TIM_Base_Init>
 8006928:	b108      	cbz	r0, 800692e <MX_TIM1_Init+0x42>
    Error_Handler();
 800692a:	f7ff fac6 	bl	8005eba <Error_Handler>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800692e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8006932:	a902      	add	r1, sp, #8
 8006934:	481d      	ldr	r0, [pc, #116]	; (80069ac <MX_TIM1_Init+0xc0>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8006936:	9302      	str	r3, [sp, #8]
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8006938:	f7fb ff57 	bl	80027ea <HAL_TIM_ConfigClockSource>
 800693c:	b108      	cbz	r0, 8006942 <MX_TIM1_Init+0x56>
    Error_Handler();
 800693e:	f7ff fabc 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_Init(&htim1) != HAL_OK)
 8006942:	481a      	ldr	r0, [pc, #104]	; (80069ac <MX_TIM1_Init+0xc0>)
 8006944:	f7fc f8a8 	bl	8002a98 <HAL_TIM_OC_Init>
 8006948:	b108      	cbz	r0, 800694e <MX_TIM1_Init+0x62>
    Error_Handler();
 800694a:	f7ff fab6 	bl	8005eba <Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800694e:	2400      	movs	r4, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8006950:	4669      	mov	r1, sp
 8006952:	4816      	ldr	r0, [pc, #88]	; (80069ac <MX_TIM1_Init+0xc0>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006954:	9400      	str	r4, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006956:	9401      	str	r4, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8006958:	f7fc f9f2 	bl	8002d40 <HAL_TIMEx_MasterConfigSynchronization>
 800695c:	b108      	cbz	r0, 8006962 <MX_TIM1_Init+0x76>
    Error_Handler();
 800695e:	f7ff faac 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8006962:	220c      	movs	r2, #12
 8006964:	a906      	add	r1, sp, #24
 8006966:	4811      	ldr	r0, [pc, #68]	; (80069ac <MX_TIM1_Init+0xc0>)
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8006968:	9406      	str	r4, [sp, #24]
  sConfigOC.Pulse = 0;
 800696a:	9407      	str	r4, [sp, #28]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800696c:	9408      	str	r4, [sp, #32]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800696e:	940a      	str	r4, [sp, #40]	; 0x28
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8006970:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8006972:	940c      	str	r4, [sp, #48]	; 0x30
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8006974:	f7fc f9b6 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006978:	b108      	cbz	r0, 800697e <MX_TIM1_Init+0x92>
    Error_Handler();
 800697a:	f7ff fa9e 	bl	8005eba <Error_Handler>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 800697e:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8006980:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8006984:	a90d      	add	r1, sp, #52	; 0x34
 8006986:	4809      	ldr	r0, [pc, #36]	; (80069ac <MX_TIM1_Init+0xc0>)
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8006988:	930d      	str	r3, [sp, #52]	; 0x34
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 800698a:	930e      	str	r3, [sp, #56]	; 0x38
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800698c:	930f      	str	r3, [sp, #60]	; 0x3c
  sBreakDeadTimeConfig.DeadTime = 0;
 800698e:	9310      	str	r3, [sp, #64]	; 0x40
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 8006990:	9311      	str	r3, [sp, #68]	; 0x44
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8006992:	9212      	str	r2, [sp, #72]	; 0x48
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8006994:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8006996:	f7fc f9f5 	bl	8002d84 <HAL_TIMEx_ConfigBreakDeadTime>
 800699a:	b108      	cbz	r0, 80069a0 <MX_TIM1_Init+0xb4>
    Error_Handler();
 800699c:	f7ff fa8d 	bl	8005eba <Error_Handler>
  HAL_TIM_MspPostInit(&htim1);
 80069a0:	4802      	ldr	r0, [pc, #8]	; (80069ac <MX_TIM1_Init+0xc0>)
 80069a2:	f7ff ff19 	bl	80067d8 <HAL_TIM_MspPostInit>
}
 80069a6:	b014      	add	sp, #80	; 0x50
 80069a8:	bd10      	pop	{r4, pc}
 80069aa:	bf00      	nop
 80069ac:	200047a0 	.word	0x200047a0
 80069b0:	40010000 	.word	0x40010000

080069b4 <MX_TIM2_Init>:
{
 80069b4:	b510      	push	{r4, lr}
 80069b6:	b08e      	sub	sp, #56	; 0x38
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 80069b8:	2210      	movs	r2, #16
 80069ba:	2100      	movs	r1, #0
 80069bc:	a803      	add	r0, sp, #12
 80069be:	f000 fa7e 	bl	8006ebe <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80069c2:	2400      	movs	r4, #0
  TIM_OC_InitTypeDef sConfigOC = {0};
 80069c4:	221c      	movs	r2, #28
 80069c6:	4621      	mov	r1, r4
 80069c8:	eb0d 0002 	add.w	r0, sp, r2
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80069cc:	9401      	str	r4, [sp, #4]
 80069ce:	9402      	str	r4, [sp, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 80069d0:	f000 fa75 	bl	8006ebe <memset>
  htim2.Instance = TIM2;
 80069d4:	481f      	ldr	r0, [pc, #124]	; (8006a54 <MX_TIM2_Init+0xa0>)
 80069d6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  htim2.Init.Prescaler = 0;
 80069da:	e880 0018 	stmia.w	r0, {r3, r4}
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80069de:	6084      	str	r4, [r0, #8]
  htim2.Init.Period = 0;
 80069e0:	60c4      	str	r4, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80069e2:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 80069e4:	f7fc f83e 	bl	8002a64 <HAL_TIM_Base_Init>
 80069e8:	b108      	cbz	r0, 80069ee <MX_TIM2_Init+0x3a>
    Error_Handler();
 80069ea:	f7ff fa66 	bl	8005eba <Error_Handler>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80069ee:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 80069f2:	a903      	add	r1, sp, #12
 80069f4:	4817      	ldr	r0, [pc, #92]	; (8006a54 <MX_TIM2_Init+0xa0>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80069f6:	9303      	str	r3, [sp, #12]
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 80069f8:	f7fb fef7 	bl	80027ea <HAL_TIM_ConfigClockSource>
 80069fc:	b108      	cbz	r0, 8006a02 <MX_TIM2_Init+0x4e>
    Error_Handler();
 80069fe:	f7ff fa5c 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_Init(&htim2) != HAL_OK)
 8006a02:	4814      	ldr	r0, [pc, #80]	; (8006a54 <MX_TIM2_Init+0xa0>)
 8006a04:	f7fc f848 	bl	8002a98 <HAL_TIM_OC_Init>
 8006a08:	b108      	cbz	r0, 8006a0e <MX_TIM2_Init+0x5a>
    Error_Handler();
 8006a0a:	f7ff fa56 	bl	8005eba <Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006a0e:	2400      	movs	r4, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8006a10:	a901      	add	r1, sp, #4
 8006a12:	4810      	ldr	r0, [pc, #64]	; (8006a54 <MX_TIM2_Init+0xa0>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006a14:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006a16:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8006a18:	f7fc f992 	bl	8002d40 <HAL_TIMEx_MasterConfigSynchronization>
 8006a1c:	b108      	cbz	r0, 8006a22 <MX_TIM2_Init+0x6e>
    Error_Handler();
 8006a1e:	f7ff fa4c 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006a22:	2200      	movs	r2, #0
 8006a24:	a907      	add	r1, sp, #28
 8006a26:	480b      	ldr	r0, [pc, #44]	; (8006a54 <MX_TIM2_Init+0xa0>)
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8006a28:	9407      	str	r4, [sp, #28]
  sConfigOC.Pulse = 0;
 8006a2a:	9408      	str	r4, [sp, #32]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8006a2c:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8006a2e:	940b      	str	r4, [sp, #44]	; 0x2c
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006a30:	f7fc f958 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006a34:	b108      	cbz	r0, 8006a3a <MX_TIM2_Init+0x86>
    Error_Handler();
 8006a36:	f7ff fa40 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006a3a:	2204      	movs	r2, #4
 8006a3c:	a907      	add	r1, sp, #28
 8006a3e:	4805      	ldr	r0, [pc, #20]	; (8006a54 <MX_TIM2_Init+0xa0>)
 8006a40:	f7fc f950 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006a44:	b108      	cbz	r0, 8006a4a <MX_TIM2_Init+0x96>
    Error_Handler();
 8006a46:	f7ff fa38 	bl	8005eba <Error_Handler>
  HAL_TIM_MspPostInit(&htim2);
 8006a4a:	4802      	ldr	r0, [pc, #8]	; (8006a54 <MX_TIM2_Init+0xa0>)
 8006a4c:	f7ff fec4 	bl	80067d8 <HAL_TIM_MspPostInit>
}
 8006a50:	b00e      	add	sp, #56	; 0x38
 8006a52:	bd10      	pop	{r4, pc}
 8006a54:	200047dc 	.word	0x200047dc

08006a58 <MX_TIM4_Init>:
{
 8006a58:	b510      	push	{r4, lr}
 8006a5a:	b08e      	sub	sp, #56	; 0x38
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8006a5c:	2210      	movs	r2, #16
 8006a5e:	2100      	movs	r1, #0
 8006a60:	a803      	add	r0, sp, #12
 8006a62:	f000 fa2c 	bl	8006ebe <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006a66:	2400      	movs	r4, #0
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006a68:	221c      	movs	r2, #28
 8006a6a:	4621      	mov	r1, r4
 8006a6c:	eb0d 0002 	add.w	r0, sp, r2
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006a70:	9401      	str	r4, [sp, #4]
 8006a72:	9402      	str	r4, [sp, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006a74:	f000 fa23 	bl	8006ebe <memset>
  htim4.Instance = TIM4;
 8006a78:	481b      	ldr	r0, [pc, #108]	; (8006ae8 <MX_TIM4_Init+0x90>)
 8006a7a:	4b1c      	ldr	r3, [pc, #112]	; (8006aec <MX_TIM4_Init+0x94>)
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006a7c:	6084      	str	r4, [r0, #8]
  htim4.Init.Prescaler = 0;
 8006a7e:	e880 0018 	stmia.w	r0, {r3, r4}
  htim4.Init.Period = 0;
 8006a82:	60c4      	str	r4, [r0, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8006a84:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 8006a86:	f7fb ffed 	bl	8002a64 <HAL_TIM_Base_Init>
 8006a8a:	b108      	cbz	r0, 8006a90 <MX_TIM4_Init+0x38>
    Error_Handler();
 8006a8c:	f7ff fa15 	bl	8005eba <Error_Handler>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8006a90:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 8006a94:	a903      	add	r1, sp, #12
 8006a96:	4814      	ldr	r0, [pc, #80]	; (8006ae8 <MX_TIM4_Init+0x90>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8006a98:	9303      	str	r3, [sp, #12]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 8006a9a:	f7fb fea6 	bl	80027ea <HAL_TIM_ConfigClockSource>
 8006a9e:	b108      	cbz	r0, 8006aa4 <MX_TIM4_Init+0x4c>
    Error_Handler();
 8006aa0:	f7ff fa0b 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_Init(&htim4) != HAL_OK)
 8006aa4:	4810      	ldr	r0, [pc, #64]	; (8006ae8 <MX_TIM4_Init+0x90>)
 8006aa6:	f7fb fff7 	bl	8002a98 <HAL_TIM_OC_Init>
 8006aaa:	b108      	cbz	r0, 8006ab0 <MX_TIM4_Init+0x58>
    Error_Handler();
 8006aac:	f7ff fa05 	bl	8005eba <Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006ab0:	2400      	movs	r4, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 8006ab2:	a901      	add	r1, sp, #4
 8006ab4:	480c      	ldr	r0, [pc, #48]	; (8006ae8 <MX_TIM4_Init+0x90>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006ab6:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006ab8:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 8006aba:	f7fc f941 	bl	8002d40 <HAL_TIMEx_MasterConfigSynchronization>
 8006abe:	b108      	cbz	r0, 8006ac4 <MX_TIM4_Init+0x6c>
    Error_Handler();
 8006ac0:	f7ff f9fb 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006ac4:	2204      	movs	r2, #4
 8006ac6:	a907      	add	r1, sp, #28
 8006ac8:	4807      	ldr	r0, [pc, #28]	; (8006ae8 <MX_TIM4_Init+0x90>)
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8006aca:	9407      	str	r4, [sp, #28]
  sConfigOC.Pulse = 0;
 8006acc:	9408      	str	r4, [sp, #32]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8006ace:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8006ad0:	940b      	str	r4, [sp, #44]	; 0x2c
  if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006ad2:	f7fc f907 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006ad6:	b108      	cbz	r0, 8006adc <MX_TIM4_Init+0x84>
    Error_Handler();
 8006ad8:	f7ff f9ef 	bl	8005eba <Error_Handler>
  HAL_TIM_MspPostInit(&htim4);
 8006adc:	4802      	ldr	r0, [pc, #8]	; (8006ae8 <MX_TIM4_Init+0x90>)
 8006ade:	f7ff fe7b 	bl	80067d8 <HAL_TIM_MspPostInit>
}
 8006ae2:	b00e      	add	sp, #56	; 0x38
 8006ae4:	bd10      	pop	{r4, pc}
 8006ae6:	bf00      	nop
 8006ae8:	200046ec 	.word	0x200046ec
 8006aec:	40000800 	.word	0x40000800

08006af0 <MX_TIM5_Init>:
{
 8006af0:	b510      	push	{r4, lr}
 8006af2:	b08e      	sub	sp, #56	; 0x38
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8006af4:	2210      	movs	r2, #16
 8006af6:	2100      	movs	r1, #0
 8006af8:	a803      	add	r0, sp, #12
 8006afa:	f000 f9e0 	bl	8006ebe <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006afe:	2400      	movs	r4, #0
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006b00:	221c      	movs	r2, #28
 8006b02:	4621      	mov	r1, r4
 8006b04:	eb0d 0002 	add.w	r0, sp, r2
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006b08:	9401      	str	r4, [sp, #4]
 8006b0a:	9402      	str	r4, [sp, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006b0c:	f000 f9d7 	bl	8006ebe <memset>
  htim5.Instance = TIM5;
 8006b10:	481f      	ldr	r0, [pc, #124]	; (8006b90 <MX_TIM5_Init+0xa0>)
 8006b12:	4b20      	ldr	r3, [pc, #128]	; (8006b94 <MX_TIM5_Init+0xa4>)
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006b14:	6084      	str	r4, [r0, #8]
  htim5.Init.Prescaler = 0;
 8006b16:	e880 0018 	stmia.w	r0, {r3, r4}
  htim5.Init.Period = 0;
 8006b1a:	60c4      	str	r4, [r0, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8006b1c:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8006b1e:	f7fb ffa1 	bl	8002a64 <HAL_TIM_Base_Init>
 8006b22:	b108      	cbz	r0, 8006b28 <MX_TIM5_Init+0x38>
    Error_Handler();
 8006b24:	f7ff f9c9 	bl	8005eba <Error_Handler>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8006b28:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8006b2c:	a903      	add	r1, sp, #12
 8006b2e:	4818      	ldr	r0, [pc, #96]	; (8006b90 <MX_TIM5_Init+0xa0>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8006b30:	9303      	str	r3, [sp, #12]
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8006b32:	f7fb fe5a 	bl	80027ea <HAL_TIM_ConfigClockSource>
 8006b36:	b108      	cbz	r0, 8006b3c <MX_TIM5_Init+0x4c>
    Error_Handler();
 8006b38:	f7ff f9bf 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_Init(&htim5) != HAL_OK)
 8006b3c:	4814      	ldr	r0, [pc, #80]	; (8006b90 <MX_TIM5_Init+0xa0>)
 8006b3e:	f7fb ffab 	bl	8002a98 <HAL_TIM_OC_Init>
 8006b42:	b108      	cbz	r0, 8006b48 <MX_TIM5_Init+0x58>
    Error_Handler();
 8006b44:	f7ff f9b9 	bl	8005eba <Error_Handler>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006b48:	2400      	movs	r4, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8006b4a:	a901      	add	r1, sp, #4
 8006b4c:	4810      	ldr	r0, [pc, #64]	; (8006b90 <MX_TIM5_Init+0xa0>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006b4e:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006b50:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8006b52:	f7fc f8f5 	bl	8002d40 <HAL_TIMEx_MasterConfigSynchronization>
 8006b56:	b108      	cbz	r0, 8006b5c <MX_TIM5_Init+0x6c>
    Error_Handler();
 8006b58:	f7ff f9af 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006b5c:	2200      	movs	r2, #0
 8006b5e:	a907      	add	r1, sp, #28
 8006b60:	480b      	ldr	r0, [pc, #44]	; (8006b90 <MX_TIM5_Init+0xa0>)
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8006b62:	9407      	str	r4, [sp, #28]
  sConfigOC.Pulse = 0;
 8006b64:	9408      	str	r4, [sp, #32]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8006b66:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8006b68:	940b      	str	r4, [sp, #44]	; 0x2c
  if (HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006b6a:	f7fc f8bb 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006b6e:	b108      	cbz	r0, 8006b74 <MX_TIM5_Init+0x84>
    Error_Handler();
 8006b70:	f7ff f9a3 	bl	8005eba <Error_Handler>
  if (HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006b74:	2204      	movs	r2, #4
 8006b76:	a907      	add	r1, sp, #28
 8006b78:	4805      	ldr	r0, [pc, #20]	; (8006b90 <MX_TIM5_Init+0xa0>)
 8006b7a:	f7fc f8b3 	bl	8002ce4 <HAL_TIM_OC_ConfigChannel>
 8006b7e:	b108      	cbz	r0, 8006b84 <MX_TIM5_Init+0x94>
    Error_Handler();
 8006b80:	f7ff f99b 	bl	8005eba <Error_Handler>
  HAL_TIM_MspPostInit(&htim5);
 8006b84:	4802      	ldr	r0, [pc, #8]	; (8006b90 <MX_TIM5_Init+0xa0>)
 8006b86:	f7ff fe27 	bl	80067d8 <HAL_TIM_MspPostInit>
}
 8006b8a:	b00e      	add	sp, #56	; 0x38
 8006b8c:	bd10      	pop	{r4, pc}
 8006b8e:	bf00      	nop
 8006b90:	20004728 	.word	0x20004728
 8006b94:	40000c00 	.word	0x40000c00

08006b98 <MX_USART1_UART_Init>:
DMA_HandleTypeDef hdma_usart3_tx;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8006b98:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 8006b9a:	480b      	ldr	r0, [pc, #44]	; (8006bc8 <MX_USART1_UART_Init+0x30>)
  huart1.Init.BaudRate = 9600;
 8006b9c:	4b0b      	ldr	r3, [pc, #44]	; (8006bcc <MX_USART1_UART_Init+0x34>)
 8006b9e:	f44f 5e16 	mov.w	lr, #9600	; 0x2580
 8006ba2:	e880 4008 	stmia.w	r0, {r3, lr}
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 8006ba6:	220c      	movs	r2, #12
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8006ba8:	2300      	movs	r3, #0
 8006baa:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8006bac:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8006bae:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8006bb0:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006bb2:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8006bb4:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8006bb6:	f7fc fa25 	bl	8003004 <HAL_UART_Init>
 8006bba:	b118      	cbz	r0, 8006bc4 <MX_USART1_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 8006bbc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8006bc0:	f7ff b97b 	b.w	8005eba <Error_Handler>
 8006bc4:	bd08      	pop	{r3, pc}
 8006bc6:	bf00      	nop
 8006bc8:	20004918 	.word	0x20004918
 8006bcc:	40011000 	.word	0x40011000

08006bd0 <MX_USART3_UART_Init>:
/* USART3 init function */

void MX_USART3_UART_Init(void)
{
 8006bd0:	b508      	push	{r3, lr}

  huart3.Instance = USART3;
 8006bd2:	480b      	ldr	r0, [pc, #44]	; (8006c00 <MX_USART3_UART_Init+0x30>)
  huart3.Init.BaudRate = 115200;
 8006bd4:	4b0b      	ldr	r3, [pc, #44]	; (8006c04 <MX_USART3_UART_Init+0x34>)
 8006bd6:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
 8006bda:	e880 4008 	stmia.w	r0, {r3, lr}
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
 8006bde:	220c      	movs	r2, #12
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 8006be0:	2300      	movs	r3, #0
 8006be2:	6083      	str	r3, [r0, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8006be4:	60c3      	str	r3, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8006be6:	6103      	str	r3, [r0, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 8006be8:	6142      	str	r2, [r0, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006bea:	6183      	str	r3, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 8006bec:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8006bee:	f7fc fa09 	bl	8003004 <HAL_UART_Init>
 8006bf2:	b118      	cbz	r0, 8006bfc <MX_USART3_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 8006bf4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8006bf8:	f7ff b95f 	b.w	8005eba <Error_Handler>
 8006bfc:	bd08      	pop	{r3, pc}
 8006bfe:	bf00      	nop
 8006c00:	20004878 	.word	0x20004878
 8006c04:	40004800 	.word	0x40004800

08006c08 <MX_USART6_UART_Init>:
/* USART6 init function */

void MX_USART6_UART_Init(void)
{
 8006c08:	b508      	push	{r3, lr}

  huart6.Instance = USART6;
 8006c0a:	480b      	ldr	r0, [pc, #44]	; (8006c38 <MX_USART6_UART_Init+0x30>)
  huart6.Init.BaudRate = 9600;
 8006c0c:	4b0b      	ldr	r3, [pc, #44]	; (8006c3c <MX_USART6_UART_Init+0x34>)
 8006c0e:	f44f 5e16 	mov.w	lr, #9600	; 0x2580
 8006c12:	e880 4008 	stmia.w	r0, {r3, lr}
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
 8006c16:	220c      	movs	r2, #12
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
 8006c18:	2300      	movs	r3, #0
 8006c1a:	6083      	str	r3, [r0, #8]
  huart6.Init.StopBits = UART_STOPBITS_1;
 8006c1c:	60c3      	str	r3, [r0, #12]
  huart6.Init.Parity = UART_PARITY_NONE;
 8006c1e:	6103      	str	r3, [r0, #16]
  huart6.Init.Mode = UART_MODE_TX_RX;
 8006c20:	6142      	str	r2, [r0, #20]
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006c22:	6183      	str	r3, [r0, #24]
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
 8006c24:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart6) != HAL_OK)
 8006c26:	f7fc f9ed 	bl	8003004 <HAL_UART_Init>
 8006c2a:	b118      	cbz	r0, 8006c34 <MX_USART6_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 8006c2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8006c30:	f7ff b943 	b.w	8005eba <Error_Handler>
 8006c34:	bd08      	pop	{r3, pc}
 8006c36:	bf00      	nop
 8006c38:	20004958 	.word	0x20004958
 8006c3c:	40011400 	.word	0x40011400

08006c40 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8006c40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006c44:	4606      	mov	r6, r0
 8006c46:	b08c      	sub	sp, #48	; 0x30

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006c48:	2214      	movs	r2, #20
 8006c4a:	2100      	movs	r1, #0
 8006c4c:	a807      	add	r0, sp, #28
 8006c4e:	f000 f936 	bl	8006ebe <memset>
  if(uartHandle->Instance==USART1)
 8006c52:	6833      	ldr	r3, [r6, #0]
 8006c54:	4a62      	ldr	r2, [pc, #392]	; (8006de0 <HAL_UART_MspInit+0x1a0>)
 8006c56:	4293      	cmp	r3, r2
 8006c58:	d125      	bne.n	8006ca6 <HAL_UART_MspInit+0x66>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8006c5a:	4b62      	ldr	r3, [pc, #392]	; (8006de4 <HAL_UART_MspInit+0x1a4>)
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006c5c:	4862      	ldr	r0, [pc, #392]	; (8006de8 <HAL_UART_MspInit+0x1a8>)
    __HAL_RCC_USART1_CLK_ENABLE();
 8006c5e:	2100      	movs	r1, #0
 8006c60:	9100      	str	r1, [sp, #0]
 8006c62:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006c64:	f042 0210 	orr.w	r2, r2, #16
 8006c68:	645a      	str	r2, [r3, #68]	; 0x44
 8006c6a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006c6c:	f002 0210 	and.w	r2, r2, #16
 8006c70:	9200      	str	r2, [sp, #0]
 8006c72:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006c74:	9101      	str	r1, [sp, #4]
 8006c76:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006c78:	f042 0201 	orr.w	r2, r2, #1
 8006c7c:	631a      	str	r2, [r3, #48]	; 0x30
 8006c7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006c80:	f003 0301 	and.w	r3, r3, #1
 8006c84:	9301      	str	r3, [sp, #4]
 8006c86:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8006c88:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8006c8c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006c8e:	2302      	movs	r3, #2
 8006c90:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006c92:	2301      	movs	r3, #1
 8006c94:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006c96:	2303      	movs	r3, #3
 8006c98:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8006c9a:	2307      	movs	r3, #7
 8006c9c:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006c9e:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006ca0:	f7fa f8b8 	bl	8000e14 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART6_MspInit 1 */

  /* USER CODE END USART6_MspInit 1 */
  }
}
 8006ca4:	e073      	b.n	8006d8e <HAL_UART_MspInit+0x14e>
  else if(uartHandle->Instance==USART3)
 8006ca6:	4a51      	ldr	r2, [pc, #324]	; (8006dec <HAL_UART_MspInit+0x1ac>)
 8006ca8:	4293      	cmp	r3, r2
 8006caa:	d173      	bne.n	8006d94 <HAL_UART_MspInit+0x154>
    __HAL_RCC_USART3_CLK_ENABLE();
 8006cac:	2500      	movs	r5, #0
 8006cae:	4b4d      	ldr	r3, [pc, #308]	; (8006de4 <HAL_UART_MspInit+0x1a4>)
 8006cb0:	9502      	str	r5, [sp, #8]
 8006cb2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006cb4:	484e      	ldr	r0, [pc, #312]	; (8006df0 <HAL_UART_MspInit+0x1b0>)
    __HAL_RCC_USART3_CLK_ENABLE();
 8006cb6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8006cba:	641a      	str	r2, [r3, #64]	; 0x40
 8006cbc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006cbe:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 8006cc2:	9202      	str	r2, [sp, #8]
 8006cc4:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006cc6:	9503      	str	r5, [sp, #12]
 8006cc8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006cca:	f042 0204 	orr.w	r2, r2, #4
 8006cce:	631a      	str	r2, [r3, #48]	; 0x30
 8006cd0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006cd2:	f002 0204 	and.w	r2, r2, #4
 8006cd6:	9203      	str	r2, [sp, #12]
 8006cd8:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006cda:	9504      	str	r5, [sp, #16]
 8006cdc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006cde:	f042 0202 	orr.w	r2, r2, #2
 8006ce2:	631a      	str	r2, [r3, #48]	; 0x30
 8006ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006ce6:	f003 0302 	and.w	r3, r3, #2
 8006cea:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8006cec:	2407      	movs	r4, #7
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006cee:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8006cf0:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 8006cf2:	2320      	movs	r3, #32
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006cf4:	f04f 0a02 	mov.w	sl, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006cf8:	f04f 0901 	mov.w	r9, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006cfc:	f04f 0803 	mov.w	r8, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006d00:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 8006d02:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8006d04:	f44f 6780 	mov.w	r7, #1024	; 0x400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006d08:	f8cd a020 	str.w	sl, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006d0c:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006d10:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006d14:	f7fa f87e 	bl	8000e14 <HAL_GPIO_Init>
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8006d18:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006d1a:	4836      	ldr	r0, [pc, #216]	; (8006df4 <HAL_UART_MspInit+0x1b4>)
    hdma_usart3_rx.Instance = DMA1_Stream1;
 8006d1c:	4c36      	ldr	r4, [pc, #216]	; (8006df8 <HAL_UART_MspInit+0x1b8>)
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8006d1e:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006d20:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006d22:	f8cd a020 	str.w	sl, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006d26:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006d2a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006d2e:	f7fa f871 	bl	8000e14 <HAL_GPIO_Init>
    hdma_usart3_rx.Init.Channel = DMA_CHANNEL_4;
 8006d32:	4b32      	ldr	r3, [pc, #200]	; (8006dfc <HAL_UART_MspInit+0x1bc>)
    hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8006d34:	60a5      	str	r5, [r4, #8]
    hdma_usart3_rx.Init.Channel = DMA_CHANNEL_4;
 8006d36:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 8006d3a:	4620      	mov	r0, r4
    hdma_usart3_rx.Init.Channel = DMA_CHANNEL_4;
 8006d3c:	e884 4008 	stmia.w	r4, {r3, lr}
    hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8006d40:	60e5      	str	r5, [r4, #12]
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8006d42:	6127      	str	r7, [r4, #16]
    hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8006d44:	6165      	str	r5, [r4, #20]
    hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8006d46:	61a5      	str	r5, [r4, #24]
    hdma_usart3_rx.Init.Mode = DMA_NORMAL;
 8006d48:	61e5      	str	r5, [r4, #28]
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_LOW;
 8006d4a:	6225      	str	r5, [r4, #32]
    hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8006d4c:	6265      	str	r5, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 8006d4e:	f7f9 fed9 	bl	8000b04 <HAL_DMA_Init>
 8006d52:	b108      	cbz	r0, 8006d58 <HAL_UART_MspInit+0x118>
      Error_Handler();
 8006d54:	f7ff f8b1 	bl	8005eba <Error_Handler>
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart3_rx);
 8006d58:	6374      	str	r4, [r6, #52]	; 0x34
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006d5a:	4b29      	ldr	r3, [pc, #164]	; (8006e00 <HAL_UART_MspInit+0x1c0>)
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart3_rx);
 8006d5c:	63a6      	str	r6, [r4, #56]	; 0x38
    hdma_usart3_tx.Instance = DMA1_Stream4;
 8006d5e:	4c29      	ldr	r4, [pc, #164]	; (8006e04 <HAL_UART_MspInit+0x1c4>)
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006d60:	f04f 6560 	mov.w	r5, #234881024	; 0xe000000
 8006d64:	2740      	movs	r7, #64	; 0x40
 8006d66:	e884 00a8 	stmia.w	r4, {r3, r5, r7}
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006d6a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8006d6e:	2300      	movs	r3, #0
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 8006d70:	4620      	mov	r0, r4
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8006d72:	60e3      	str	r3, [r4, #12]
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006d74:	6122      	str	r2, [r4, #16]
    hdma_usart3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8006d76:	6163      	str	r3, [r4, #20]
    hdma_usart3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8006d78:	61a3      	str	r3, [r4, #24]
    hdma_usart3_tx.Init.Mode = DMA_NORMAL;
 8006d7a:	61e3      	str	r3, [r4, #28]
    hdma_usart3_tx.Init.Priority = DMA_PRIORITY_LOW;
 8006d7c:	6223      	str	r3, [r4, #32]
    hdma_usart3_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8006d7e:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 8006d80:	f7f9 fec0 	bl	8000b04 <HAL_DMA_Init>
 8006d84:	b108      	cbz	r0, 8006d8a <HAL_UART_MspInit+0x14a>
      Error_Handler();
 8006d86:	f7ff f898 	bl	8005eba <Error_Handler>
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart3_tx);
 8006d8a:	6334      	str	r4, [r6, #48]	; 0x30
 8006d8c:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8006d8e:	b00c      	add	sp, #48	; 0x30
 8006d90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  else if(uartHandle->Instance==USART6)
 8006d94:	4a1c      	ldr	r2, [pc, #112]	; (8006e08 <HAL_UART_MspInit+0x1c8>)
 8006d96:	4293      	cmp	r3, r2
 8006d98:	d1f9      	bne.n	8006d8e <HAL_UART_MspInit+0x14e>
    __HAL_RCC_USART6_CLK_ENABLE();
 8006d9a:	4b12      	ldr	r3, [pc, #72]	; (8006de4 <HAL_UART_MspInit+0x1a4>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006d9c:	4814      	ldr	r0, [pc, #80]	; (8006df0 <HAL_UART_MspInit+0x1b0>)
    __HAL_RCC_USART6_CLK_ENABLE();
 8006d9e:	2100      	movs	r1, #0
 8006da0:	9105      	str	r1, [sp, #20]
 8006da2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006da4:	f042 0220 	orr.w	r2, r2, #32
 8006da8:	645a      	str	r2, [r3, #68]	; 0x44
 8006daa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006dac:	f002 0220 	and.w	r2, r2, #32
 8006db0:	9205      	str	r2, [sp, #20]
 8006db2:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006db4:	9106      	str	r1, [sp, #24]
 8006db6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006db8:	f042 0204 	orr.w	r2, r2, #4
 8006dbc:	631a      	str	r2, [r3, #48]	; 0x30
 8006dbe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006dc0:	f003 0304 	and.w	r3, r3, #4
 8006dc4:	9306      	str	r3, [sp, #24]
 8006dc6:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8006dc8:	23c0      	movs	r3, #192	; 0xc0
 8006dca:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006dcc:	2302      	movs	r3, #2
 8006dce:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006dd0:	2301      	movs	r3, #1
 8006dd2:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006dd4:	2303      	movs	r3, #3
 8006dd6:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8006dd8:	2308      	movs	r3, #8
 8006dda:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006ddc:	a907      	add	r1, sp, #28
 8006dde:	e75f      	b.n	8006ca0 <HAL_UART_MspInit+0x60>
 8006de0:	40011000 	.word	0x40011000
 8006de4:	40023800 	.word	0x40023800
 8006de8:	40020000 	.word	0x40020000
 8006dec:	40004800 	.word	0x40004800
 8006df0:	40020800 	.word	0x40020800
 8006df4:	40020400 	.word	0x40020400
 8006df8:	20004818 	.word	0x20004818
 8006dfc:	40026028 	.word	0x40026028
 8006e00:	40026070 	.word	0x40026070
 8006e04:	200048b8 	.word	0x200048b8
 8006e08:	40011400 	.word	0x40011400

08006e0c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8006e0c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8006e44 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8006e10:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8006e12:	e003      	b.n	8006e1c <LoopCopyDataInit>

08006e14 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8006e14:	4b0c      	ldr	r3, [pc, #48]	; (8006e48 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8006e16:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8006e18:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8006e1a:	3104      	adds	r1, #4

08006e1c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8006e1c:	480b      	ldr	r0, [pc, #44]	; (8006e4c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8006e1e:	4b0c      	ldr	r3, [pc, #48]	; (8006e50 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8006e20:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8006e22:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8006e24:	d3f6      	bcc.n	8006e14 <CopyDataInit>
  ldr  r2, =_sbss
 8006e26:	4a0b      	ldr	r2, [pc, #44]	; (8006e54 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8006e28:	e002      	b.n	8006e30 <LoopFillZerobss>

08006e2a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8006e2a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8006e2c:	f842 3b04 	str.w	r3, [r2], #4

08006e30 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8006e30:	4b09      	ldr	r3, [pc, #36]	; (8006e58 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8006e32:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8006e34:	d3f9      	bcc.n	8006e2a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8006e36:	f7ff fb15 	bl	8006464 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8006e3a:	f000 f811 	bl	8006e60 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8006e3e:	f7ff f80b 	bl	8005e58 <main>
  bx  lr    
 8006e42:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8006e44:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8006e48:	08006f98 	.word	0x08006f98
  ldr  r0, =_sdata
 8006e4c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8006e50:	20000014 	.word	0x20000014
  ldr  r2, =_sbss
 8006e54:	200001b4 	.word	0x200001b4
  ldr  r3, = _ebss
 8006e58:	20004998 	.word	0x20004998

08006e5c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8006e5c:	e7fe      	b.n	8006e5c <ADC_IRQHandler>
	...

08006e60 <__libc_init_array>:
 8006e60:	b570      	push	{r4, r5, r6, lr}
 8006e62:	4e0d      	ldr	r6, [pc, #52]	; (8006e98 <__libc_init_array+0x38>)
 8006e64:	4c0d      	ldr	r4, [pc, #52]	; (8006e9c <__libc_init_array+0x3c>)
 8006e66:	1ba4      	subs	r4, r4, r6
 8006e68:	10a4      	asrs	r4, r4, #2
 8006e6a:	2500      	movs	r5, #0
 8006e6c:	42a5      	cmp	r5, r4
 8006e6e:	d109      	bne.n	8006e84 <__libc_init_array+0x24>
 8006e70:	4e0b      	ldr	r6, [pc, #44]	; (8006ea0 <__libc_init_array+0x40>)
 8006e72:	4c0c      	ldr	r4, [pc, #48]	; (8006ea4 <__libc_init_array+0x44>)
 8006e74:	f000 f82c 	bl	8006ed0 <_init>
 8006e78:	1ba4      	subs	r4, r4, r6
 8006e7a:	10a4      	asrs	r4, r4, #2
 8006e7c:	2500      	movs	r5, #0
 8006e7e:	42a5      	cmp	r5, r4
 8006e80:	d105      	bne.n	8006e8e <__libc_init_array+0x2e>
 8006e82:	bd70      	pop	{r4, r5, r6, pc}
 8006e84:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006e88:	4798      	blx	r3
 8006e8a:	3501      	adds	r5, #1
 8006e8c:	e7ee      	b.n	8006e6c <__libc_init_array+0xc>
 8006e8e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006e92:	4798      	blx	r3
 8006e94:	3501      	adds	r5, #1
 8006e96:	e7f2      	b.n	8006e7e <__libc_init_array+0x1e>
 8006e98:	08006f90 	.word	0x08006f90
 8006e9c:	08006f90 	.word	0x08006f90
 8006ea0:	08006f90 	.word	0x08006f90
 8006ea4:	08006f94 	.word	0x08006f94

08006ea8 <memcpy>:
 8006ea8:	b510      	push	{r4, lr}
 8006eaa:	1e43      	subs	r3, r0, #1
 8006eac:	440a      	add	r2, r1
 8006eae:	4291      	cmp	r1, r2
 8006eb0:	d100      	bne.n	8006eb4 <memcpy+0xc>
 8006eb2:	bd10      	pop	{r4, pc}
 8006eb4:	f811 4b01 	ldrb.w	r4, [r1], #1
 8006eb8:	f803 4f01 	strb.w	r4, [r3, #1]!
 8006ebc:	e7f7      	b.n	8006eae <memcpy+0x6>

08006ebe <memset>:
 8006ebe:	4402      	add	r2, r0
 8006ec0:	4603      	mov	r3, r0
 8006ec2:	4293      	cmp	r3, r2
 8006ec4:	d100      	bne.n	8006ec8 <memset+0xa>
 8006ec6:	4770      	bx	lr
 8006ec8:	f803 1b01 	strb.w	r1, [r3], #1
 8006ecc:	e7f9      	b.n	8006ec2 <memset+0x4>
	...

08006ed0 <_init>:
 8006ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006ed2:	bf00      	nop
 8006ed4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006ed6:	bc08      	pop	{r3}
 8006ed8:	469e      	mov	lr, r3
 8006eda:	4770      	bx	lr

08006edc <_fini>:
 8006edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006ede:	bf00      	nop
 8006ee0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006ee2:	bc08      	pop	{r3}
 8006ee4:	469e      	mov	lr, r3
 8006ee6:	4770      	bx	lr
